// Package zoomapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.0 DO NOT EDIT.
package zoomapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	Openapi_authorizationScopes = "openapi_authorization.Scopes"
	Openapi_oauthScopes         = "openapi_oauth.Scopes"
)

// InMeetingControlJSONBody defines parameters for InMeetingControl.
type InMeetingControlJSONBody struct {
	// Method The in-meeting method to control:
	// * `recording.start` &mdash; Start the recording.
	// * `recording.stop` &mdash; Stop the recording.
	// * `recording.pause` &mdash; Pause the recording.
	// * `recording.resume` &mdash; Resume a paused recording.
	// * `participant.invite` &mdash; Invite a participant to the meeting.
	// * `participant.invite.callout` &mdash; Invite a participant to the meeting through [call out (phone)](https://support.zoom.us/hc/en-us/articles/4404535651085-Inviting-others-by-phone-call-out).
	// * `participant.invite.room_system_callout` &mdash; Invite a participant to the meeting through [call out (room system)].
	Method *string `json:"method,omitempty"`

	// Params The in-meeting parameters.
	Params *struct {
		// CallType The type of call out. Use a value of `h323` or `sip`. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field.
		CallType *string `json:"call_type,omitempty"`

		// Contacts The user's email address or the user ID, up to a maximum of 10 contacts. The account must be a part of the meeting host's account.
		Contacts *[]struct {
			// Email The user's email address. Use this value if you do not have the user's ID.
			//
			// If you pass the `id` value, the API ignores this query parameter.
			Email *string `json:"email,omitempty"`

			// Id The user's ID.
			Id *string `json:"id,omitempty"`
		} `json:"contacts,omitempty"`

		// DeviceIp The user's device IP address or URI. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field.
		DeviceIp *string `json:"device_ip,omitempty"`

		// H323Headers Enable customers to leverage services that require customization of the FROM header to identify the caller. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field and the `h323` value for the `call_type` field.
		H323Headers *struct {
			// FromDisplayName Custom name that will be used within the h323 Header.
			FromDisplayName *string `json:"from_display_name,omitempty"`

			// ToDisplayName Custom remote name that will be used within the meeting.
			ToDisplayName *string `json:"to_display_name,omitempty"`
		} `json:"h323_headers,omitempty"`

		// InviteOptions Information about the `participant.invite.callout` settings.
		InviteOptions *struct {
			// RequireGreeting Whether to require a greeting before being connected. Use this field if you pass the `participant.invite.callout` value for the `method` field.
			RequireGreeting *bool `json:"require_greeting,omitempty"`

			// RequirePressingOne Whether to require pressing 1 before being connected. Use this field if you pass the `participant.invite.callout` value for the `method` field.
			RequirePressingOne *bool `json:"require_pressing_one,omitempty"`
		} `json:"invite_options,omitempty"`

		// InviteeName The user's name to display in the meeting. Use this field if you pass the `participant.invite.callout` value for the `method` field.
		InviteeName *string `json:"invitee_name,omitempty"`

		// PhoneNumber The user's phone number. Use this field if you pass the `participant.invite.callout` value for the `method` field. As a best practice, ensure this includes a country code and area code.
		PhoneNumber *string `json:"phone_number,omitempty"`

		// SipHeaders Enable customers to leverage services that require customization of the FROM header to identify the caller. Use this field if you pass the `participant.invite.room_system_callout` value for the `method` field and the `sip` value for the `call_type` field.
		SipHeaders *struct {
			// AdditionalHeaders Ability to add 1 to 10 custom headers, each of which has a maximum length of 256 bytes to comply with SIP standards.  Custom headers would leverage header names starting with 'X-' per SIP guidelines.
			AdditionalHeaders *[]struct {
				// Key Additional custom SIP header's key.
				Key *string `json:"key,omitempty"`

				// Value Additional custom SIP header's value.
				Value *string `json:"value,omitempty"`
			} `json:"additional_headers,omitempty"`

			// FromDisplayName Custom name that will be used within the SIP Header.
			FromDisplayName *string `json:"from_display_name,omitempty"`

			// FromUri Custom URI that will be used within the SIP Header. The URI must start with 'sip:' or 'sips:' as a valid URI based on parameters defined by the platform.
			FromUri *string `json:"from_uri,omitempty"`

			// ToDisplayName Custom remote name that will be used within the meeting.
			ToDisplayName *string `json:"to_display_name,omitempty"`
		} `json:"sip_headers,omitempty"`
	} `json:"params,omitempty"`
}

// MeetingDeleteParams defines parameters for MeetingDelete.
type MeetingDeleteParams struct {
	// OccurrenceId The meeting or webinar occurrence ID.
	OccurrenceId *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty"`

	// ScheduleForReminder `true`: Notify host and alternative host about the meeting cancellation via email.
	// `false`: Do not send any email notification.
	ScheduleForReminder *bool `form:"schedule_for_reminder,omitempty" json:"schedule_for_reminder,omitempty"`

	// CancelMeetingReminder `true`: Notify registrants about the meeting cancellation via email.
	//
	// `false`: Do not send any email notification to meeting registrants.
	//
	// The default value of this field is `false`.
	CancelMeetingReminder *bool `form:"cancel_meeting_reminder,omitempty" json:"cancel_meeting_reminder,omitempty"`
}

// MeetingParams defines parameters for Meeting.
type MeetingParams struct {
	// OccurrenceId Meeting Occurrence ID. Provide this field to view meeting details of a particular occurrence of the [recurring meeting](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings).
	OccurrenceId *string `json:"occurrence_id,omitempty"`

	// ShowPreviousOccurrences Set the value of this field to `true` if you would like to view meeting details of all previous occurrences of a [recurring meeting](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings).
	ShowPreviousOccurrences *bool `json:"show_previous_occurrences,omitempty"`
}

// MeetingUpdateJSONBody defines parameters for MeetingUpdate.
type MeetingUpdateJSONBody struct {
	// Agenda Meeting description.
	Agenda *string `json:"agenda,omitempty"`

	// Duration Meeting duration (minutes). Used for scheduled meetings only.
	Duration *int `json:"duration,omitempty"`

	// Password Meeting passcode. Passcode may only contain the following characters: [a-z A-Z 0-9 @ - _ *] and can have a maximum of 10 characters.
	//
	// **Note:** If the account owner or the admin has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the passcode value provided here must meet those requirements.
	//
	//  If the requirements are enabled, you can view those requirements by calling either the [**Get user settings**](/docs/api-reference/zoom-api/methods#operation/userSettings) API or the [**Get account settings**](/docs/api-reference/zoom-api/ma#operation/accountSettings) API.
	Password *string `json:"password,omitempty"`

	// PreSchedule Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time):
	// * `true` &mdash; Create a prescheduled meeting.
	// * `false` &mdash; Create a regular meeting.
	PreSchedule *bool `json:"pre_schedule,omitempty"`

	// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
	Recurrence *struct {
		// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
		EndDateTime *time.Time `json:"end_date_time,omitempty"`

		// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
		EndTimes *int `json:"end_times,omitempty"`

		// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
		//
		// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
		MonthlyDay *int `json:"monthly_day,omitempty"`

		// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
		//  `-1` - Last week of the month.
		//  `1` - First week of the month.
		//  `2` - Second week of the month.
		//  `3` - Third week of the month.
		//  `4` - Fourth week of the month.
		MonthlyWeek *int `json:"monthly_week,omitempty"`

		// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
		//
		//
		//  `1` - Sunday.
		//  `2` - Monday.
		//  `3` - Tuesday.
		//  `4` -  Wednesday.
		//  `5` - Thursday.
		//  `6` - Friday.
		//  `7` - Saturday.
		MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

		// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
		//
		// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
		//
		RepeatInterval *int `json:"repeat_interval,omitempty"`

		// Type Recurrence meeting types:
		//  `1` - Daily.
		//  `2` - Weekly.
		//  `3` - Monthly.
		Type int `json:"type"`

		// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
		//
		//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
		//
		//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
		//
		//
		//  `1`  - Sunday.
		//  `2` - Monday.
		//  `3` - Tuesday.
		//  `4` -  Wednesday.
		//  `5` -  Thursday.
		//  `6` - Friday.
		//  `7` - Saturday.
		WeeklyDays *string `json:"weekly_days,omitempty"`
	} `json:"recurrence,omitempty"`

	// ScheduleFor The email address or `userId` of the user to schedule a meeting for.
	ScheduleFor *string `json:"schedule_for,omitempty"`

	// Settings Meeting settings.
	Settings *struct {
		// AllowMultipleDevices Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
		AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

		// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
		AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

		// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
		AlternativeHosts *string `json:"alternative_hosts,omitempty"`

		// AlternativeHostsEmailNotification Flag to determine whether to send email notifications to alternative hosts, default value is true.
		AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

		// ApprovalType Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**
		//
		//
		//
		// `0` - Automatically approve.
		//  `1` - Manually approve.
		//  `2` - No registration required.
		ApprovalType *int `json:"approval_type,omitempty"`

		// ApprovedOrDeniedCountriesOrRegions Approve or block users from specific regions/countries from joining this meeting.
		ApprovedOrDeniedCountriesOrRegions *struct {
			// ApprovedList List of countries/regions from where participants can join this meeting.
			ApprovedList *[]string `json:"approved_list,omitempty"`

			// DeniedList List of countries/regions from where participants can not join this meeting.
			DeniedList *[]string `json:"denied_list,omitempty"`

			// Enable `true`: Setting enabled to either allow users or block users from specific regions to join your meetings.
			//
			//
			// `false`: Setting disabled.
			Enable *bool `json:"enable,omitempty"`

			// Method Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.
			//
			//
			// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.
			//
			//
			// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
			Method *string `json:"method,omitempty"`
		} `json:"approved_or_denied_countries_or_regions,omitempty"`

		// Audio Determine how participants can join the audio portion of the meeting.
		//  `both` - Both Telephony and VoIP.
		//  `telephony` - Telephony only.
		//  `voip` - VoIP only.
		//  `thirdParty` - Third party audio conference.
		Audio *string `json:"audio,omitempty"`

		// AudioConferenceInfo Third party audio conference info.
		AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

		// AuthenticationDomains If user has configured [&quot;Sign Into Zoom with Specified Domains&quot;](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
		AuthenticationDomains *string `json:"authentication_domains,omitempty"`

		// AuthenticationException The participants added here will receive unique meeting invite links and bypass authentication.
		AuthenticationException *[]struct {
			// Email Email address of the participant.
			Email *openapi_types.Email `json:"email,omitempty"`

			// JoinUrl URL for participants to join the meeting
			JoinUrl *string `json:"join_url,omitempty"`

			// Name Name of the participant.
			Name *string `json:"name,omitempty"`
		} `json:"authentication_exception,omitempty"`

		// AuthenticationName Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
		AuthenticationName *string `json:"authentication_name,omitempty"`

		// AuthenticationOption Meeting authentication option id.
		AuthenticationOption *string `json:"authentication_option,omitempty"`

		// AutoRecording Automatic recording:
		//  `local` - Record on local.
		//  `cloud` -  Record on cloud.
		//  `none` - Disabled.
		AutoRecording *string `json:"auto_recording,omitempty"`

		// BreakoutRoom Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
		BreakoutRoom *struct {
			// Enable Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
			Enable *bool `json:"enable,omitempty"`

			// Rooms Create room(s).
			Rooms *[]struct {
				// Name Name of the breakout room.
				Name *string `json:"name,omitempty"`

				// Participants Email addresses of the participants who are to be assigned to the breakout room.
				Participants *[]string `json:"participants,omitempty"`
			} `json:"rooms,omitempty"`
		} `json:"breakout_room,omitempty"`

		// CalendarType Indicates the type of calendar integration used to schedule the meeting:
		// * `1` &mdash; [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
		// * `2` &mdash; [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
		//
		// Works with the `private_meeting` field to determine whether to share details of meetings or not.
		CalendarType *int `json:"calendar_type,omitempty"`

		// CloseRegistration Close registration after event date
		CloseRegistration *bool `json:"close_registration,omitempty"`

		// CnMeeting Host meeting in China.
		// Deprecated:
		CnMeeting *bool `json:"cn_meeting,omitempty"`

		// ContactEmail Contact email for registration
		ContactEmail *string `json:"contact_email,omitempty"`

		// ContactName Contact name for registration
		ContactName *string `json:"contact_name,omitempty"`

		// CustomKeys Custom keys and values assigned to the meeting.
		CustomKeys *[]struct {
			// Key Custom key associated with the user.
			Key *string `json:"key,omitempty"`

			// Value Value of the custom key associated with the user.
			Value *string `json:"value,omitempty"`
		} `json:"custom_keys,omitempty"`

		// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
		EmailNotification *bool `json:"email_notification,omitempty"`

		// EncryptionType Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.
		//
		//  The value of this field can be one of the following:
		//
		// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option.
		//
		//
		// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
		EncryptionType *string `json:"encryption_type,omitempty"`

		// EnforceLogin Only signed in users can join this meeting.
		//
		// **This field is deprecated and will not be supported in the future.**
		//
		//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
		// Deprecated:
		EnforceLogin *bool `json:"enforce_login,omitempty"`

		// EnforceLoginDomains Only signed in users with specified domains can join meetings.
		//
		// **This field is deprecated and will not be supported in the future.**
		//
		//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
		// Deprecated:
		EnforceLoginDomains *string `json:"enforce_login_domains,omitempty"`

		// FocusMode Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
		FocusMode *bool `json:"focus_mode,omitempty"`

		// GlobalDialInCountries List of global dial-in countries
		GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

		// GlobalDialInNumbers Global Dial-in Countries/Regions
		GlobalDialInNumbers *[]struct {
			// City City of the number, if any. For example, Chicago.
			City *string `json:"city,omitempty"`

			// Country Country code. For example, BR.
			Country *string `json:"country,omitempty"`

			// CountryName Full name of country. For example, Brazil.
			CountryName *string `json:"country_name,omitempty"`

			// Number Phone number. For example, +1 2332357613.
			Number *string `json:"number,omitempty"`

			// Type Type of number.
			Type *string `json:"type,omitempty"`
		} `json:"global_dial_in_numbers,omitempty"`

		// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
		HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

		// HostVideo Start video when the host joins the meeting.
		HostVideo *bool `json:"host_video,omitempty"`

		// InMeeting Host meeting in India.
		// Deprecated:
		InMeeting *bool `json:"in_meeting,omitempty"`

		// JbhTime If the value of &quot;join_before_host&quot; field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
		//
		// *  `0`: Allow participant to join anytime.
		// *  `5`: Allow participant to join 5 minutes before meeting start time.
		//  * `10`: Allow participant to join 10 minutes before meeting start time.
		JbhTime *int `json:"jbh_time,omitempty"`

		// JoinBeforeHost Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
		JoinBeforeHost *bool `json:"join_before_host,omitempty"`

		// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
		//
		// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
		LanguageInterpretation *struct {
			// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
			Enable *bool `json:"enable,omitempty"`

			// Interpreters Information about the meeting's language interpreters.
			Interpreters *[]struct {
				// Email The interpreter's email address.
				Email *openapi_types.Email `json:"email,omitempty"`

				// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
				//
				// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
				Languages *string `json:"languages,omitempty"`
			} `json:"interpreters,omitempty"`
		} `json:"language_interpretation,omitempty"`

		// MeetingAuthentication `true`- Only authenticated users can join meetings.
		MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

		// MeetingInvitees A list of the meeting's invitees.
		MeetingInvitees *[]struct {
			// Email The invitee's email address.
			Email *openapi_types.Email `json:"email,omitempty"`
		} `json:"meeting_invitees,omitempty"`

		// MuteUponEntry Mute participants upon entry.
		MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

		// ParticipantVideo Start video when participants join the meeting.
		ParticipantVideo *bool `json:"participant_video,omitempty"`

		// PrivateMeeting Whether the meeting is set as private.
		PrivateMeeting *bool `json:"private_meeting,omitempty"`

		// RegistrantsConfirmationEmail Whether to send registrants an email confirmation:
		// * `true` &mdash; Send a confirmation email.
		// * `false` &mdash; Do not send a confirmation email.
		RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

		// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
		//
		// * `true` &mdash; Send an email notification.
		// * `false` &mdash; Do not send an email notification.
		//
		//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
		RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

		// RegistrationType Registration type. Used for recurring meeting with fixed time only.
		//  `1` Attendees register once and can attend any of the occurrences.
		//  `2` Attendees need to register for each occurrence to attend.
		//  `3` Attendees register once and can choose one or more occurrences to attend.
		RegistrationType *int `json:"registration_type,omitempty"`

		// ShowShareButton Show social share buttons on the meeting registration page.
		// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
		ShowShareButton *bool `json:"show_share_button,omitempty"`

		// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
		//
		// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
		SignLanguageInterpretation *struct {
			// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
			Enable *bool `json:"enable,omitempty"`

			// Interpreters Information about the meeting's sign language interpreters.
			Interpreters *[]struct {
				// Email The interpreter's email address.
				Email *openapi_types.Email `json:"email,omitempty"`

				// SignLanguage The interpreter's sign language.
				//
				//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
				SignLanguage *string `json:"sign_language,omitempty"`
			} `json:"interpreters,omitempty"`
		} `json:"sign_language_interpretation,omitempty"`

		// UsePmi Use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
		UsePmi *bool `json:"use_pmi,omitempty"`

		// WaitingRoom Enable waiting room
		WaitingRoom *bool `json:"waiting_room,omitempty"`

		// Watermark Add watermark when viewing a shared screen.
		Watermark *bool `json:"watermark,omitempty"`
	} `json:"settings,omitempty"`

	// StartTime Meeting start time. When using a format like &quot;yyyy-MM-dd'T'HH:mm:ss'Z'&quot;, always use GMT time. When using a format like &quot;yyyy-MM-dd'T'HH:mm:ss&quot;, you should use local time and  specify the time zone. Only used for scheduled meetings and recurring meetings with a fixed time.
	StartTime *time.Time `json:"start_time,omitempty"`

	// TemplateId Unique identifier of the meeting template.
	//
	// Use this field if you would like to [schedule the meeting from a meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates#h_86f06cff-0852-4998-81c5-c83663c176fb). You can retrieve the value of this field by calling the [List meeting templates](https://marketplace.zoom.us/docs/api-reference/zoom-api/methods#operation/listMeetingTemplates) API.
	TemplateId *string `json:"template_id,omitempty"`

	// Timezone The timezone to assign to the `start_time` value. This field is only used for scheduled or recurring meetings with a fixed time.
	//
	// For a list of supported timezones and their formats, see our [timezone list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#timezones).
	Timezone *string `json:"timezone,omitempty"`

	// Topic Meeting topic.
	Topic *string `json:"topic,omitempty"`

	// TrackingFields Tracking fields
	TrackingFields *[]struct {
		// Field Tracking fields type
		Field *string `json:"field,omitempty"`

		// Value Tracking fields value
		Value *string `json:"value,omitempty"`
	} `json:"tracking_fields,omitempty"`

	// Type Meeting Types:
	//  `1` - Instant meeting.
	//  `2` - Scheduled meeting.
	//  `3` - Recurring meeting with no fixed time.
	//  `8` - Recurring meeting with a fixed time.
	Type *int `json:"type,omitempty"`
}

// MeetingUpdateParams defines parameters for MeetingUpdate.
type MeetingUpdateParams struct {
	// OccurrenceId Meeting occurrence id. Support change of agenda, start_time, duration, settings: {host_video, participant_video, join_before_host, mute_upon_entry, waiting_room, watermark, auto_recording}
	OccurrenceId *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty"`
}

// CreateBatchPollsJSONBody defines parameters for CreateBatchPolls.
type CreateBatchPollsJSONBody struct {
	// Polls Information about the meeting's polls.
	Polls *[]struct {
		// Anonymous Whether to allow meeting participants to answer poll questions anonymously:
		// * `true` &mdash; Anonymous polls enabled.
		// * `false` &mdash; Participants cannot answer poll questions anonymously.
		//
		// This value defaults to `false`.
		Anonymous *bool `json:"anonymous,omitempty"`

		// PollType The type of poll:
		// * `1` &mdash; Poll.
		// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
		// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
		//
		//  This value defaults to `1`.
		PollType *int `json:"poll_type,omitempty"`

		// Questions Information about the poll's questions.
		Questions *[]struct {
			// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
			// * For `short_answer` polls, a maximum of 500 characters.
			// * For `long_answer` polls, a maximum of 2,000 characters.
			AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

			// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
			AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

			// AnswerRequired Whether participants must answer the question:
			// * `true` &mdash; The participant must answer the question.
			// * `false` &mdash; The participant does not need to answer the question.
			//
			// **Note:**
			// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
			// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
			AnswerRequired *bool `json:"answer_required,omitempty"`

			// Answers The poll question's available answers. This field requires a **minimum** of two answers.
			//
			// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
			// * For `matching` polls, you can only provide a maximum of 16 answers.
			// * For `rank_order` polls, you can only provide a maximum of seven answers.
			Answers *[]string `json:"answers,omitempty"`

			// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
			// * `true` &mdash; The answer is case-sensitive.
			// * `false` &mdash; The answer is not case-sensitive.
			//
			// This value defaults to `false`.
			CaseSensitive *bool `json:"case_sensitive,omitempty"`

			// Name The poll question's title, up to 255 characters.
			//
			// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
			Name *string `json:"name,omitempty"`

			// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
			Prompts *[]struct {
				// PromptQuestion The question prompt's title.
				PromptQuestion *string `json:"prompt_question,omitempty"`

				// PromptRightAnswers The question prompt's correct answers:
				// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
				// * For `rank_order` polls, you can only provide one correct answer.
				PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
			} `json:"prompts,omitempty"`

			// RatingMaxLabel The high score label used for the `rating_max_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxLabel *string `json:"rating_max_label,omitempty"`

			// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxValue *int `json:"rating_max_value,omitempty"`

			// RatingMinLabel The low score label used for the `rating_min_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinLabel *string `json:"rating_min_label,omitempty"`

			// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinValue *int `json:"rating_min_value,omitempty"`

			// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
			//
			//  For `single` and `matching` polls, this field only accepts one answer.
			RightAnswers *[]string `json:"right_answers,omitempty"`

			// ShowAsDropdown Whether to display the radio selection as a drop-down box:
			// * `true` &mdash; Show as a drop-down box.
			// * `false` &mdash; Do not show as a drop-down box.
			//
			// This value defaults to `false`.
			ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

			// Type The poll's question and answer type:
			// * `single` &mdash; Single choice.
			// * `multiple` &mdash; Multiple choice.
			// * `matching` &mdash; Matching.
			// * `rank_order` &mdash; Rank order.
			// * `short_answer` &mdash; Short answer.
			// * `long_answer` &mdash; Long answer.
			// * `fill_in_the_blank` &mdash; Fill in the blank.
			// * `rating_scale` &mdash; Rating scale.
			Type *string `json:"type,omitempty"`
		} `json:"questions,omitempty"`

		// Title The poll's title, up to 64 characters.
		Title *string `json:"title,omitempty"`
	} `json:"polls,omitempty"`
}

// AddBatchRegistrantsJSONBody defines parameters for AddBatchRegistrants.
type AddBatchRegistrantsJSONBody struct {
	// AutoApprove If a meeting was scheduled with approval_type `1` (manual approval), but you would like to automatically approve the registrants that are added via this API, you can set the value of this field to `true`.
	//
	// You **cannot** use this field to change approval setting for a meeting  that was originally scheduled with approval_type `0` (automatic approval).
	AutoApprove *bool `json:"auto_approve,omitempty"`
	Registrants *[]struct {
		// Email Email address of the registrant.
		Email openapi_types.Email `json:"email"`

		// FirstName First name of the registrant.
		FirstName string `json:"first_name"`

		// LastName Last name of the registrant.
		LastName *string `json:"last_name,omitempty"`
	} `json:"registrants,omitempty"`

	// RegistrantsConfirmationEmail Send confirmation Email to Registrants
	RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`
}

// MeetingInviteLinksCreateJSONBody defines parameters for MeetingInviteLinksCreate.
type MeetingInviteLinksCreateJSONBody struct {
	// Attendees The attendees list.
	Attendees *[]struct {
		// Name User display name.
		Name string `json:"name"`
	} `json:"attendees,omitempty"`

	// Ttl The invite link's expiration time, in seconds.
	//
	// This value defaults to `7200`.
	Ttl *int64 `json:"ttl,omitempty"`
}

// MeetingLiveStreamUpdateJSONBody defines parameters for MeetingLiveStreamUpdate.
type MeetingLiveStreamUpdateJSONBody struct {
	// PageUrl The live stream page URL.
	PageUrl string `json:"page_url"`

	// Resolution The number of pixels in each dimension that the video camera can display, required when a user enables 1080p. Use a value of `720p` or `1080p`
	Resolution *string `json:"resolution,omitempty"`

	// StreamKey Stream name and key.
	StreamKey string `json:"stream_key"`

	// StreamUrl Streaming URL.
	StreamUrl string `json:"stream_url"`
}

// MeetingLiveStreamStatusUpdateJSONBody defines parameters for MeetingLiveStreamStatusUpdate.
type MeetingLiveStreamStatusUpdateJSONBody struct {
	// Action Update the status of a live stream.
	//
	// The value can be one of the following:
	//
	// `start`: Start a live stream.
	//
	// `stop`: Stop an ongoing live stream.
	Action *string `json:"action,omitempty"`

	// Settings Update the settings of a live streaming session. The settings can only be updated for a live stream that has been stopped. You can not update the settings of an ongoing live stream.
	Settings *struct {
		// ActiveSpeakerName Display the name of the active speaker during a live stream.
		ActiveSpeakerName *bool `json:"active_speaker_name,omitempty"`

		// DisplayName Display name of the live stream.
		DisplayName *string `json:"display_name,omitempty"`
	} `json:"settings,omitempty"`
}

// MeetingPollsParams defines parameters for MeetingPolls.
type MeetingPollsParams struct {
	// Anonymous Whether to query for polls with the **Anonymous** option enabled:
	// * `true` &mdash; Query for polls with the **Anonymous** option enabled.
	// * `false` &mdash; Do not query for polls with the **Anonymous** option enabled.
	Anonymous *bool `form:"anonymous,omitempty" json:"anonymous,omitempty"`
}

// MeetingPollCreateJSONBody defines parameters for MeetingPollCreate.
type MeetingPollCreateJSONBody struct {
	// Anonymous Allow meeting participants to answer poll questions anonymously.
	//
	// This value defaults to `false`.
	Anonymous *bool `json:"anonymous,omitempty"`

	// PollType The type of poll:
	// * `1` &mdash; Poll.
	// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
	// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
	//
	//  This value defaults to `1`.
	PollType *int `json:"poll_type,omitempty"`

	// Questions Information about the poll's questions.
	Questions *[]struct {
		// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
		// * For `short_answer` polls, a maximum of 500 characters.
		// * For `long_answer` polls, a maximum of 2,000 characters.
		AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

		// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
		AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

		// AnswerRequired Whether participants must answer the question:
		// * `true` &mdash; The participant must answer the question.
		// * `false` &mdash; The participant does not need to answer the question.
		//
		// **Note:**
		// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
		// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
		AnswerRequired *bool `json:"answer_required,omitempty"`

		// Answers The poll question's available answers. This field requires a **minimum** of two answers.
		//
		// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
		// * For `matching` polls, you can only provide a maximum of 16 answers.
		// * For `rank_order` polls, you can only provide a maximum of seven answers.
		Answers *[]string `json:"answers,omitempty"`

		// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
		// * `true` &mdash; The answer is case-sensitive.
		// * `false` &mdash; The answer is not case-sensitive.
		//
		// This value defaults to `false`.
		CaseSensitive *bool `json:"case_sensitive,omitempty"`

		// Name The poll question, up to 255 characters.
		//
		// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
		Name *string `json:"name,omitempty"`

		// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
		Prompts *[]struct {
			// PromptQuestion The question prompt's title.
			PromptQuestion *string `json:"prompt_question,omitempty"`

			// PromptRightAnswers The question prompt's correct answers:
			// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
			// * For `rank_order` polls, you can only provide one correct answer.
			PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
		} `json:"prompts,omitempty"`

		// RatingMaxLabel The high score label used for the `rating_max_value` field.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMaxLabel *string `json:"rating_max_label,omitempty"`

		// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMaxValue *int `json:"rating_max_value,omitempty"`

		// RatingMinLabel The low score label used for the `rating_min_value` field.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMinLabel *string `json:"rating_min_label,omitempty"`

		// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMinValue *int `json:"rating_min_value,omitempty"`

		// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
		//
		//  For `single` and `matching` polls, this field only accepts one answer.
		RightAnswers *[]string `json:"right_answers,omitempty"`

		// ShowAsDropdown Whether to display the radio selection as a drop-down box:
		// * `true` &mdash; Show as a drop-down box.
		// * `false` &mdash; Do not show as a drop-down box.
		//
		// This value defaults to `false`.
		ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

		// Type The poll's question and answer type:
		// * `single` &mdash; Single choice.
		// * `multiple` &mdash; Multiple choice.
		// * `matching` &mdash; Matching.
		// * `rank_order` &mdash; Rank order.
		// * `short_answer` &mdash; Short answer.
		// * `long_answer` &mdash; Long answer.
		// * `fill_in_the_blank` &mdash; Fill in the blank.
		// * `rating_scale` &mdash; Rating scale.
		Type *string `json:"type,omitempty"`
	} `json:"questions,omitempty"`

	// Title The poll's title, up to 64 characters.
	Title *string `json:"title,omitempty"`
}

// MeetingPollUpdateJSONBody defines parameters for MeetingPollUpdate.
type MeetingPollUpdateJSONBody struct {
	// Anonymous Allow meeting participants to answer poll questions anonymously.
	//
	// This value defaults to `false`.
	Anonymous *bool `json:"anonymous,omitempty"`

	// PollType The type of poll:
	// * `1` &mdash; Poll.
	// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
	// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
	//
	//  This value defaults to `1`.
	PollType *int `json:"poll_type,omitempty"`

	// Questions Information about the poll's questions.
	Questions *[]struct {
		// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
		// * For `short_answer` polls, a maximum of 500 characters.
		// * For `long_answer` polls, a maximum of 2,000 characters.
		AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

		// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
		AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

		// AnswerRequired Whether participants must answer the question:
		// * `true` &mdash; The participant must answer the question.
		// * `false` &mdash; The participant does not need to answer the question.
		//
		// **Note:**
		// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
		// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
		AnswerRequired *bool `json:"answer_required,omitempty"`

		// Answers The poll question's available answers. This field requires a **minimum** of two answers.
		//
		// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
		// * For `matching` polls, you can only provide a maximum of 16 answers.
		// * For `rank_order` polls, you can only provide a maximum of seven answers.
		Answers *[]string `json:"answers,omitempty"`

		// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
		// * `true` &mdash; The answer is case-sensitive.
		// * `false` &mdash; The answer is not case-sensitive.
		//
		// This value defaults to `false`.
		CaseSensitive *bool `json:"case_sensitive,omitempty"`

		// Name The poll question, up to 255 characters.
		//
		// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
		Name *string `json:"name,omitempty"`

		// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
		Prompts *[]struct {
			// PromptQuestion The question prompt's title.
			PromptQuestion *string `json:"prompt_question,omitempty"`

			// PromptRightAnswers The question prompt's correct answers:
			// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
			// * For `rank_order` polls, you can only provide one correct answer.
			PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
		} `json:"prompts,omitempty"`

		// RatingMaxLabel The high score label used for the `rating_max_value` field.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMaxLabel *string `json:"rating_max_label,omitempty"`

		// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMaxValue *int `json:"rating_max_value,omitempty"`

		// RatingMinLabel The low score label used for the `rating_min_value` field.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMinLabel *string `json:"rating_min_label,omitempty"`

		// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
		//
		// This field only applies to the `rating_scale` poll.
		RatingMinValue *int `json:"rating_min_value,omitempty"`

		// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
		//
		//  For `single` and `matching` polls, this field only accepts one answer.
		RightAnswers *[]string `json:"right_answers,omitempty"`

		// ShowAsDropdown Whether to display the radio selection as a drop-down box:
		// * `true` &mdash; Show as a drop-down box.
		// * `false` &mdash; Do not show as a drop-down box.
		//
		// This value defaults to `false`.
		ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

		// Type The poll's question and answer type:
		// * `single` &mdash; Single choice.
		// * `multiple` &mdash; Multiple choice.
		// * `matching` &mdash; Matching.
		// * `rank_order` &mdash; Rank order.
		// * `short_answer` &mdash; Short answer.
		// * `long_answer` &mdash; Long answer.
		// * `fill_in_the_blank` &mdash; Fill in the blank.
		// * `rating_scale` &mdash; Rating scale.
		Type *string `json:"type,omitempty"`
	} `json:"questions,omitempty"`

	// Title The poll's title, up to 64 characters.
	Title *string `json:"title,omitempty"`
}

// MeetingRegistrantsParams defines parameters for MeetingRegistrants.
type MeetingRegistrantsParams struct {
	// OccurrenceId The meeting or webinar occurrence ID.
	OccurrenceId *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty"`

	// Status Query by the registrant's status:
	// * `pending` &mdash; The registration is pending.
	// * `approved` &mdash; The registrant is approved.
	// * `denied` &mdash; The registration is denied.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// PageSize The number of records returned within a single API call.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// PageNumber **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
	PageNumber *int `form:"page_number,omitempty" json:"page_number,omitempty"`

	// NextPageToken Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
	NextPageToken *string `form:"next_page_token,omitempty" json:"next_page_token,omitempty"`
}

// MeetingRegistrantCreateJSONBody defines parameters for MeetingRegistrantCreate.
type MeetingRegistrantCreateJSONBody struct {
	// Address The registrant's address.
	Address *string `json:"address,omitempty"`

	// AutoApprove If a meeting was scheduled with the `approval_type` field value of `1` (manual approval) but you want to automatically approve meeting registrants, set the value of this field to `true`.
	//
	// **Note:** You cannot use this field to change approval setting for a meeting originally scheduled with the `approval_type` field value of `0` (automatic approval).
	AutoApprove *bool `json:"auto_approve,omitempty"`

	// City The registrant's city.
	City *string `json:"city,omitempty"`

	// Comments The registrant's questions and comments.
	Comments *string `json:"comments,omitempty"`

	// Country The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
	Country *string `json:"country,omitempty"`

	// CustomQuestions Information about custom questions.
	CustomQuestions *[]struct {
		// Title The title of the custom question.
		Title *string `json:"title,omitempty"`

		// Value The custom question's response value. This has a limit of 128 characters.
		Value *string `json:"value,omitempty"`
	} `json:"custom_questions,omitempty"`

	// Email The registrant's email address.
	Email openapi_types.Email `json:"email"`

	// FirstName The registrant's first name.
	FirstName string `json:"first_name"`

	// Industry The registrant's industry.
	Industry *string `json:"industry,omitempty"`

	// JobTitle The registrant's job title.
	JobTitle *string `json:"job_title,omitempty"`

	// Language The registrant's language preference for confirmation emails:
	// * `en-US` &mdash; English (US)
	// * `de-DE` &mdash; German (Germany)
	// * `es-ES` &mdash; Spanish (Spain)
	// * `fr-FR` &mdash; French (France)
	// * `jp-JP` &mdash; Japanese
	// * `pt-PT` &mdash; Portuguese (Portugal)
	// * `ru-RU` &mdash; Russian
	// * `zh-CN` &mdash; Chinese (PRC)
	// * `zh-TW` &mdash; Chinese (Taiwan)
	// * `ko-KO` &mdash; Korean
	// * `it-IT` &mdash; Italian (Italy)
	// * `vi-VN` &mdash; Vietnamese
	// * `pl-PL` &mdash; Polish
	// * `Tr-TR` &mdash; Turkish
	Language *string `json:"language,omitempty"`

	// LastName The registrant's last name.
	LastName *string `json:"last_name,omitempty"`

	// NoOfEmployees The registrant's number of employees:
	// * `1-20`
	// * `21-50`
	// * `51-100`
	// * `101-500`
	// * `500-1,000`
	// * `1,001-5,000`
	// * `5,001-10,000`
	// * `More than 10,000`
	NoOfEmployees *string `json:"no_of_employees,omitempty"`

	// Org The registrant's organization.
	Org *string `json:"org,omitempty"`

	// Phone The registrant's phone number.
	Phone *string `json:"phone,omitempty"`

	// PurchasingTimeFrame The registrant's purchasing time frame:
	// * `Within a month`
	// * `1-3 months`
	// * `4-6 months`
	// * `More than 6 months`
	// * `No timeframe`
	PurchasingTimeFrame *string `json:"purchasing_time_frame,omitempty"`

	// RoleInPurchaseProcess The registrant's role in the purchase process:
	// * `Decision Maker`
	// * `Evaluator/Recommender`
	// * `Influencer`
	// * `Not involved`
	RoleInPurchaseProcess *string `json:"role_in_purchase_process,omitempty"`

	// State The registrant's state or province.
	State *string `json:"state,omitempty"`

	// Zip The registrant's ZIP or postal code.
	Zip *string `json:"zip,omitempty"`
}

// MeetingRegistrantCreateParams defines parameters for MeetingRegistrantCreate.
type MeetingRegistrantCreateParams struct {
	// OccurrenceIds A comma-separated list of meeting occurrence IDs. You can get this value with the [Get a meeting](/docs/api-reference/zoom-api/methods#operation/meeting) API.
	OccurrenceIds *string `form:"occurrence_ids,omitempty" json:"occurrence_ids,omitempty"`
}

// MeetingRegistrantQuestionUpdateJSONBody defines parameters for MeetingRegistrantQuestionUpdate.
type MeetingRegistrantQuestionUpdateJSONBody struct {
	// CustomQuestions Array of Registrant Custom Questions
	CustomQuestions *[]struct {
		// Answers Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
		Answers *[]string `json:"answers,omitempty"`

		// Required Indicates whether or not the custom question is required to be answered by participants or not.
		Required *bool `json:"required,omitempty"`

		// Title Title of the custom question.
		Title *string `json:"title,omitempty"`

		// Type Type of the question being asked.
		Type *string `json:"type,omitempty"`
	} `json:"custom_questions,omitempty"`

	// Questions Array of Registrant Questions
	Questions *[]struct {
		// FieldName Field name of the question.
		FieldName *string `json:"field_name,omitempty"`

		// Required Indicates whether or not the displayed fields are required to be filled out by registrants.
		Required *bool `json:"required,omitempty"`
	} `json:"questions,omitempty"`
}

// MeetingRegistrantStatusJSONBody defines parameters for MeetingRegistrantStatus.
type MeetingRegistrantStatusJSONBody struct {
	// Action Registrant Status:
	//  `approve` - Approve registrant.
	//  `cancel` - Cancel previously approved registrant's registration.
	//  `deny` - Deny registrant.
	Action string `json:"action"`

	// Registrants List of registrants.
	Registrants *[]struct {
		Email *string `json:"email,omitempty"`
		Id    *string `json:"id,omitempty"`
	} `json:"registrants,omitempty"`
}

// MeetingRegistrantStatusParams defines parameters for MeetingRegistrantStatus.
type MeetingRegistrantStatusParams struct {
	// OccurrenceId The meeting or webinar occurrence ID.
	OccurrenceId *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty"`
}

// MeetingregistrantdeleteParams defines parameters for Meetingregistrantdelete.
type MeetingregistrantdeleteParams struct {
	// OccurrenceId The meeting occurrence ID.
	OccurrenceId *string `form:"occurrence_id,omitempty" json:"occurrence_id,omitempty"`
}

// GetSipDialingWithPasscodeJSONBody defines parameters for GetSipDialingWithPasscode.
type GetSipDialingWithPasscodeJSONBody struct {
	// Passcode If customers desire that a passcode be embedded in the SIP URI dial string, they must supply the passcode. Zoom will not validate the passcode.
	Passcode *string `json:"passcode,omitempty"`
}

// MeetingStatusJSONBody defines parameters for MeetingStatus.
type MeetingStatusJSONBody struct {
	// Action `end` - End a meeting.
	//
	// `recover` - [Recover](https://support.zoom.us/hc/en-us/articles/360038297111-Recover-a-deleted-meeting) a deleted meeting.
	Action *string `json:"action,omitempty"`
}

// MeetingSurveyUpdateJSONBody defines parameters for MeetingSurveyUpdate.
type MeetingSurveyUpdateJSONBody struct {
	// CustomSurvey Information about the customized meeting survey.
	CustomSurvey *struct {
		// Anonymous Allow participants to anonymously answer survey questions.
		//
		//  This value defaults to `true`.
		Anonymous *bool `json:"anonymous,omitempty"`

		// Questions Information about the meeting survey's questions.
		Questions *[]struct {
			// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
			AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

			// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
			AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

			// AnswerRequired Whether participants must answer the question:
			// * `true` &mdash; The participant must answer the question.
			// * `false` &mdash; The participant does not need to answer the question.
			//
			//  This value defaults to `false`.
			AnswerRequired *bool `json:"answer_required,omitempty"`

			// Answers The survey question's available answers. This field requires a **minimum** of two answers.
			//
			// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
			// * For `matching` polls, you can only provide a maximum of 16 answers.
			// * For `rank_order` polls, you can only provide a maximum of seven answers.
			Answers *[]string `json:"answers,omitempty"`

			// Name The survey question, up to 255 characters.
			Name *string `json:"name,omitempty"`

			// RatingMaxLabel The high score label used for the `rating_max_value` field.
			//
			//  This field only applies to the `rating_scale` survey.
			RatingMaxLabel *string `json:"rating_max_label,omitempty"`

			// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
			//
			//  This field only applies to the `rating_scale` survey.
			RatingMaxValue *int `json:"rating_max_value,omitempty"`

			// RatingMinLabel The low score label used for the `rating_min_value` field.
			//
			// T his field only applies to the `rating_scale` survey.
			RatingMinLabel *string `json:"rating_min_label,omitempty"`

			// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
			//
			//  This field only applies to the `rating_scale` survey.
			RatingMinValue *int `json:"rating_min_value,omitempty"`

			// ShowAsDropdown Display the radio selection as a drop-down box:
			// * `true` &mdash; Show as a drop-down box.
			// * `false` &mdash; Do not show as a drop-down box.
			//
			//  This value defaults to `false`.
			ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

			// Type The survey's question and answer type:
			// * `single` &mdash; Single choice.
			// * `multiple` &mdash; Multiple choice.
			// * `rating_scale` &mdash; Rating scale.
			// * `long_answer` &mdash; Long answer.
			Type *string `json:"type,omitempty"`
		} `json:"questions,omitempty"`
	} `json:"custom_survey,omitempty"`

	// ShowInTheBrowser Whether the **Show in the browser when the meeting ends** option is enabled:
	// * `true` &mdash; Enabled.
	// * `false` &mdash; Disabled.
	//
	//  This value defaults to `true`.
	ShowInTheBrowser *bool `json:"show_in_the_browser,omitempty"`

	// ThirdPartySurvey The link to the third party meeting survey.
	ThirdPartySurvey *string `json:"third_party_survey,omitempty"`
}

// MeetingTokenParams defines parameters for MeetingToken.
type MeetingTokenParams struct {
	// Type The meeting token type:
	// * `closed_caption_token` &mdash; The third-party closed caption API token.
	//
	// This defaults to `closed_caption_token`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`
}

// PastMeetingDetailsParamsMeetingId0 defines parameters for PastMeetingDetails.
type PastMeetingDetailsParamsMeetingId0 = int

// PastMeetingDetailsParamsMeetingId1 defines parameters for PastMeetingDetails.
type PastMeetingDetailsParamsMeetingId1 = string

// PastMeetingParticipantsParams defines parameters for PastMeetingParticipants.
type PastMeetingParticipantsParams struct {
	// PageSize The number of records returned within a single API call.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// NextPageToken Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
	NextPageToken *string `form:"next_page_token,omitempty" json:"next_page_token,omitempty"`
}

// PastMeetingParticipantsParamsMeetingId0 defines parameters for PastMeetingParticipants.
type PastMeetingParticipantsParamsMeetingId0 = int

// PastMeetingParticipantsParamsMeetingId1 defines parameters for PastMeetingParticipants.
type PastMeetingParticipantsParamsMeetingId1 = string

// ListPastMeetingPollsParamsMeetingId0 defines parameters for ListPastMeetingPolls.
type ListPastMeetingPollsParamsMeetingId0 = int

// ListPastMeetingPollsParamsMeetingId1 defines parameters for ListPastMeetingPolls.
type ListPastMeetingPollsParamsMeetingId1 = string

// ListPastMeetingQAParamsMeetingId0 defines parameters for ListPastMeetingQA.
type ListPastMeetingQAParamsMeetingId0 = int

// ListPastMeetingQAParamsMeetingId1 defines parameters for ListPastMeetingQA.
type ListPastMeetingQAParamsMeetingId1 = string

// UsersParams defines parameters for Users.
type UsersParams struct {
	// Status The user's status:
	// * `active` &mdash; The user exists on the account.
	// * `inactive` &mdash; The user has been deactivated.
	// * `pending` &mdash; The user exists on the account but has not activated their account. See [Managing users](https://support.zoom.us/hc/en-us/articles/201363183) for details.
	//
	// This value defaults to `active`.
	Status *string `form:"status,omitempty" json:"status,omitempty"`

	// PageSize The number of records returned within a single API call.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// RoleId The role's unique ID. Use this parameter to filter the response by a specific role. You can use the [**List roles**](/docs/api-reference/zoom-api/methods#operation/roles) API to get a role's unique ID value.
	RoleId *string `form:"role_id,omitempty" json:"role_id,omitempty"`

	// PageNumber The page number of the current page in the returned records.
	PageNumber *string `form:"page_number,omitempty" json:"page_number,omitempty"`

	// IncludeFields Use this parameter to display specific attributes in the API call's response:
	// * `custom_attributes` &mdash; Return the user's custom attributes.
	IncludeFields *string `form:"include_fields,omitempty" json:"include_fields,omitempty"`

	// NextPageToken Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
	NextPageToken *string `form:"next_page_token,omitempty" json:"next_page_token,omitempty"`
}

// UserCreateJSONBody defines parameters for UserCreate.
type UserCreateJSONBody struct {
	// Action The action to take to create the new user:
	// * `create` &mdash; The user receives an email from Zoom containing a confirmation link. The user must then use the link to activate their Zoom account. The user can then set or change their password.
	// * `autoCreate` &mdash; This action is for Enterprise customers with a managed domain. This feature is disabled by default because of the security risk involved in creating a user who does not belong to your domain.
	// * `custCreate` &mdash; Users created with this action do not have passwords and will **not** have the ability to log into the Zoom web portal or the Zoom client. These users can still host and join meetings using the `start_url` and `join_url` respectively. To use this option, you must [contact the Integrated Software Vendor (ISV) sales team](https://explore.zoom.us/en/isv/#isv).
	// * `ssoCreate` &mdash; This action is provided for the enabled &ldquo;Pre-provisioning SSO User&rdquo; option. A user created this way has no password. If it is **not** a Basic user, a personal vanity URL with the username (no domain) of the provisioning email is generated. If the username or PMI is invalid or occupied, it uses a random number or random personal vanity URL.
	Action   string `json:"action"`
	UserInfo *struct {
		// DisplayName The user's display name. Cannot contain more than 10 Chinese characters.
		DisplayName *string `json:"display_name,omitempty"`

		// Email User email address.
		Email string `json:"email"`

		// Feature Information about the user's features.
		Feature *struct {
			// ZoomOneType The Zoom One plan option.
			//  `16` - Zoom One Business Plus with US/CA Unlimited.
			//  `32` - Zoom One Business Plus with UK/IR Unlimited.
			//  `64` - Zoom One Business Plus with AU/NZ Unlimited.
			//  `128` - Zoom One Business Plus with Japan Unlimited.
			//  `33554432` - Zoom One Business Plus with Global Select.
			//
			//  The Zoom One plan option for Gov accounts:
			//  `16` - Zoom One Business Plus.
			ZoomOneType *int `json:"zoom_one_type,omitempty"`

			// ZoomPhone Whether the user has the **Zoom Phone** feature enabled.
			ZoomPhone *bool `json:"zoom_phone,omitempty"`
		} `json:"feature,omitempty"`

		// FirstName The user's first name. Cannot contain more than 5 Chinese characters.
		FirstName *string `json:"first_name,omitempty"`

		// LastName The user's last name. Cannot contain more than 5 Chinese characters.
		LastName *string `json:"last_name,omitempty"`

		// Password User password. Only used for the &quot;autoCreate&quot; function. The password has to have a minimum of 8 characters and maximum of 32 characters. By default (basic requirement), password must have at least one letter (a, b, c..), at least one number (1, 2, 3...) and include both uppercase and lowercase letters. It should not contain only one identical character repeatedly ('11111111' or 'aaaaaaaa') and it cannot contain consecutive characters ('12345678' or 'abcdefgh').
		//
		// **Note:** If the account owner or admin has enabled [enhanced password requirements](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_fa9186e4-6818-4f7a-915c-2e25c19f0acd), the value provided in this field must meet those requirements. These requirements can be retrieved by calling the [**Get account settings**](/docs/api-reference/zoom-api/ma#operation/accountSettings) API and referring to the `password_requirement` field present in the `security` object.
		Password *string `json:"password,omitempty"`

		// PlanUnitedType The Zoom United type. The license option:
		// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
		// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
		// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
		// * `8` &mdash; Zoom United Pro-United with Global Select.
		// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
		// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
		// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
		// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
		// * `256` &mdash; Zoom United Biz-United with Global Select.
		// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
		// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
		// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
		// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
		// * `8192` &mdash; Zoom United Ent-United with Global Select.
		// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
		// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
		// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
		// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
		PlanUnitedType *string `json:"plan_united_type,omitempty"`

		// Type User type.
		//  `1` - Basic.
		//  `2` - Licensed.
		//  `99` - None (this can only be set with `ssoCreate`).
		Type int `json:"type"`
	} `json:"user_info,omitempty"`
}

// UserEmailParams defines parameters for UserEmail.
type UserEmailParams struct {
	// Email The email address to be verified.
	Email string `form:"email" json:"email"`
}

// BulkUpdateFeatureJSONBody defines parameters for BulkUpdateFeature.
type BulkUpdateFeatureJSONBody struct {
	// FeatureType The feature type you want to update.
	FeatureType string `json:"feature_type"`

	// FeatureValue The feature value you want to update. The value you can pass depends on the 'feature_type' field.
	//
	// **user_type:**
	// * `1` - Basic
	// * `2` - Licensed
	// * `99` - None (this can only be set with `ssoCreate`).
	//
	// **concurrent_meeting:**
	// * `Basic`
	// * `Plus`
	// * `None`.
	//
	// **large_meeting:**
	// * `1` - 100 capacity
	// * `32` - 200 capacity
	// * `64` - 300 capacity
	// * `128` - 500 capacity
	// * `256` - 1000 capacity
	// * `0` - Turn off the **Large meeting** feature.
	//
	// **webinar:**
	// * `16` - 100 capacity
	// * `1` - 500 capacity
	// * `64` - 1000 capacity
	// * `128` - 3000 capacity
	// * `256` - 5000 capacity
	// * `512` - 10000 capacity
	// * `1024` - 20000 capacity
	// * `2048` - 30000 capacity
	// * `4096` - 40000 capacity
	// * `8192` - 50000 capacity
	// * `16384` - promo 500 capacity
	// * `32768` - promo 1000 capacity
	// * `0` - Turn off the **Webinar** feature.
	//
	// **zoom_events:**
	// * `500` - 500 capacity
	// * `1000` - 1000 capacity
	// * `3000` - 3000 capacity
	// * `5000` - 5000 capacity
	// * `10000` - 10000 capacity
	// * `20000` - 20000 capacity
	// * `30000` - 30000 capacity
	// * `50000` - 50000 capacity
	// * `0` - Turn off the **Zoom events** feature.
	//
	// **zoom_iq_for_sales:**
	// * `true` - Turn on the **Zoom IQ** feature.
	// * `false` - Turn off the **Zoom IQ** feature.
	//
	// **zoom_whiteboard:**
	// * `true` - Turn on the **Zoom whiteboard** feature.
	// * `false` - Turn off the **Zoom whiteboard** feature.
	//
	// **plan_united_type:**
	// * `1` - Zoom United Pro-United with US/CA Unlimited.
	// * `2` - Zoom United Pro-United with UK/IR Unlimited.
	// * `4` - Zoom United Pro-United with AU/NZ Unlimited.
	// * `8` - Zoom United Pro-United with Global Select.
	// * `16` -  Zoom United Pro-United with Zoom Phone Pro.
	// * `32` - Zoom United Biz-United with US/CA Unlimited.
	// * `64` - Zoom United Biz-United with UK/IR Unlimited.
	// * `128` - Zoom United Biz-United with AU/NZ Unlimited.
	// * `256` - Zoom United Biz-United with Global Select.
	// * `512` -  Zoom United Biz-United with Zoom Phone Pro.
	// * `1024` - Zoom United Ent-United with US/CA Unlimited.
	// * `2048` - Zoom United Ent-United with UK/IR Unlimited.
	// * `4096` - Zoom United Ent-United with AU/NZ Unlimited.
	// * `8192` - Zoom United Ent-United with Global Select.
	// * `16384` -  Zoom United Ent-United with Zoom Phone Pro.
	// * `32768` - Zoom United Pro-United with JP Unlimited.
	// * `65536` - Zoom United Biz-United with JP Unlimited.
	// * `131072` - Zoom United Ent-United with JP Unlimited.
	// * `0` - Turn off the **Zoom united** feature.
	//
	// **zoom_one_type:**
	// * `16` - Zoom One Business Plus with US/CA Unlimited.
	// * `32` - Zoom One Business Plus with UK/IR Unlimited.
	// * `64` - Zoom One Business Plus with AU/NZ Unlimited.
	// * `128` - Zoom One Business Plus with Japan Unlimited.
	// * `33554432` - Zoom One Business Plus with Global Select.
	// * `0` - Turn off the **Zoom one** feature.
	//
	// For Gov accounts:
	// * `16` - Zoom One Business Plus.
	// * `0` - Turn off the **Zoom one** feature.
	FeatureValue string `json:"feature_value"`

	// Users The users' info you want to update.
	Users []struct {
		// Email The user's email.
		Email *string `json:"email,omitempty"`

		// Id The user's ID.
		Id *string `json:"id,omitempty"`
	} `json:"users"`
}

// UserVanityNameParams defines parameters for UserVanityName.
type UserVanityNameParams struct {
	// VanityName Personal meeting room name.
	VanityName string `form:"vanity_name" json:"vanity_name"`
}

// UserDeleteParams defines parameters for UserDelete.
type UserDeleteParams struct {
	// Action Delete action options:
	//  `disassociate` - Disassociate a user.
	//  `delete`-  Permanently delete a user.
	//  Note: To delete pending user in the account, use `disassociate`
	Action *string `form:"action,omitempty" json:"action,omitempty"`

	// EncryptedEmail Whether the email address passed for the `userId` value is an encrypted email address:
	//
	//  * `true` &mdash; The email address is encrypted.
	//  * `false` &mdash; The email address is not encrypted.
	//
	//  If you do not query this parameter, this value defaults to null (`false`).
	EncryptedEmail *bool `form:"encrypted_email,omitempty" json:"encrypted_email,omitempty"`

	// TransferEmail Transfer email. This field is **required** if the user has upcoming Zoom Events scheduled. After you delete or disassociate the user, the user's upcoming Zoom Events will be transferred to the target user.
	TransferEmail *string `form:"transfer_email,omitempty" json:"transfer_email,omitempty"`

	// TransferMeeting Transfer meeting.
	TransferMeeting *bool `form:"transfer_meeting,omitempty" json:"transfer_meeting,omitempty"`

	// TransferWebinar Transfer webinar.
	TransferWebinar *bool `form:"transfer_webinar,omitempty" json:"transfer_webinar,omitempty"`

	// TransferRecording Transfer recording.
	TransferRecording *bool `form:"transfer_recording,omitempty" json:"transfer_recording,omitempty"`

	// TransferWhiteboard When you delete the user, whether to transfer all their [Zoom Whiteboard](https://support.zoom.us/hc/en-us/articles/4410916881421) data to another user.
	TransferWhiteboard *bool `form:"transfer_whiteboard,omitempty" json:"transfer_whiteboard,omitempty"`
}

// UserDeleteParamsUserId0 defines parameters for UserDelete.
type UserDeleteParamsUserId0 = string

// UserDeleteParamsUserId1 defines parameters for UserDelete.
type UserDeleteParamsUserId1 = openapi_types.Email

// UserDeleteParamsUserId2 defines parameters for UserDelete.
type UserDeleteParamsUserId2 = string

// UserParams defines parameters for User.
type UserParams struct {
	// LoginType The user's login method:
	// * `0` &mdash; Facebook OAuth
	// * `1` &mdash; Google OAuth
	// * `24` &mdash; Apple OAuth
	// * `27` &mdash; Microsoft OAuth
	// * `97` &mdash; Mobile device
	// * `98` &mdash; RingCentral OAuth
	// * `99` &mdash; API user
	// * `100` &mdash; Zoom Work email
	// * `101` &mdash; Single Sign-On (SSO)
	//
	// The following login methods are only available in China:
	// * `11` &mdash; Phone number
	// * `21` &mdash; WeChat
	// * `23` &mdash; Alipay
	LoginType *int `json:"login_type,omitempty"`

	// EncryptedEmail Whether the email address passed for the `userId` value is an encrypted email address:
	//
	//  * `true` &mdash; The email address is encrypted.
	//  * `false` &mdash; The email address is not encrypted.
	//
	//  If you do not query this parameter, this value defaults to null (`false`).
	EncryptedEmail *bool `json:"encrypted_email,omitempty"`

	// SearchByUniqueId Whether the queried `userId` value is an employee unique ID:
	// * `true` &mdash; The queried ID is an employee's unique ID.
	// * `false` &mdash; The queried ID is not an employee's unique ID.
	//
	// This value defaults to `false` (null).
	SearchByUniqueId *bool `json:"search_by_unique_id,omitempty"`
}

// UserUpdateJSONBody defines parameters for UserUpdate.
type UserUpdateJSONBody struct {
	// AboutMe The self-introduction of the user. Hyperlinks or HTML code not allowed in this field.
	AboutMe *string `json:"about_me,omitempty"`

	// CmsUserId The Kaltura user ID.
	CmsUserId *string `json:"cms_user_id,omitempty"`

	// Company The user's company.
	Company *string `json:"company,omitempty"`

	// CustomAttributes The user's assigned custom attributes.
	CustomAttributes *[]struct {
		// Key The custom attribute's key.
		Key *string `json:"key,omitempty"`

		// Name The custom attribute's name.
		Name *string `json:"name,omitempty"`

		// Value The custom attribute's value
		Value *string `json:"value,omitempty"`
	} `json:"custom_attributes,omitempty"`

	// Dept The user's assigned department.
	Dept *string `json:"dept,omitempty"`

	// DisplayName The user's display name. This value cannot contain more than ten Chinese characters.
	DisplayName *string `json:"display_name,omitempty"`

	// FirstName The user's first name. This value cannot contain more than five Chinese characters.
	FirstName *string `json:"first_name,omitempty"`

	// GroupId Provide unique identifier of the group that you would like to add a [pending user](https://support.zoom.us/hc/en-us/articles/201363183-Managing-users#h_13c87a2a-ecd6-40ad-be61-a9935e660edb) to. The value of this field can be retrieved from the [**List groups**](/docs/api-reference/zoom-api/methods#operation/groups) API.
	GroupId *string `json:"group_id,omitempty"`

	// HostKey The user's host key.
	HostKey *string `json:"host_key,omitempty"`

	// JobTitle The user's job title.
	JobTitle *string `json:"job_title,omitempty"`

	// Language The user's language.
	Language *string `json:"language,omitempty"`

	// LastName The user's last name. This value cannot contain more than five Chinese characters.
	LastName *string `json:"last_name,omitempty"`

	// LinkedinUrl The LinkedIn link of the user. The URL must contain `linkedin.com`.
	LinkedinUrl *string `json:"linkedin_url,omitempty"`

	// Location The user's location.
	Location *string `json:"location,omitempty"`

	// Manager The user's assigned manager.
	Manager *openapi_types.Email `json:"manager,omitempty"`

	// PhoneCountry **Note:** This field has been **deprecated** and will not be supported in the future. Use the `country` field of the `phone_numbers` object to select the phone number country.
	//
	// The user's phone number [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
	// Deprecated:
	PhoneCountry *string `json:"phone_country,omitempty"`

	// PhoneNumber **Note:** This field has been **deprecated** and will not be supported in the future. Instead, use the `phone_numbers` field to assign phone numbers to a user.
	//
	// The user's phone number. To update a phone number, you must also provide the `phone_country` field.
	// Deprecated:
	PhoneNumber *string `json:"phone_number,omitempty"`

	// PhoneNumbers Information about the user's assigned phone numbers.
	PhoneNumbers *[]struct {
		// Code The phone number's country code
		Code *string `json:"code,omitempty"`

		// Country The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) of the phone number.
		Country *string `json:"country,omitempty"`

		// Label The phone number's label:
		// * `Mobile`
		// * `Office`
		// * `Home`
		// * `Fax`
		Label *string `json:"label,omitempty"`

		// Number The phone number.
		Number *string `json:"number,omitempty"`
	} `json:"phone_numbers,omitempty"`

	// PlanUnitedType The Zoom United type. The license option:
	// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
	// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
	// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
	// * `8` &mdash; Zoom United Pro-United with Global Select.
	// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
	// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
	// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
	// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
	// * `256` &mdash; Zoom United Biz-United with Global Select.
	// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
	// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
	// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
	// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
	// * `8192` &mdash; Zoom United Ent-United with Global Select.
	// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
	// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
	// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
	// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
	// * `none` &mdash; Turn off Zoom United type.
	PlanUnitedType *string `json:"plan_united_type,omitempty"`

	// Pmi The user's [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi).
	Pmi *int `json:"pmi,omitempty"`

	// Pronouns The user's pronouns.
	Pronouns *string `json:"pronouns,omitempty"`

	// PronounsOption The user's display pronouns setting:
	// * `1` &mdash; Ask the user every time they join meetings and webinars.
	// * `2` &mdash; Always display pronouns in meetings and webinars.
	// * `3` &mdash; Do not display pronouns in meetings and webinars.
	PronounsOption *int `json:"pronouns_option,omitempty"`

	// Timezone The user's [timezone](/docs/api-reference/other-references/abbreviation-lists#timezones)
	Timezone *string `json:"timezone,omitempty"`

	// Type The type of [user](https://support.zoom.us/hc/en-us/articles/201363173-Zoom-user-types-roles):
	// * `1` &mdash; Basic.
	// * `2` &mdash; Licensed.
	// * `4` &mdash; No Meetings License.
	// * `99` &mdash; None. You can only set this value if the user was created using the `ssoCreate` value for `action` parameter in the [**Create users**](/docs/api-reference/zoom-api/methods#operation/userCreate) API.
	Type *int `json:"type,omitempty"`

	// UsePmi Whether to use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi) for instant meetings.
	UsePmi *bool `json:"use_pmi,omitempty"`

	// VanityName The user's Personal Meeting Room name.
	VanityName *string `json:"vanity_name,omitempty"`

	// ZoomOneType The Zoom One plan option:
	//  `0` - Turn off Zoom United license.
	//  `16` - Zoom One Business Plus with US/CA Unlimited.
	//  `32` - Zoom One Business Plus with UK/IR Unlimited.
	//  `64` - Zoom One Business Plus with AU/NZ Unlimited.
	//  `128` - Zoom One Business Plus with Japan Unlimited.
	//  `33554432` - Zoom One Business Plus with Global Select.
	//
	//  The Zoom One plan option for Gov accounts:
	//  `0` - Turn off Zoom United license.
	//  `16` - Zoom One Business Plus.
	ZoomOneType *int `json:"zoom_one_type,omitempty"`
}

// UserUpdateParams defines parameters for UserUpdate.
type UserUpdateParams struct {
	// LoginType The user's login method:
	// * `0` &mdash; Facebook OAuth
	// * `1` &mdash; Google OAuth
	// * `24` &mdash; Apple OAuth
	// * `27` &mdash; Microsoft OAuth
	// * `97` &mdash; Mobile device
	// * `98` &mdash; RingCentral OAuth
	// * `99` &mdash; API user
	// * `100` &mdash; Zoom Work email
	// * `101` &mdash; Single Sign-On (SSO)
	//
	// The following login methods are only available in China:
	// * `11` &mdash; Phone number
	// * `21` &mdash; WeChat
	// * `23` &mdash; Alipay
	LoginType *int `form:"login_type,omitempty" json:"login_type,omitempty"`

	// RemoveTspCredentials Whether to remove the user's TSP credentials:
	// * `true` &mdash; The queried ID is an employee's unique ID.
	// * `false` &mdash; The queried ID is not an employee's unique ID.
	//
	//  This value defaults to `false` (null).
	RemoveTspCredentials *bool `form:"remove_tsp_credentials,omitempty" json:"remove_tsp_credentials,omitempty"`
}

// UserUpdateParamsUserId0 defines parameters for UserUpdate.
type UserUpdateParamsUserId0 = string

// UserUpdateParamsUserId1 defines parameters for UserUpdate.
type UserUpdateParamsUserId1 = openapi_types.Email

// UserUpdateParamsUserId2 defines parameters for UserUpdate.
type UserUpdateParamsUserId2 = string

// SwitchAUsersAccountJSONBody defines parameters for SwitchAUsersAccount.
type SwitchAUsersAccountJSONBody struct {
	// AccountId The Account ID of the account to which you would like move the user to.
	AccountId string `json:"account_id"`
}

// UserAssistantsDeleteParamsUserId0 defines parameters for UserAssistantsDelete.
type UserAssistantsDeleteParamsUserId0 = string

// UserAssistantsDeleteParamsUserId1 defines parameters for UserAssistantsDelete.
type UserAssistantsDeleteParamsUserId1 = openapi_types.Email

// UserAssistantsDeleteParamsUserId2 defines parameters for UserAssistantsDelete.
type UserAssistantsDeleteParamsUserId2 = string

// UserAssistantsParamsUserId0 defines parameters for UserAssistants.
type UserAssistantsParamsUserId0 = string

// UserAssistantsParamsUserId1 defines parameters for UserAssistants.
type UserAssistantsParamsUserId1 = openapi_types.Email

// UserAssistantsParamsUserId2 defines parameters for UserAssistants.
type UserAssistantsParamsUserId2 = string

// UserAssistantCreateJSONBody defines parameters for UserAssistantCreate.
type UserAssistantCreateJSONBody struct {
	// Assistants List of User's assistants.
	Assistants *[]struct {
		// Email Assistant's email address.
		Email *string `json:"email,omitempty"`

		// Id Assistant's user ID.
		Id *string `json:"id,omitempty"`
	} `json:"assistants,omitempty"`
}

// UserAssistantCreateParamsUserId0 defines parameters for UserAssistantCreate.
type UserAssistantCreateParamsUserId0 = string

// UserAssistantCreateParamsUserId1 defines parameters for UserAssistantCreate.
type UserAssistantCreateParamsUserId1 = openapi_types.Email

// UserAssistantCreateParamsUserId2 defines parameters for UserAssistantCreate.
type UserAssistantCreateParamsUserId2 = string

// UserAssistantDeleteParamsUserId0 defines parameters for UserAssistantDelete.
type UserAssistantDeleteParamsUserId0 = string

// UserAssistantDeleteParamsUserId1 defines parameters for UserAssistantDelete.
type UserAssistantDeleteParamsUserId1 = openapi_types.Email

// UserAssistantDeleteParamsUserId2 defines parameters for UserAssistantDelete.
type UserAssistantDeleteParamsUserId2 = string

// ListCollaborationDevicesParamsUserId0 defines parameters for ListCollaborationDevices.
type ListCollaborationDevicesParamsUserId0 = string

// ListCollaborationDevicesParamsUserId1 defines parameters for ListCollaborationDevices.
type ListCollaborationDevicesParamsUserId1 = openapi_types.Email

// ListCollaborationDevicesParamsUserId2 defines parameters for ListCollaborationDevices.
type ListCollaborationDevicesParamsUserId2 = string

// GetCollaborationDeviceParamsUserId0 defines parameters for GetCollaborationDevice.
type GetCollaborationDeviceParamsUserId0 = string

// GetCollaborationDeviceParamsUserId1 defines parameters for GetCollaborationDevice.
type GetCollaborationDeviceParamsUserId1 = openapi_types.Email

// GetCollaborationDeviceParamsUserId2 defines parameters for GetCollaborationDevice.
type GetCollaborationDeviceParamsUserId2 = string

// UserEmailUpdateJSONBody defines parameters for UserEmailUpdate.
type UserEmailUpdateJSONBody struct {
	// Email User's email. The length should be less than 128 characters.
	Email openapi_types.Email `json:"email"`
}

// UserEmailUpdateParamsUserId0 defines parameters for UserEmailUpdate.
type UserEmailUpdateParamsUserId0 = string

// UserEmailUpdateParamsUserId1 defines parameters for UserEmailUpdate.
type UserEmailUpdateParamsUserId1 = openapi_types.Email

// UserEmailUpdateParamsUserId2 defines parameters for UserEmailUpdate.
type UserEmailUpdateParamsUserId2 = string

// MeetingTemplateCreateJSONBody defines parameters for MeetingTemplateCreate.
type MeetingTemplateCreateJSONBody struct {
	// MeetingId The meeting ID aka the meeting number in long (int64) format.
	MeetingId *int64 `json:"meeting_id,omitempty"`

	// Name The template name.
	Name *string `json:"name,omitempty"`

	// Overwrite Overwrite an existing meeting template if the template is created from same existing meeting.
	Overwrite *bool `json:"overwrite,omitempty"`

	// SaveRecurrence If the field is set to true, the recurrence meeting template will be saved as the scheduled meeting.
	SaveRecurrence *bool `json:"save_recurrence,omitempty"`
}

// MeetingsParams defines parameters for Meetings.
type MeetingsParams struct {
	// Type The type of meeting:
	// * `scheduled` &mdash; All valid previous (unexpired) meetings, live meetings, and upcoming scheduled meetings.
	// * `live` &mdash; All the ongoing meetings.
	// * `upcoming` &mdash; All upcoming meetings, including live meetings.
	// * `upcoming_meetings` &mdash; All upcoming meetings, including live meetings.
	// * `previous_meetings` &mdash; All the previous meetings.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// PageSize The number of records returned within a single API call.
	PageSize *int `form:"page_size,omitempty" json:"page_size,omitempty"`

	// NextPageToken Use the next page token to paginate through large result sets. A next page token is returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
	NextPageToken *string `form:"next_page_token,omitempty" json:"next_page_token,omitempty"`

	// PageNumber The page number of the current page in the returned records.
	PageNumber *int `form:"page_number,omitempty" json:"page_number,omitempty"`

	// From The start date.
	From *openapi_types.Date `form:"from,omitempty" json:"from,omitempty"`

	// To The end data.
	To *openapi_types.Date `form:"to,omitempty" json:"to,omitempty"`
}

// MeetingsParamsUserId0 defines parameters for Meetings.
type MeetingsParamsUserId0 = string

// MeetingsParamsUserId1 defines parameters for Meetings.
type MeetingsParamsUserId1 = openapi_types.Email

// MeetingsParamsUserId2 defines parameters for Meetings.
type MeetingsParamsUserId2 = string

// MeetingCreateJSONBody defines parameters for MeetingCreate.
type MeetingCreateJSONBody struct {
	// Agenda The meeting's agenda. This value has a maximum length of 2,000 characters.
	Agenda *string `json:"agenda,omitempty"`

	// DefaultPassword Whether to generate a default password using the user's settings. This value defaults to `false`.
	//
	// If this value is `true` and the user has the PMI setting enabled with a password, then the user's meetings will use the PMI password. It will **not** use a default password.
	DefaultPassword *bool `json:"default_password,omitempty"`

	// Duration The meeting's scheduled duration, in minutes. This field is only used for scheduled meetings (`2`).
	Duration *int `json:"duration,omitempty"`

	// Password The password required to join the meeting. By default, a password can **only** have a maximum length of 10 characters and only contain alphanumeric characters and the `@`, `-`, `_`, and `*` characters.
	// * If the account owner or administrator has configured [minimum passcode requirement settings](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604), the password **must** meet those requirements.
	// * If password requirements are enabled, use the [**Get user settings**](/docs/api-reference/zoom-api/methods#operation/userSettings) API or the [**Get account settings**](/docs/api-reference/zoom-api/ma#operation/accountSettings) API to get the requirements.
	Password *string `json:"password,omitempty"`

	// PreSchedule Whether to create a prescheduled meeting via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time).
	// * `true` - Create a prescheduled meeting.
	// * `false` - Create a regular meeting.
	PreSchedule *bool `json:"pre_schedule,omitempty"`

	// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
	Recurrence *struct {
		// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
		EndDateTime *time.Time `json:"end_date_time,omitempty"`

		// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
		EndTimes *int `json:"end_times,omitempty"`

		// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
		//
		// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
		MonthlyDay *int `json:"monthly_day,omitempty"`

		// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
		//  `-1` - Last week of the month.
		//  `1` - First week of the month.
		//  `2` - Second week of the month.
		//  `3` - Third week of the month.
		//  `4` - Fourth week of the month.
		MonthlyWeek *int `json:"monthly_week,omitempty"`

		// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
		//
		//
		//  `1` - Sunday.
		//  `2` - Monday.
		//  `3` - Tuesday.
		//  `4` -  Wednesday.
		//  `5` - Thursday.
		//  `6` - Friday.
		//  `7` - Saturday.
		MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

		// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
		//
		// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
		//
		RepeatInterval *int `json:"repeat_interval,omitempty"`

		// Type Recurrence meeting types:
		//  `1` - Daily.
		//  `2` - Weekly.
		//  `3` - Monthly.
		Type int `json:"type"`

		// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
		//
		//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
		//
		//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
		//
		//
		//  `1`  - Sunday.
		//  `2` - Monday.
		//  `3` - Tuesday.
		//  `4` -  Wednesday.
		//  `5` -  Thursday.
		//  `6` - Friday.
		//  `7` - Saturday.
		WeeklyDays *string `json:"weekly_days,omitempty"`
	} `json:"recurrence,omitempty"`

	// ScheduleFor The email address or user ID of the user to schedule a meeting for.
	ScheduleFor *string `json:"schedule_for,omitempty"`

	// Settings Information about the meeting's settings.
	Settings *struct {
		// AdditionalDataCenterRegions Add additional meeting [data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars). Provide this value as an array of [country codes](/docs/api/rest/other-references/abbreviation-lists/#countries) for the countries available as data center regions in the [**Account Profile**](https://zoom.us/account/setting) interface but have been opted out of in the [user settings](https://zoom.us/profile).
		//
		// For example, the data center regions selected in your [**Account Profile**](https://zoom.us/account) are &quot;Europe&quot;, &quot;Hong Kong SAR&quot;, &quot;Australia&quot;, &quot;India&quot;, &quot;Japan&quot;, &quot;China&quot;, &quot;United States&quot;, and &quot;Canada&quot;. However, in the [**My Profile**](https://zoom.us/profile) settings, you did **not** select &quot;India&quot; and &quot;Japan&quot; for meeting and webinar traffic routing.
		//
		// To include &quot;India&quot; and &quot;Japan&quot; as additional data centers, use the `[&quot;IN&quot;, &quot;TY&quot;]` value for this field.
		AdditionalDataCenterRegions *[]string `json:"additional_data_center_regions,omitempty"`

		// AllowMultipleDevices Whether to allow attendees to join a meeting from multiple devices. This setting is only applied to meetings with registration enabled.
		AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

		// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
		AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

		// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
		AlternativeHosts *string `json:"alternative_hosts,omitempty"`

		// AlternativeHostsEmailNotification Whether to send email notifications to alternative hosts. This value defaults to `true`.
		AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

		// ApprovalType Enable meeting registration approval:
		// * `0` - Automatically approve registration.
		// * `1` - Manually approve registration.
		// * `2` - No registration required.
		//
		// This value defaults to `2`.
		ApprovalType *int `json:"approval_type,omitempty"`

		// ApprovedOrDeniedCountriesOrRegions The list of approved or blocked users from specific countries or regions who can join the meeting.
		ApprovedOrDeniedCountriesOrRegions *struct {
			// ApprovedList The list of approved countries or regions.
			ApprovedList *[]string `json:"approved_list,omitempty"`

			// DeniedList The list of blocked countries or regions.
			DeniedList *[]string `json:"denied_list,omitempty"`

			// Enable Whether to enable the [**Approve or block entry for users from specific countries/regions**](https://support.zoom.us/hc/en-us/articles/360060086231-Approve-or-block-entry-for-users-from-specific-countries-regions) setting.
			Enable *bool `json:"enable,omitempty"`

			// Method Whether to allow or block users from specific countries or regions.
			// * `approve` - Allow users from specific countries or regions to join the meeting. If you select this setting, include the approved countries or regions in the `approved_list` field.
			// * `deny` - Block users from specific countries or regions from joining the meeting. If you select this setting, include the blocked countries or regions in the `denied_list` field.
			Method *string `json:"method,omitempty"`
		} `json:"approved_or_denied_countries_or_regions,omitempty"`

		// Audio How participants join the audio portion of the meeting.
		// * `both` - Both telephony and VoIP.
		// * `telephony` - Telephony only.
		// * `voip` - VoIP only.
		// * `thirdParty` - Third party audio conference.
		Audio *string `json:"audio,omitempty"`

		// AudioConferenceInfo Third party audio conference info.
		AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

		// AuthenticationDomains The meeting's authenticated domains. Only Zoom users whose email address contains an authenticated domain can join the meeting. Comma-separate multiple domains or use a wildcard for listing domains.
		AuthenticationDomains *string `json:"authentication_domains,omitempty"`

		// AuthenticationException A list of participants that can bypass meeting authentication. These participants will receive a unique meeting invite.
		AuthenticationException *[]struct {
			// Email The participant's email address.
			Email *openapi_types.Email `json:"email,omitempty"`

			// Name The participant's name.
			Name *string `json:"name,omitempty"`
		} `json:"authentication_exception,omitempty"`

		// AuthenticationOption If the `meeting_authentication` value is `true`, the type of authentication required for users to join a meeting.
		//
		// To get this value, use the `authentication_options` array's `id` value in the [**Get user settings**](/docs/api-reference/zoom-api/methods#operation/userSettings) API response.
		AuthenticationOption *string `json:"authentication_option,omitempty"`

		// AutoRecording The automatic recording settings.
		// * `local` - Record the meeting locally.
		// * `cloud` - Record the meeting to the cloud.
		// * `none` - Auto-recording disabled.
		//
		// This value defaults to `none`.
		AutoRecording *string `json:"auto_recording,omitempty"`

		// BreakoutRoom The [pre-assigned breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) settings.
		BreakoutRoom *struct {
			// Enable Whether to enable the [**Breakout Room pre-assign**](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms) option.
			Enable *bool `json:"enable,omitempty"`

			// Rooms Information about the breakout rooms.
			Rooms *[]struct {
				// Name The breakout room's name.
				Name *string `json:"name,omitempty"`

				// Participants The email addresses of the participants to assign to the breakout room.
				Participants *[]string `json:"participants,omitempty"`
			} `json:"rooms,omitempty"`
		} `json:"breakout_room,omitempty"`

		// CalendarType Indicates the type of calendar integration used to schedule the meeting.
		// * `1` - [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
		// * `2` - [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
		//
		// Works with the `private_meeting` field to determine whether to share details of meetings or not.
		CalendarType *int `json:"calendar_type,omitempty"`

		// CloseRegistration Whether to close registration after the event date. This value defaults to `false`.
		CloseRegistration *bool `json:"close_registration,omitempty"`

		// CnMeeting Whether to host the meeting in China (CN). This value defaults to `false`.
		// Deprecated:
		CnMeeting *bool `json:"cn_meeting,omitempty"`

		// ContactEmail The contact email address for meeting registration.
		ContactEmail *string `json:"contact_email,omitempty"`

		// ContactName The contact name for meeting registration.
		ContactName *string `json:"contact_name,omitempty"`

		// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
		EmailNotification *bool `json:"email_notification,omitempty"`

		// EncryptionType The type of [end-to-end (E2EE) encryption](https://support.zoom.us/hc/en-us/articles/360048660871) to use for the meeting.
		// * `enhanced_encryption` - Enhanced encryption. Encryption is stored in the cloud when you enable this option.
		// * `e2ee` - End-to-end encryption. The encryption key is stored on your local device and **cannot** be obtained by anyone else. When you use E2EE encryption, [certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording or phone and SIP/H.323 dial-in, are **disabled**.
		EncryptionType *string `json:"encryption_type,omitempty"`

		// FocusMode Whether to enable the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) when the meeting starts.
		FocusMode *bool `json:"focus_mode,omitempty"`

		// GlobalDialInCountries A list of available global dial-in countries.
		GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

		// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
		HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

		// HostVideo Whether to start meetings with the host video on.
		HostVideo *bool `json:"host_video,omitempty"`

		// InMeeting Whether to host the meeting in India (IN). This value defaults to `false`.
		// Deprecated:
		InMeeting *bool `json:"in_meeting,omitempty"`

		// JbhTime If the value of the `join_before_host` field is `true`, this field indicates the time limits within which a participant can join a meeting before the meeting's host:
		//
		// * `0` &mdash; Allow the participant to join the meeting at anytime.
		// * `5` &mdash; Allow the participant to join 5 minutes before the meeting's start time.
		// * `10` &mdash; Allow the participant to join 10 minutes before the meeting's start time.
		JbhTime *int `json:"jbh_time,omitempty"`

		// JoinBeforeHost Whether participants can join the meeting before its host. This field is only used for scheduled meetings (`2`) or recurring meetings (`3` and `8`). This value defaults to `false`.
		//
		// If the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) is enabled, this setting is **disabled**.
		JoinBeforeHost *bool `json:"join_before_host,omitempty"`

		// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
		//
		// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
		LanguageInterpretation *struct {
			// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
			Enable *bool `json:"enable,omitempty"`

			// Interpreters Information about the meeting's language interpreters.
			Interpreters *[]struct {
				// Email The interpreter's email address.
				Email *openapi_types.Email `json:"email,omitempty"`

				// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](/docs/api/rest/other-references/abbreviation-lists/#countries).
				//
				// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
				Languages *string `json:"languages,omitempty"`
			} `json:"interpreters,omitempty"`
		} `json:"language_interpretation,omitempty"`

		// MeetingAuthentication If true, only [authenticated](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) users can join the meeting.
		MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

		// MeetingInvitees A list of the meeting's invitees.
		MeetingInvitees *[]struct {
			// Email The invitee's email address.
			Email *openapi_types.Email `json:"email,omitempty"`
		} `json:"meeting_invitees,omitempty"`

		// MuteUponEntry Whether to mute participants upon entry.
		MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

		// ParticipantVideo Whether to start meetings with the participant video on.
		ParticipantVideo *bool `json:"participant_video,omitempty"`

		// PrivateMeeting Whether to set the meeting as private.
		PrivateMeeting *bool `json:"private_meeting,omitempty"`

		// RegistrantsConfirmationEmail Whether to send registrants an email confirmation:
		// * `true` &mdash; Send a confirmation email.
		// * `false` &mdash; Do not send a confirmation email.
		RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

		// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
		//
		// * `true` &mdash; Send an email notification.
		// * `false` &mdash; Do not send an email notification.
		//
		//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
		RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

		// RegistrationType The meeting's registration type:
		// * `1` &mdash; Attendees register once and can attend any meeting occurrence.
		// * `2` &mdash; Attendees must register for each meeting occurrence.
		// * `3` &mdash; Attendees register once and can select one or more meeting occurrences to attend.
		//
		// This field is only for recurring meetings with fixed times (`8`). This value defaults to `1`.
		RegistrationType *int `json:"registration_type,omitempty"`

		// ShowShareButton Whether to include social media sharing buttons on the meeting's registration page. This setting is only applied to meetings with registration enabled.
		ShowShareButton *bool `json:"show_share_button,omitempty"`

		// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
		//
		// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
		SignLanguageInterpretation *struct {
			// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
			Enable *bool `json:"enable,omitempty"`

			// Interpreters Information about the meeting's sign language interpreters.
			Interpreters *[]struct {
				// Email The interpreter's email address.
				Email *openapi_types.Email `json:"email,omitempty"`

				// SignLanguage The interpreter's sign language.
				//
				//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
				SignLanguage *string `json:"sign_language,omitempty"`
			} `json:"interpreters,omitempty"`
		} `json:"sign_language_interpretation,omitempty"`

		// UsePmi Whether to use a [Personal Meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi) instead of a generated meeting ID. This field is only used for scheduled meetings (`2`), instant meetings (`1`), or recurring meetings with no fixed time (`3`). This value defaults to `false`.
		UsePmi *bool `json:"use_pmi,omitempty"`

		// WaitingRoom Whether to enable the [**Waiting Room** feature](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room). If this value is `true`, this **disables** the `join_before_host` setting.
		WaitingRoom *bool `json:"waiting_room,omitempty"`

		// Watermark Whether to add a watermark when viewing a shared screen.
		Watermark *bool `json:"watermark,omitempty"`
	} `json:"settings,omitempty"`

	// StartTime The meeting's start time. This field is only used for scheduled and/or recurring meetings with a fixed time. This supports local time and GMT formats.
	// * To set a meeting's start time in GMT, use the `yyyy-MM-ddTHH:mm:ssZ` date-time format. For example, `2020-03-31T12:02:00Z`.
	// * To set a meeting's start time using a specific timezone, use the `yyyy-MM-ddTHH:mm:ss` date-time format and specify the [timezone ID](/docs/api/rest/other-references/abbreviation-lists/#timezones) in the `timezone` field. If you do not specify a timezone, the `timezone` value defaults to your Zoom account's timezone. You can also use `UTC` for the `timezone` value.
	StartTime *time.Time `json:"start_time,omitempty"`

	// TemplateId The **account admin meeting template** ID with which to schedule a meeting using a [meeting template](https://support.zoom.us/hc/en-us/articles/360036559151-Meeting-templates). For a list of account admin-provided meeting templates, use the [**List meeting templates**](/docs/api-reference/zoom-api/methods#operation/listMeetingTemplates) API.
	// * At this time, this field **only** accepts account admin meeting template IDs.
	// * To enable the account admin meeting templates feature, [contact Zoom support](https://support.zoom.us/hc/en-us).
	TemplateId *string `json:"template_id,omitempty"`

	// Timezone The timezone to assign to the `start_time` value. This field is only used for scheduled or recurring meetings with a fixed time.
	//
	// For a list of supported timezones and their formats, see our [timezone list](/docs/api/rest/other-references/abbreviation-lists/#timezones).
	Timezone *string `json:"timezone,omitempty"`

	// Topic The meeting's topic.
	Topic *string `json:"topic,omitempty"`

	// TrackingFields Information about the meeting's tracking fields.
	TrackingFields *[]struct {
		// Field The tracking field's label.
		Field string `json:"field"`

		// Value The tracking field's value.
		Value *string `json:"value,omitempty"`
	} `json:"tracking_fields,omitempty"`

	// Type The type of meeting:
	// * `1` &mdash; An instant meeting.
	// * `2` &mdash; A scheduled meeting.
	// * `3` &mdash; A recurring meeting with no fixed time.
	// * `8` &mdash; A recurring meeting with fixed time.
	Type *int `json:"type,omitempty"`
}

// UserPasswordJSONBody defines parameters for UserPassword.
type UserPasswordJSONBody struct {
	// Password User password. Should be less than 32 characters.
	//
	// **Note:** If the account owner or admin has enabled [enhanced password requirements](https://support.zoom.us/hc/en-us/articles/360034675592-Advanced-security-settings#h_fa9186e4-6818-4f7a-915c-2e25c19f0acd), the value provided in this field must meet those requirements. These requirements can be retrieved by calling the [**Get account settings](/docs/api-reference/zoom-api/ma#operation/accountSettings) API and referring to the `password_requirement` field present in the `security` object.
	Password string `json:"password"`
}

// UserPasswordParamsUserId0 defines parameters for UserPassword.
type UserPasswordParamsUserId0 = string

// UserPasswordParamsUserId1 defines parameters for UserPassword.
type UserPasswordParamsUserId1 = openapi_types.Email

// UserPasswordParamsUserId2 defines parameters for UserPassword.
type UserPasswordParamsUserId2 = string

// UserPermissionParamsUserId0 defines parameters for UserPermission.
type UserPermissionParamsUserId0 = string

// UserPermissionParamsUserId1 defines parameters for UserPermission.
type UserPermissionParamsUserId1 = openapi_types.Email

// UserPermissionParamsUserId2 defines parameters for UserPermission.
type UserPermissionParamsUserId2 = string

// UserPictureDeleteParamsUserId0 defines parameters for UserPictureDelete.
type UserPictureDeleteParamsUserId0 = string

// UserPictureDeleteParamsUserId1 defines parameters for UserPictureDelete.
type UserPictureDeleteParamsUserId1 = openapi_types.Email

// UserPictureDeleteParamsUserId2 defines parameters for UserPictureDelete.
type UserPictureDeleteParamsUserId2 = string

// UserPictureMultipartBody defines parameters for UserPicture.
type UserPictureMultipartBody struct {
	// PicFile The file's path.
	PicFile string `json:"pic_file"`
}

// UserPictureParamsUserId0 defines parameters for UserPicture.
type UserPictureParamsUserId0 = string

// UserPictureParamsUserId1 defines parameters for UserPicture.
type UserPictureParamsUserId1 = openapi_types.Email

// UserPictureParamsUserId2 defines parameters for UserPicture.
type UserPictureParamsUserId2 = string

// UpdatePresenceStatusJSONBody defines parameters for UpdatePresenceStatus.
type UpdatePresenceStatusJSONBody struct {
	// Duration If updating the user's status to `Do_Not_Disturb`, the duration for which the status should remain as `Do_Not_Disturb`, in minutes.
	Duration *int `json:"duration,omitempty"`

	// Status The user's presence status:
	// * `Away`
	// * `Do_Not_Disturb`
	// * `Available`
	// * `In_Calendar_Event`
	// * `Presenting`
	// * `In_A_Zoom_Meeting`
	// * `On_A_Call`
	//
	// Users who are on Zoom Client with a version **lower than 5.3.0** can update the status from:
	// * `Away` to `Do_Not_Disturb`
	// * `Available` to `Do_Not_Disturb`
	//
	// Users who are on **Zoom Client 5.3.0 or higher** can update the status from:
	// * `Do_Not_Disturb` to `Away`
	// * `Do_Not_Disturb` to `Available`
	// * `Available` to `Away`
	// * `Away` to `Available`
	Status *string `json:"status,omitempty"`
}

// UserSchedulersDeleteParamsUserId0 defines parameters for UserSchedulersDelete.
type UserSchedulersDeleteParamsUserId0 = string

// UserSchedulersDeleteParamsUserId1 defines parameters for UserSchedulersDelete.
type UserSchedulersDeleteParamsUserId1 = openapi_types.Email

// UserSchedulersDeleteParamsUserId2 defines parameters for UserSchedulersDelete.
type UserSchedulersDeleteParamsUserId2 = string

// UserSchedulersParamsUserId0 defines parameters for UserSchedulers.
type UserSchedulersParamsUserId0 = string

// UserSchedulersParamsUserId1 defines parameters for UserSchedulers.
type UserSchedulersParamsUserId1 = openapi_types.Email

// UserSchedulersParamsUserId2 defines parameters for UserSchedulers.
type UserSchedulersParamsUserId2 = string

// UserSchedulerDeleteParamsUserId0 defines parameters for UserSchedulerDelete.
type UserSchedulerDeleteParamsUserId0 = string

// UserSchedulerDeleteParamsUserId1 defines parameters for UserSchedulerDelete.
type UserSchedulerDeleteParamsUserId1 = openapi_types.Email

// UserSchedulerDeleteParamsUserId2 defines parameters for UserSchedulerDelete.
type UserSchedulerDeleteParamsUserId2 = string

// UserSettingsParams defines parameters for UserSettings.
type UserSettingsParams struct {
	// LoginType The user's login method:
	// * `0` &mdash; Facebook OAuth
	// * `1` &mdash; Google OAuth
	// * `24` &mdash; Apple OAuth
	// * `27` &mdash; Microsoft OAuth
	// * `97` &mdash; Mobile device
	// * `98` &mdash; RingCentral OAuth
	// * `99` &mdash; API user
	// * `100` &mdash; Zoom Work email
	// * `101` &mdash; Single Sign-On (SSO)
	//
	// The following login methods are only available in China:
	// * `11` &mdash; Phone number
	// * `21` &mdash; WeChat
	// * `23` &mdash; Alipay
	LoginType *int `form:"login_type,omitempty" json:"login_type,omitempty"`

	// Option Optional query parameters:
	// * `meeting_authentication` &mdash; Use this query parameter to view the [meeting authentication settings](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) applied to the user's account.
	// * `recording_authentication` &mdash; Use this query parameter to view the [recording authentication settings](https://support.zoom.us/hc/en-us/articles/360037756671-Authentication-Profiles-for-Cloud-Recordings) applied to the user's account.
	// * `meeting_security` &mdash; Use this query parameter to view the meeting security settings applied to the user's account.
	Option *string `form:"option,omitempty" json:"option,omitempty"`

	// CustomQueryFields Provide the name of the field by which you would like to filter the response. For example, if you provide &quot;host_video&quot; as the value of this field, you will get a response similar to the following:
	//
	// {
	//     &quot;schedule_meeting&quot;: {
	//         &quot;host_video&quot;: false
	//     }
	// }
	//
	//  You can provide multiple values by separating them with commas(example: &quot;host_video,participant_video&rdquo;).
	CustomQueryFields *string `form:"custom_query_fields,omitempty" json:"custom_query_fields,omitempty"`
}

// UserSettingsParamsUserId0 defines parameters for UserSettings.
type UserSettingsParamsUserId0 = string

// UserSettingsParamsUserId1 defines parameters for UserSettings.
type UserSettingsParamsUserId1 = openapi_types.Email

// UserSettingsParamsUserId2 defines parameters for UserSettings.
type UserSettingsParamsUserId2 = string

// UserSettingsUpdateJSONBody defines parameters for UserSettingsUpdate.
type UserSettingsUpdateJSONBody struct {
	union json.RawMessage
}

// UserSettingsUpdateParams defines parameters for UserSettingsUpdate.
type UserSettingsUpdateParams struct {
	// Option Optional query parameters:
	// * `meeting_authentication` &mdash; Use this query parameter to view the [meeting authentication settings](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) applied to the user's account.
	// * `recording_authentication` &mdash; Use this query parameter to view the [recording authentication settings](https://support.zoom.us/hc/en-us/articles/360037756671-Authentication-Profiles-for-Cloud-Recordings) applied to the user's account.
	// * `meeting_security` &mdash; Use this query parameter to view the meeting security settings applied to the user's account.
	Option *string `form:"option,omitempty" json:"option,omitempty"`
}

// UserSettingsUpdateParamsUserId0 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateParamsUserId0 = string

// UserSettingsUpdateParamsUserId1 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateParamsUserId1 = openapi_types.Email

// UserSettingsUpdateParamsUserId2 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateParamsUserId2 = string

// UserSettingsUpdateJSONBody0 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateJSONBody0 struct {
	EmailNotification *struct {
		// AlternativeHostReminder When an alternative host is set or removed from a meeting.
		AlternativeHostReminder *bool `json:"alternative_host_reminder,omitempty"`

		// CancelMeetingReminder When a meeting is cancelled.
		CancelMeetingReminder *bool `json:"cancel_meeting_reminder,omitempty"`

		// CloudRecordingAvailableReminder Whether to notify the host when a cloud recording is available.
		CloudRecordingAvailableReminder *bool `json:"cloud_recording_available_reminder,omitempty"`

		// JbhReminder When attendees join meeting before host.
		JbhReminder *bool `json:"jbh_reminder,omitempty"`

		// RecordingAvailableReminderAlternativeHosts Whether to notify any alternative hosts when a cloud recording is available.
		RecordingAvailableReminderAlternativeHosts *bool `json:"recording_available_reminder_alternative_hosts,omitempty"`

		// RecordingAvailableReminderSchedulers Whether to notify the person who scheduled the meeting or webinar for the host when a cloud recording is available.
		RecordingAvailableReminderSchedulers *bool `json:"recording_available_reminder_schedulers,omitempty"`

		// ScheduleForReminder Notify the host there is a meeting is scheduled, rescheduled, or cancelled.
		ScheduleForReminder *bool `json:"schedule_for_reminder,omitempty"`
	} `json:"email_notification,omitempty"`
	Feature *struct {
		// ConcurrentMeeting The user's assigned [Concurrent Meeting](https://support.zoom.us/hc/en-us/articles/206122046) type:
		// * `Basic`
		// * `Plus`
		// * `None`
		//
		//  **Note:** This feature requires a Concurrent Meeting Basic or Plus plan subscription.
		ConcurrentMeeting *string `json:"concurrent_meeting,omitempty"`

		// LargeMeeting Enable [large meeting](https://support.zoom.us/hc/en-us/articles/201362823-What-is-a-Large-Meeting-) feature for the user.
		LargeMeeting *bool `json:"large_meeting,omitempty"`

		// LargeMeetingCapacity Set the meeting capacity for the user if the user has **Large meeting** feature enabled. The value for the field can be either 500 or 1000.
		LargeMeetingCapacity *int `json:"large_meeting_capacity,omitempty"`

		// MeetingCapacity Set a user's meeting capacity. User's meeting capacity denotes the maximum number of participants that can join a meeting scheduled by the user.
		MeetingCapacity *int `json:"meeting_capacity,omitempty"`

		// Webinar Enable Webinar feature for the user.
		Webinar *bool `json:"webinar,omitempty"`

		// WebinarCapacity The user's webinar capacity. This only applies to users with the [**Webinar**](https://support.zoom.us/hc/en-us/articles/200917029-Getting-started-with-webinar) feature enabled:
		// * `100`
		// * `500`
		// * `501`
		// * `1000`
		// * `1001`
		// * `3000`
		// * `5000`
		// * `10000`
		WebinarCapacity *int `json:"webinar_capacity,omitempty"`

		// ZoomCustomerManagedKey Whether the user has a Zoom Customer Managed Key license.
		ZoomCustomerManagedKey *bool `json:"zoom_customer_managed_key,omitempty"`

		// ZoomEvents Whether to enable the Zoom Events feature for the user.
		ZoomEvents *bool `json:"zoom_events,omitempty"`

		// ZoomEventsCapacity The user's Zoom Events plan capacity: `500`, `1000`, `3000`, `5000`, `10000`, `20000`, `30000`, or `50000`.
		ZoomEventsCapacity *int `json:"zoom_events_capacity,omitempty"`

		// ZoomIqForSales Whether the user has a Zoom IQ license. For information about a Zoom IQ license, contact [Zoom Support](https://support.zoom.us/hc/en-us/articles/201362003).
		ZoomIqForSales *bool `json:"zoom_iq_for_sales,omitempty"`

		// ZoomPhone Zoom phone feature.
		ZoomPhone *bool `json:"zoom_phone,omitempty"`

		// ZoomSpots Whether the user has a Zoom Spots license.
		ZoomSpots *bool `json:"zoom_spots,omitempty"`

		// ZoomTranslatedCaptions Whether the user has a Zoom Translated Captions license.
		ZoomTranslatedCaptions *bool `json:"zoom_translated_captions,omitempty"`

		// ZoomWhiteboard Whether the user has a Zoom Whiteboard license.
		ZoomWhiteboard *bool `json:"zoom_whiteboard,omitempty"`

		// ZoomWhiteboardPlus Whether the user has a Zoom Whiteboard Plus license.
		ZoomWhiteboardPlus *bool `json:"zoom_whiteboard_plus,omitempty"`
	} `json:"feature,omitempty"`
	InMeeting *struct {
		// AllowHostPanelistsToUseAudibleClap Whether to allow host and panelist to use audible clap.
		AllowHostPanelistsToUseAudibleClap *bool `json:"allow_host_panelists_to_use_audible_clap,omitempty"`

		// AllowHostToEnableFocusMode Whether the host can enable [**Focus Mode**](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) when scheduling a meeting. This value defaults to `null`.
		AllowHostToEnableFocusMode *bool `json:"allow_host_to_enable_focus_mode,omitempty"`

		// AllowLiveStreaming Allow livestreaming.
		AllowLiveStreaming *bool `json:"allow_live_streaming,omitempty"`

		// AllowParticipantsChatWith Who participants can chat with:
		// * `1` &mdash; The participant cannot use chat.
		// * `2` &mdash; The participant can chat with the host and co-hosts only.
		//  * `3` &mdash; The participant can chat with other participants publicly.
		// * `4` - The participant can chat with other participants publicly and privately.
		//
		//  **Note:** This setting is only available with client versions 5.7.3 and above.
		AllowParticipantsChatWith *int `json:"allow_participants_chat_with,omitempty"`

		// AllowShowZoomWindows Enable the [**Show Zoom windows during screen share**](https://support.zoom.us/hc/en-us/articles/360061383571-Showing-Zoom-windows-during-screen-share) feature.
		AllowShowZoomWindows *bool `json:"allow_show_zoom_windows,omitempty"`

		// AllowUsersSaveChats How participants can save meeting chats:
		// * `1` &mdash; Participants cannot save meeting chats.
		// * `2` &mdash; Participants can only save host and co-host meeting chats.
		// * `3` &mdash; Participants can save all meeting chats.
		AllowUsersSaveChats *int `json:"allow_users_save_chats,omitempty"`

		// AllowUsersToDeleteMessagesInMeetingChat If the value of this field is set to `true`,  allow users to delete messages in the in-meeting chat.
		AllowUsersToDeleteMessagesInMeetingChat *bool `json:"allow_users_to_delete_messages_in_meeting_chat,omitempty"`

		// Annotation Allow meeting participants to use the [annotation tools](https://support.zoom.us/hc/en-us/articles/115005706806). This value defaults to `false`.
		Annotation *bool `json:"annotation,omitempty"`

		// AttendeeOnHold Allow the host to put an attendee on hold. This value defaults to `false`. **This field has been deprecated and is no longer supported.**
		AttendeeOnHold *bool `json:"attendee_on_hold,omitempty"`

		// AttentionModeFocusMode Whether the [**Focus Mode**](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) feature is enabled. When enabled, this feature only displays the host and co-hosts' video and profile pictures during a meeting.
		//
		//  This value defaults to `false`.
		AttentionModeFocusMode *bool `json:"attention_mode_focus_mode,omitempty"`

		// AutoAnswer Allow the user to view and add contacts to the [**Auto-answer group in chat**](https://support.zoom.us/hc/en-us/articles/203736135-Auto-answering-invitations-to-meetings) feature. Calls from members of the **Auto Answer Group** will be automatically answered the user.
		AutoAnswer *bool `json:"auto_answer,omitempty"`

		// AutoSavingChat Automatically save all in-meeting chats. This value defaults to `false`.
		AutoSavingChat *bool `json:"auto_saving_chat,omitempty"`

		// BreakoutRoom Allow the meeting host to split meeting participants into separate breakout rooms.
		BreakoutRoom *bool `json:"breakout_room,omitempty"`

		// BreakoutRoomSchedule Allow the host to assign participants to breakout rooms when scheduling. This feature is **only** available in version 4.5.0 or higher.
		BreakoutRoomSchedule *bool `json:"breakout_room_schedule,omitempty"`

		// Chat Enable chat during meeting for all participants. This value defaults to `false`.
		Chat *bool `json:"chat,omitempty"`

		// ClosedCaption Enable closed captions. This value defaults to `false`.
		ClosedCaption *bool `json:"closed_caption,omitempty"`

		// ClosedCaptioning Information about the user's closed captioning settings.
		ClosedCaptioning *struct {
			// AutoTranscribing Allow a live transcription service to transcribe meetings.
			AutoTranscribing *bool `json:"auto_transcribing,omitempty"`

			// Enable Allow the host to type closed captions or assign a participant or 3rd-party service to provide closed captioning.
			Enable *bool `json:"enable,omitempty"`

			// SaveCaption Allow participants to save closed captions or transcripts.
			SaveCaption *bool `json:"save_caption,omitempty"`

			// ThirdPartyCaptioningService Allow the use of an API token to integrate with 3rd-party closed captioning services.
			ThirdPartyCaptioningService *bool `json:"third_party_captioning_service,omitempty"`

			// ViewFullTranscript Allow the viewing of full transcripts in the in-meeting side panel.
			ViewFullTranscript *bool `json:"view_full_transcript,omitempty"`
		} `json:"closed_captioning,omitempty"`

		// CoHost Allow the host to add co-hosts. This value defaults to `false`.
		CoHost *bool `json:"co_host,omitempty"`

		// CustomDataCenterRegions Use custom [data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-meetings-webinars):
		// * `true` &mdash; Users can [select data center regions](https://support.zoom.us/hc/en-us/articles/360042411451-Selecting-data-center-regions-for-hosted-meetings-and-webinars) to use for hosting real-time meeting traffic. The data center regions can be provided in the `data_center_regions` field.
		// * `false` &mdash; Only use the default data center regions.
		CustomDataCenterRegions *bool `json:"custom_data_center_regions,omitempty"`

		// CustomLiveStreamingService Allow custom livestreaming.
		CustomLiveStreamingService *bool `json:"custom_live_streaming_service,omitempty"`

		// CustomServiceInstructions The custom livestreaming service instructions.
		CustomServiceInstructions *string `json:"custom_service_instructions,omitempty"`

		// DataCenterRegions If the value of `custom_data_center_regions` is `true`, a comma-separated list of the following [data center regions](https://support.zoom.us/hc/en-us/articles/360059254691-Datacenter-abbreviation-list) to opt in to:
		// * `AU` &mdash; Australia.
		// * `LA` &mdash; Latin America.
		// * `CA` &mdash; Canada.
		// * `CN` &mdash; China.
		// * `DE` &mdash; Germany.
		// * `HK` &mdash; Hong Kong SAR.
		// * `IN` &mdash; India.
		// * `IE` &mdash; Ireland.
		// * `TY` &mdash; Japan.
		// * `MX` &mdash; Mexico.
		// * `NL` &mdash; Netherlands.
		// * `SG` &mdash; Singapore.
		// * `US` &mdash; United States.
		DataCenterRegions *[]string `json:"data_center_regions,omitempty"`

		// DisableScreenSharingForHostMeetings Enable the **Disable desktop screen sharing for meetings you host** setting.
		DisableScreenSharingForHostMeetings *bool `json:"disable_screen_sharing_for_host_meetings,omitempty"`

		// DisableScreenSharingForInMeetingGuests Enable the **Disable screen sharing when guests are in the meeting** setting.
		DisableScreenSharingForInMeetingGuests *bool `json:"disable_screen_sharing_for_in_meeting_guests,omitempty"`

		// E2eEncryption Require [AES encryption](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard) for meetings.
		E2eEncryption *bool `json:"e2e_encryption,omitempty"`

		// EntryExitChime When to play the meeting entry/exit sound notification:
		// * `host` &mdash; Only when the host joins or leaves.
		// * `all` &mdash; When any participant joins or leaves.
		// * `none` - Disable the entry/exit sound notification.
		//
		// This value defaults to `all`.
		EntryExitChime *string `json:"entry_exit_chime,omitempty"`

		// FarEndCameraControl Allow another user to take control of the user's camera. This value defaults to `false`.
		FarEndCameraControl *bool `json:"far_end_camera_control,omitempty"`

		// Feedback Enable the [**Feedback to Zoom**](https://support.zoom.us/hc/en-us/articles/115005838023-Feedback-to-Zoom) setting. This value defaults to `false`.
		Feedback *bool `json:"feedback,omitempty"`

		// FileTransfer Indicates whether [in-meeting file transfer](https://support.zoom.us/hc/en-us/articles/209605493-In-meeting-file-transfer) setting has been enabled for the user or not.
		FileTransfer *bool `json:"file_transfer,omitempty"`

		// GroupHd Enable group HD video. This value defaults to `false`.
		GroupHd *bool `json:"group_hd,omitempty"`

		// JoinFromDesktop Allow participants to join a meeting directly from their desktop browser. Note that the meeting experience from the desktop browser is limited.
		JoinFromDesktop *bool `json:"join_from_desktop,omitempty"`

		// JoinFromMobile Allow participants to join a meeting directly from their mobile browser. Note that the meeting experience from the mobile browser is limited.
		JoinFromMobile *bool `json:"join_from_mobile,omitempty"`

		// LanguageInterpretation Information about the [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Using-Language-Interpretation-in-your-meeting-or-webinar) settings.
		LanguageInterpretation *struct {
			// AllowParticipantsToSpeakInListeningChannel Whether to allow participants to speak in listening channel.
			AllowParticipantsToSpeakInListeningChannel *bool `json:"allow_participants_to_speak_in_listening_channel,omitempty"`

			// AllowUpTo25CustomLanguagesWhenSchedulingMeetings Whether to allow up to 25 custom languages when scheduling meetings.
			AllowUpTo25CustomLanguagesWhenSchedulingMeetings *bool `json:"allow_up_to_25_custom_languages_when_scheduling_meetings,omitempty"`

			// CustomLanguages A list of user-defined supported languages.
			CustomLanguages *[]string `json:"custom_languages,omitempty"`

			// Enable Allow hosts to assign participants as interpreters who can interpret one language into another in real-time.
			Enable *bool `json:"enable,omitempty"`

			// EnableLanguageInterpretationByDefault Whether enable language interpretation by default.
			EnableLanguageInterpretationByDefault *bool `json:"enable_language_interpretation_by_default,omitempty"`
		} `json:"language_interpretation,omitempty"`

		// LiveStreamingFacebook Allow Facebook livestreaming.
		LiveStreamingFacebook *bool `json:"live_streaming_facebook,omitempty"`

		// LiveStreamingYoutube Allow YouTube livestreaming.
		LiveStreamingYoutube *bool `json:"live_streaming_youtube,omitempty"`

		// ManualCaptioning Information about manual captioning settings.
		ManualCaptioning *struct {
			// AllowToType Allow the host to manually caption or let the host assign a participant to provide manual captioning.
			AllowToType *bool `json:"allow_to_type,omitempty"`

			// AutoGeneratedCaptions Enable Zoom's [live transcription feature](https://support.zoom.us/hc/en-us/articles/207279736-Managing-closed-captioning-and-live-transcription#h_01FHGGHYJ4457H4GSZY0KM3NSB).
			AutoGeneratedCaptions *bool `json:"auto_generated_captions,omitempty"`

			// FullTranscript Enable the viewing of full transcripts in the in-meeting side panel.
			FullTranscript *bool `json:"full_transcript,omitempty"`

			// ManualCaptions [Enable manual closed captioning](https://support.zoom.us/hc/en-us/articles/207279736-Managing-closed-captioning-and-live-transcription).
			ManualCaptions *bool `json:"manual_captions,omitempty"`

			// SaveCaptions Allow participants to [save closed captions or transcripts](https://support.zoom.us/hc/en-us/articles/360060958752).
			//
			//  **Note:** If the `full_transcript` field is set to `false`, participants **cannot** save captions.
			SaveCaptions *bool `json:"save_captions,omitempty"`

			// ThirdPartyCaptioningService Allow the use of an API token to integrate with a [3rd-party device](https://support.zoom.us/hc/en-us/articles/115002212983) to provide closed captioning.
			ThirdPartyCaptioningService *bool `json:"third_party_captioning_service,omitempty"`
		} `json:"manual_captioning,omitempty"`

		// MeetingPolling Information about the account's meeting polling settings.
		MeetingPolling *struct {
			// AdvancedPolls Whether to allow the host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. The host can also set the correct answers for quizzes they create.
			AdvancedPolls *bool `json:"advanced_polls,omitempty"`

			// AllowAlternativeHostToAddEdit Whether to allow alternative hosts to add or edit polls and quizzes.
			AllowAlternativeHostToAddEdit *bool `json:"allow_alternative_host_to_add_edit,omitempty"`

			// AllowHostToUploadImage Whether to allow host to upload an image for each question.
			AllowHostToUploadImage *bool `json:"allow_host_to_upload_image,omitempty"`

			// Enable Whether to allow the host to add polls before or during a meeting.
			Enable *bool `json:"enable,omitempty"`

			// RequireAnswersToBeAnonymous Whether to require answers to be anonymous.
			RequireAnswersToBeAnonymous *bool `json:"require_answers_to_be_anonymous,omitempty"`
		} `json:"meeting_polling,omitempty"`

		// MeetingQuestionAnswer Allow participants to ask questions for the host and participants to answer.
		MeetingQuestionAnswer *bool `json:"meeting_question_answer,omitempty"`

		// MeetingReactions Whether meeting participants can [communicate using the emoji reactions](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions) located in the **Reactions** menu in the meeting toolbar.
		MeetingReactions *bool `json:"meeting_reactions,omitempty"`

		// MeetingReactionsEmojis Choose from the following meeting reaction options:
		// * `all` &mdash; All emojis: Allow meeting participants to use any emoji available in Zoom chat as a reaction in a meeting.
		// * `selected` &mdash; Selected emojis: Allow meeting participants to use the 6 standard meeting reaction emojis: Clapping Hands, Thumbs Up, Heart, Tears of Joy, Open Mouth, Party Popper (Tada, Celebration)
		MeetingReactionsEmojis *string `json:"meeting_reactions_emojis,omitempty"`

		// MeetingSurvey Allow the host to present a survey to participants once a meeting has ended. This feature is only available in version 5.7.3 or higher.
		MeetingSurvey *bool `json:"meeting_survey,omitempty"`

		// NonVerbalFeedback Enable the [**Non-verbal feedback**](https://support.zoom.us/hc/en-us/articles/115001286183-Nonverbal-feedback-and-meeting-reactions-) setting.  This value defaults to `false`.
		NonVerbalFeedback *bool `json:"non_verbal_feedback,omitempty"`

		// ParticipantsShareSimultaneously Indicates how many participants can share at the same time. The value can be one of the following:
		//
		// `one`: Only one participant can share at a time
		// .
		//
		// `multiple`: Multiple participants can share simultaneously (dual monitors recommended).
		ParticipantsShareSimultaneously *string `json:"participants_share_simultaneously,omitempty"`

		// Polling Add polls to the meeting controls. This value defaults to `false`.
		Polling *bool `json:"polling,omitempty"`

		// PostMeetingFeedback Whether to display a thumbs up or thumbs down feedback survey at the end of each meeting.
		PostMeetingFeedback *bool `json:"post_meeting_feedback,omitempty"`

		// PrivateChat [Enable private chat](https://support.zoom.us/hc/en-us/articles/360060835932-Enabling-and-disabling-private-chat) between participants during meetings. This value defaults to `false`.
		PrivateChat *bool `json:"private_chat,omitempty"`

		// RecordPlayVoice Let the user record and play their own voice.
		RecordPlayVoice *bool `json:"record_play_voice,omitempty"`

		// RemoteControl Enable the [**Remote control**](https://support.zoom.us/hc/en-us/articles/201362673-Requesting-or-giving-remote-control) setting.  This value defaults to `false`.
		RemoteControl *bool `json:"remote_control,omitempty"`

		// RemoteSupport Enable the [**Remote support**](https://support.zoom.us/hc/en-us/articles/360060951012-Enabling-remote-support) setting. This value defaults to `false`.
		RemoteSupport *bool `json:"remote_support,omitempty"`

		// RequestPermissionToUnmuteParticipants Indicates whether the [**Request permission to unmute participants**](https://support.zoom.us/hc/en-us/articles/203435537-Muting-and-unmuting-participants-in-a-meeting#h_01EGK4XFWS1SJGZ71MYGKF7260) option has been enabled for the user or not.
		RequestPermissionToUnmuteParticipants *bool `json:"request_permission_to_unmute_participants,omitempty"`

		// ScreenSharing Allow host and participants to share their screen or content during meetings
		ScreenSharing *bool `json:"screen_sharing,omitempty"`

		// ShareDualCamera Allow the use of shared dual cameras. This value defaults to `false`. **This field is deprecated.**
		// Deprecated:
		ShareDualCamera *bool `json:"share_dual_camera,omitempty"`

		// ShowAJoinFromYourBrowserLink Allow participants to join a meeting directly from their browser and bypass the Zoom application download process. This is useful for participants who cannot download, install, or run applications. Note that the meeting experience from the browser is limited.
		ShowAJoinFromYourBrowserLink *bool `json:"show_a_join_from_your_browser_link,omitempty"`

		// ShowMeetingControlToolbar Always display the [in-meeting controls](https://support.zoom.us/hc/en-us/articles/360021921032-Zoom-Room-meeting-controls-and-settings#h_01EQCC03TCPRC72VKXZ7W47FDX).
		ShowMeetingControlToolbar *bool `json:"show_meeting_control_toolbar,omitempty"`

		// SignLanguageInterpretation Allow hosts to assign participants as sign language interpreters who can interpret one language into sign language in real-time. Hosts can assign interpreters when scheduling, or during the meeting itself. This feature is only available with version 5.11.3 or later.
		SignLanguageInterpretation *struct {
			// CustomLanguages A list of user-defined supported languages.
			CustomLanguages *[]string `json:"custom_languages,omitempty"`

			// Enable Whether to allow hosts to assign participants as sign language interpreters who can interpret one language into another in real-time.
			Enable *bool `json:"enable,omitempty"`

			// EnableSignLanguageInterpretationByDefault Whether to enable sign language interpretation view by default in scheduler.
			EnableSignLanguageInterpretationByDefault *bool `json:"enable_sign_language_interpretation_by_default,omitempty"`

			// Languages A list of system-supported languages.
			Languages *[]string `json:"languages,omitempty"`
		} `json:"sign_language_interpretation,omitempty"`

		// SlideControl Whether the person sharing during a presentation can allow others to control the slide presentation. This feature is only available in version 5.8.3 or higher.
		SlideControl *bool `json:"slide_control,omitempty"`

		// VirtualBackground Enable Virtual Backgrounds. This value defaults to `false`.
		VirtualBackground *bool `json:"virtual_background,omitempty"`

		// VirtualBackgroundSettings The user's Virtual Background settings.
		VirtualBackgroundSettings *struct {
			// AllowUploadCustom Allow the user to upload custom Virtual Backgrounds.
			AllowUploadCustom *bool `json:"allow_upload_custom,omitempty"`

			// AllowVideos Allow the use of videos for Virtual Backgrounds.
			AllowVideos *bool `json:"allow_videos,omitempty"`

			// Enable Enable Virtual Backgrounds.
			Enable *bool `json:"enable,omitempty"`

			// Files Information about the Virtual Background files.
			Files *[]struct {
				// Id The Virtual Background file's ID.
				Id *string `json:"id,omitempty"`

				// IsDefault Whether the file is the default Virtual Background file.
				IsDefault *bool `json:"is_default,omitempty"`

				// Name The Virtual Background file's name.
				Name *string `json:"name,omitempty"`

				// Size The Virtual Background file's size, in bytes.
				Size *int `json:"size,omitempty"`

				// Type The Virtual Background file's type.
				Type *string `json:"type,omitempty"`
			} `json:"files,omitempty"`
		} `json:"virtual_background_settings,omitempty"`

		// WaitingRoom Enable the [**Waiting Room**](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) feature. This value defaults to `false`.
		WaitingRoom *bool `json:"waiting_room,omitempty"`

		// WebinarChat Information about the user's webinar chat settings.
		WebinarChat *struct {
			// AllowAttendeesChatWith Allow webinar attendees to chat with:
			// * `1` &mdash; No one.
			// * `2` &mdash; Host and all panelists.
			// * `3` &mdash; Everyone.
			AllowAttendeesChatWith *int `json:"allow_attendees_chat_with,omitempty"`

			// AllowAutoSaveLocalChatFile Automatically save chat messages to a local file on the host's computer when the webinar ends.
			AllowAutoSaveLocalChatFile *bool `json:"allow_auto_save_local_chat_file,omitempty"`

			// AllowPanelistsChatWith Who webinar panelists can chat with:
			// * `1` &mdash; Host and all panelists.
			// * `2` &mdash; Everyone.
			AllowPanelistsChatWith *int `json:"allow_panelists_chat_with,omitempty"`

			// AllowPanelistsSendDirectMessage Allow webinar panelists to send direct messages to other panelists.
			AllowPanelistsSendDirectMessage *bool `json:"allow_panelists_send_direct_message,omitempty"`

			// AllowUsersSaveChats How webinar attendees can save chats:
			// * `0` &mdash; Attendees cannot save chats.
			// * `1` &mdash; Attendees can only save host and panelist chats.
			// * `2` &mdash; Attendees can save all chats.
			AllowUsersSaveChats *int `json:"allow_users_save_chats,omitempty"`

			// DefaultAttendeesChatWith By default, allow webinar attendees to chat with:
			// * `1` &mdash; Host and all panelists.
			// * `2` &mdash; Everyone.
			DefaultAttendeesChatWith *int `json:"default_attendees_chat_with,omitempty"`

			// Enable Allow webinar participants to send chat messages.
			Enable *bool `json:"enable,omitempty"`
		} `json:"webinar_chat,omitempty"`
		WebinarLiveStreaming *struct {
			// CustomServiceInstructions The specific instructions to allow your account's meeting hosts to configure a custom livestream.
			CustomServiceInstructions *string `json:"custom_service_instructions,omitempty"`

			// Enable Whether webinar livestreaming is enabled.
			Enable *bool `json:"enable,omitempty"`

			// LiveStreamingReminder Notify users to watch the livestream. This does not apply to custom RTMP (real-time messaging protocol).
			LiveStreamingReminder *bool `json:"live_streaming_reminder,omitempty"`

			// LiveStreamingService The available livestreaming services:
			// * `facebook`
			// * `workplace_by_facebook`
			// * `youtube`
			// * `custom_live_streaming_service`
			LiveStreamingService *[]string `json:"live_streaming_service,omitempty"`
		} `json:"webinar_live_streaming,omitempty"`

		// WebinarPolling Information about the user's webinar polling settings.
		WebinarPolling *struct {
			// AdvancedPolls Whether to allow the host to create advanced polls and quizzes. Advanced polls and quizzes include single choice, multiple choice, drop down, matching, short answer, long answer, rank order, and fill-in-the-blank questions. The host can also set the correct answers for quizzes they create.
			AdvancedPolls *bool `json:"advanced_polls,omitempty"`

			// AllowAlternativeHostToAddEdit Whether to allow alternative hosts to add or edit polls and quizzes.
			AllowAlternativeHostToAddEdit *bool `json:"allow_alternative_host_to_add_edit,omitempty"`

			// AllowHostToUploadImage Whether to allow host to upload an image for each question.
			AllowHostToUploadImage *bool `json:"allow_host_to_upload_image,omitempty"`

			// Enable Allow the host to add polls before or during a webinar.
			Enable *bool `json:"enable,omitempty"`

			// RequireAnswersToBeAnonymous Whether to require answers to be anonymous.
			RequireAnswersToBeAnonymous *bool `json:"require_answers_to_be_anonymous,omitempty"`
		} `json:"webinar_polling,omitempty"`

		// WebinarReactions Set this field to true to use [webinar reactions](https://support.zoom.us/hc/en-us/articles/4803536268429).
		WebinarReactions *bool `json:"webinar_reactions,omitempty"`

		// WebinarSurvey Allow the host to present surveys to attendees once a webinar has ended.
		WebinarSurvey *bool `json:"webinar_survey,omitempty"`

		// Whiteboard Whether to enable the [**Zoom Whiteboard**](https://support.zoom.us/hc/en-us/articles/4410916881421) feature.
		Whiteboard *bool `json:"whiteboard,omitempty"`

		// WhoCanShareScreen Indicates who can share their screen or content during meetings. The value can be one of the following:
		//
		// `host`: Only host can share the screen.
		//
		// `all`: Both hosts and attendees can share their screen during meetings. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
		WhoCanShareScreen *string `json:"who_can_share_screen,omitempty"`

		// WhoCanShareScreenWhenSomeoneIsSharing Indicates who is allowed to start sharing screen when someone else in the meeting is sharing their screen. The value can be one of the following:
		//
		// `host`: Only a host can share the screen when someone else is sharing.
		//
		// `all`: Anyone in the meeting is allowed to start sharing their screen when someone else is sharing. For Webinar, the hosts and panelists can start screen sharing, but not the attendees.
		WhoCanShareScreenWhenSomeoneIsSharing *string `json:"who_can_share_screen_when_someone_is_sharing,omitempty"`

		// WorkplaceByFacebook Allow Workplace by Facebook livestreaming.
		WorkplaceByFacebook *bool `json:"workplace_by_facebook,omitempty"`
	} `json:"in_meeting,omitempty"`
	Profile *struct {
		RecordingStorageLocation *struct {
			// AllowedValues Users can choose the country to store their recorded content. Content can include meeting, webinar, and phone recordings, as well as voicemail, transcripts, and custom greeting prompts. See [Managing the Communications Content storage location](https://support.zoom.us/hc/en-us/articles/360050781131) for details.
			//
			// Provide abbreviated country codes as the value for this field. See the [Countries abbreviation list](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries) for details.
			AllowedValues *[]string `json:"allowed_values,omitempty"`

			// Value Abbreviated country code.
			Value *string `json:"value,omitempty"`
		} `json:"recording_storage_location,omitempty"`
	} `json:"profile,omitempty"`
	Recording *struct {
		// AskHostToConfirmDisclaimer Ask host to confirm the disclaimer.
		AskHostToConfirmDisclaimer *bool `json:"ask_host_to_confirm_disclaimer,omitempty"`

		// AskParticipantsToConsentDisclaimer This field can be used if `recording_disclaimer` is set to true. This field indicates whether or not you would like to ask participants for consent when a recording starts. The value can be one of the following:
		//
		// * `true`: Ask participants for consent when a recording starts.
		//
		// * `false`: Do not ask participants for consent when a recording starts.
		AskParticipantsToConsentDisclaimer *bool `json:"ask_participants_to_consent_disclaimer,omitempty"`

		// AutoDeleteCmr Auto delete cloud recordings.
		AutoDeleteCmr *bool `json:"auto_delete_cmr,omitempty"`

		// AutoDeleteCmrDays When the `auto_delete_cmr` value is `true`, this value is the number of days before the auto-deletion of cloud recordings:
		// * `30` &mdash; 30 days.
		// * `60` &mdash; 60 days.
		// * `90` &mdash; 90 days.
		// * `120` &mdash; 120 days.
		AutoDeleteCmrDays *int `json:"auto_delete_cmr_days,omitempty"`

		// AutoRecording Automatic recording:
		//  `local` - Record on local.
		//  `cloud` - Record on cloud.
		//  `none` - Disabled.
		AutoRecording *string `json:"auto_recording,omitempty"`

		// CloudRecording Cloud recording.
		CloudRecording *bool `json:"cloud_recording,omitempty"`

		// DisplayParticipantName Display participants' names in the recording.
		DisplayParticipantName *bool `json:"display_participant_name,omitempty"`

		// HostPauseStopRecording Host can pause or stop the auto recording in the cloud.
		HostPauseStopRecording *bool `json:"host_pause_stop_recording,omitempty"`

		// IpAddressAccessControl Setting to allow cloud recording access only from specific IP address ranges.
		IpAddressAccessControl *struct {
			// Enable If set to `true`, the cloud recordings of this account can only be accessed by the IP addresses defined in the `ip_addresses_or_ranges` property.
			//
			Enable *bool `json:"enable,omitempty"`

			// IpAddressesOrRanges IP addresses or ranges that have access to the cloud recordings. Separate multiple IP ranges with comma. Use n.n.n.n, n.n.n.n/n or n.n.n.n - n.n.n.n syntax where n is a number.
			//
			// Example: `46.33.24.184, 48.99.100.2/25` or `200.181.108.17 - 220.181.108.157`
			//
			IpAddressesOrRanges *string `json:"ip_addresses_or_ranges,omitempty"`
		} `json:"ip_address_access_control,omitempty"`

		// LocalRecording Local recording.
		LocalRecording *bool `json:"local_recording,omitempty"`

		// OptimizeRecordingFor3rdPartyVideoEditor Optimize recordings for a 3rd party video editor. This may increase the file size and the time it takes to generate recording files.
		OptimizeRecordingFor3rdPartyVideoEditor *bool `json:"optimize_recording_for_3rd_party_video_editor,omitempty"`

		// RecordAudioFile Record one audio file for all participants.
		RecordAudioFile *bool `json:"record_audio_file,omitempty"`

		// RecordFilesSeparately The account's [**Record active speaker, gallery view and shared screen separately**](https://support.zoom.us/hc/en-us/articles/360060316092-Changing-basic-and-advanced-cloud-recording-settings#h_01F4CYJTCTXNS2MXH00W9EFG6R) settings.
		RecordFilesSeparately *struct {
			// ActiveSpeaker Record the active speaker only.
			ActiveSpeaker *bool `json:"active_speaker,omitempty"`

			// GalleryView Record the gallery view only.
			GalleryView *bool `json:"gallery_view,omitempty"`

			// SharedScreen Record the shared screen only.
			SharedScreen *bool `json:"shared_screen,omitempty"`
		} `json:"record_files_separately,omitempty"`

		// RecordGalleryView Record the gallery view.
		RecordGalleryView *bool `json:"record_gallery_view,omitempty"`

		// RecordSpeakerView Record the active speaker view.
		RecordSpeakerView *bool `json:"record_speaker_view,omitempty"`

		// RecordingAudioTranscript Audio transcript.
		RecordingAudioTranscript *bool `json:"recording_audio_transcript,omitempty"`

		// RecordingDisclaimer Show a disclaimer to participants before a recording starts
		RecordingDisclaimer *bool `json:"recording_disclaimer,omitempty"`

		// RecordingHighlight Enable the [recording highlights](https://support.zoom.us/hc/en-us/articles/360060802432) feature.
		// Deprecated:
		RecordingHighlight *bool `json:"recording_highlight,omitempty"`

		// RecordingPasswordRequirement This object represents the minimum passcode requirements set for recordings via Account Recording Settings.
		RecordingPasswordRequirement *struct {
			// HaveLetter Passcode must contain at least one alphabetical letter (a, b, c..).
			HaveLetter *bool `json:"have_letter,omitempty"`

			// HaveNumber Passcode must contain at least one number(1, 2, 3..).
			HaveNumber *bool `json:"have_number,omitempty"`

			// HaveSpecialCharacter Passcode must contain at least one special character(!, @, #..).
			HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`

			// Length Minimum required length for the passcode.
			Length *int `json:"length,omitempty"`

			// OnlyAllowNumeric Passcode must contain only numeric characters.
			OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`
		} `json:"recording_password_requirement,omitempty"`

		// RecordingThumbnails Record thumbnails of the presenter when they are sharing their screen.
		RecordingThumbnails *bool `json:"recording_thumbnails,omitempty"`

		// SaveChatText Save chat text from the meeting.
		SaveChatText *bool `json:"save_chat_text,omitempty"`

		// SaveCloseCaption Save [closed captions](https://support.zoom.us/hc/en-us/articles/207279736) as a VTT (Video Track Text) file.
		SaveCloseCaption *bool `json:"save_close_caption,omitempty"`

		// SavePanelistChat Save panelist chat to the recording. This setting saves messages sent by panelists during a webinar to either all panelists or all panelists and attendees to the recording.
		SavePanelistChat *bool `json:"save_panelist_chat,omitempty"`

		// SavePollResults Save poll results shared during the meeting or webinar. This also includes poll results shared during the meeting or webinar.
		SavePollResults *bool `json:"save_poll_results,omitempty"`

		// ShowTimestamp Show timestamp on video.
		ShowTimestamp *bool `json:"show_timestamp,omitempty"`

		// SmartRecording By selecting this option, your recording will have meeting smart chapters, and next steps. You are directing Zoom to access, process, and use your account's recording data for the purpose of analysis and insights.
		SmartRecording *struct {
			// CreateNextSteps By selecting this option, there will be a summary of actions to take after the recorded meeting.
			CreateNextSteps *bool `json:"create_next_steps,omitempty"`

			// CreateRecordingHighlights By selecting this option, meeting details in the audio transcript will be highlighted. Hosts can modify highlighted sections and generate a video summary (highlighted sections may have a 3-second offset) based on these sections. The summary is for informational purposes only and may not be complete.
			CreateRecordingHighlights *bool `json:"create_recording_highlights,omitempty"`

			// CreateSmartChapters By selecting this option, your recording will have chapters with overview. Hosts can edit the chapters.
			CreateSmartChapters *bool `json:"create_smart_chapters,omitempty"`
		} `json:"smart_recording,omitempty"`
	} `json:"recording,omitempty"`
	ScheduleMeeting *struct {
		// AudioType Determine how participants can join the audio portion of the meeting:
		//  `both` - Telephony and VoIP.
		//  `telephony` - Audio PSTN telephony only.
		//  `voip` - VoIP only.
		//  `thirdParty` - Third party audio conference.
		AudioType *string `json:"audio_type,omitempty"`

		// DefaultPasswordForScheduledMeetings Passcode for already scheduled meetings
		DefaultPasswordForScheduledMeetings *string `json:"default_password_for_scheduled_meetings,omitempty"`

		// EmbedPasswordInJoinLink Encrypt the meeting passcode and include in the join meeting link to allow participants to join with just one click without having to enter the passcode.
		//
		EmbedPasswordInJoinLink *bool `json:"embed_password_in_join_link,omitempty"`

		// ForcePmiJbhPassword Require a passcode for personal meetings if attendees can join before host.
		ForcePmiJbhPassword *bool `json:"force_pmi_jbh_password,omitempty"`

		// HostVideo Start meetings with host video on.
		HostVideo *bool `json:"host_video,omitempty"`

		// JoinBeforeHost Join the meeting before host arrives.
		JoinBeforeHost *bool `json:"join_before_host,omitempty"`

		// MeetingPasswordRequirement Account wide meeting/webinar [passcode requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
		MeetingPasswordRequirement *struct {
			// ConsecutiveCharactersLength
			// Specify the max length of consecutive characters(abcde...) that can be used in a password.
			// If you set the value of this field to `0`, no restriction will be applied on consecutive characters.
			//
			// If you would like to set this restriction, you can specify a number between 4 and 8 that define the maximum allowed length for consecutive characters in a password.
			//
			// The max allowed length will be `n-1` where `n` refers to the value you provide for this field.  For instance, if you provide `4` as the value, there can only be a maximum of `3` consecutive characters in a password(example: abc1x@8fdh).
			ConsecutiveCharactersLength *int `json:"consecutive_characters_length,omitempty"`

			// HaveLetter Passcode must contain at least 1 letter (such as a,b,c...).
			HaveLetter *bool `json:"have_letter,omitempty"`

			// HaveNumber Passcode must contain at least 1 number (such as 1,2,3...).
			HaveNumber *bool `json:"have_number,omitempty"`

			// HaveSpecialCharacter Passcode must have at least 1 special character (!,@,#...).
			HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`

			// HaveUpperAndLowerCharacters Passcode must include both uppercase and lowercase characters.
			HaveUpperAndLowerCharacters *bool `json:"have_upper_and_lower_characters,omitempty"`

			// Length The minimum length that the meeting or webinar passcode must have.
			Length *int `json:"length,omitempty"`

			// OnlyAllowNumeric Passcode must only contain numbers and no other characters.
			OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`

			// WeakEnhanceDetection Inform users if the provided passcode is weak.
			WeakEnhanceDetection *bool `json:"weak_enhance_detection,omitempty"`
		} `json:"meeting_password_requirement,omitempty"`

		// ParticipantsVideo Start meetings with participants video on.
		ParticipantsVideo *bool `json:"participants_video,omitempty"`

		// PersonalMeeting Personal Meeting Setting.
		//
		//
		// `true`: Indicates that the **&quot;Enable [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi)&quot;** setting is turned on. Users can choose to use a PMI for their meetings.
		//
		//
		// `false`: Indicates that the **&quot;Enable Personal Meeting ID&quot;** setting is [turned off](https://support.zoom.us/hc/en-us/articles/201362843-Personal-meeting-ID-PMI-and-personal-link#h_aa0335c8-3b06-41bc-bc1f-a8b84ef17f2a). If this setting is disabled (`false`), meetings that were scheduled with a PMI will be invalid. Scheduled meetings must be manually updated.
		// For Zoom Phone only: If a user has been assigned a desk phone, **&quot;Elevate to Zoom Meeting&quot;** on desk phone will be disabled.
		//
		//
		PersonalMeeting *bool `json:"personal_meeting,omitempty"`

		// PmiPassword PMI passcode
		PmiPassword *string `json:"pmi_password,omitempty"`

		// PstnPasswordProtected Generate and require passcode for participants joining by phone.
		PstnPasswordProtected *bool `json:"pstn_password_protected,omitempty"`

		// RequirePasswordForInstantMeetings Require a passcode for instant meetings. If you use a PMI for your instant meetings, this option will be disabled. This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
		RequirePasswordForInstantMeetings *bool `json:"require_password_for_instant_meetings,omitempty"`

		// RequirePasswordForPmiMeetings Require a passcode for Personal Meeting ID (PMI). This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
		RequirePasswordForPmiMeetings *string `json:"require_password_for_pmi_meetings,omitempty"`

		// RequirePasswordForScheduledMeetings Require a passcode for meetings which have already been scheduled
		RequirePasswordForScheduledMeetings *bool `json:"require_password_for_scheduled_meetings,omitempty"`

		// RequirePasswordForSchedulingNewMeetings Require a passcode when scheduling new meetings.This setting is always enabled for free accounts and Pro accounts with a single host and cannot be modified for these accounts.
		RequirePasswordForSchedulingNewMeetings *bool `json:"require_password_for_scheduling_new_meetings,omitempty"`

		// UsePmiForInstantMeetings Use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi) when starting an instant meeting.
		UsePmiForInstantMeetings *bool `json:"use_pmi_for_instant_meetings,omitempty"`

		// UsePmiForScheduledMeetings Use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi) when scheduling a meeting.
		UsePmiForScheduledMeetings *bool `json:"use_pmi_for_scheduled_meetings,omitempty"`
	} `json:"schedule_meeting,omitempty"`
	Telephony *struct {
		// AudioConferenceInfo Third party audio conference info.
		AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

		// ShowInternationalNumbersLink Show the international numbers link on the invitation email.
		ShowInternationalNumbersLink *bool `json:"show_international_numbers_link,omitempty"`

		// TelephonyRegions Indicates where most of the participants call into or call from during a meeting.
		TelephonyRegions *struct {
			// SelectionValues The account's selected telephony regions that indicate where most participants call into or call from during a meeting.
			SelectionValues *string `json:"selection_values,omitempty"`
		} `json:"telephony_regions,omitempty"`

		// ThirdPartyAudio Third party audio conference.
		ThirdPartyAudio *bool `json:"third_party_audio,omitempty"`
	} `json:"telephony,omitempty"`

	// Tsp Account Settings: TSP.
	Tsp *struct {
		// CallOut Call Out
		CallOut *bool `json:"call_out,omitempty"`

		// CallOutCountries Call Out Countries/Regions
		CallOutCountries *[]interface{} `json:"call_out_countries,omitempty"`

		// ShowInternationalNumbersLink Show the international numbers link on the invitation email.
		ShowInternationalNumbersLink *bool `json:"show_international_numbers_link,omitempty"`
	} `json:"tsp,omitempty"`
}

// UserSettingsUpdateJSONBody1 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateJSONBody1 struct {
	union json.RawMessage
}

// UserSettingsUpdateJSONBody2 defines parameters for UserSettingsUpdate.
type UserSettingsUpdateJSONBody2 struct {
	MeetingSecurity *struct {
		// AutoSecurity Whether to require that all meetings are secured with at least one security option.
		//
		//  This setting can only be disabled by Enterprise, ISV, Business (with more than 100 licenses), and Education accounts.
		AutoSecurity *bool `json:"auto_security,omitempty"`

		// BlockUserDomain Whether to block users in specific domains from joining meetings and webinars.
		BlockUserDomain *bool `json:"block_user_domain,omitempty"`

		// BlockUserDomainList The domain to block, up to 20 domains. For example, the `*.example.com` domain.
		BlockUserDomainList *[]string `json:"block_user_domain_list,omitempty"`

		// EmbedPasswordInJoinLink Whether the meeting password will be encrypted and included in the invitation link. The provided link will allow participants to join the meeting without having to enter the password.
		EmbedPasswordInJoinLink *bool `json:"embed_password_in_join_link,omitempty"`

		// EncryptionType The type of encryption to use when starting a meeting:
		// * `enhanced_encryption` &mdash; Use enhanced encryption. Encryption data is stored in the cloud.
		// * `e2ee` &mdash; End-to-end encryption. The encryption key is stored on the local device and cannot be obtained by anyone else. Enabling E2EE also [**disables** certain features](https://support.zoom.us/hc/en-us/articles/360048660871), such as cloud recording, live streaming, and allowing participants to join before the host.
		EncryptionType *string `json:"encryption_type,omitempty"`

		// EndToEndEncryptedMeetings Whether to enable end-to-end encryption for meetings. If enabled, you can specify the type of encryption in the `encryption_type` field.
		EndToEndEncryptedMeetings *bool `json:"end_to_end_encrypted_meetings,omitempty"`

		// MeetingPassword Whether all instant and scheduled meetings that users can join via client or Zoom Rooms systems are password-protected. [Personal Meeting ID (PMI)](https://support.zoom.us/hc/en-us/articles/203276937) meetings are **not** included in this setting.
		MeetingPassword *bool `json:"meeting_password,omitempty"`

		// MeetingPasswordRequirement Information about the meeting and webinar [password requirements](https://support.zoom.us/hc/en-us/articles/360033559832-Meeting-and-webinar-passwords#h_a427384b-e383-4f80-864d-794bf0a37604).
		MeetingPasswordRequirement *struct {
			// ConsecutiveCharactersLength The maximum length of consecutive characters (for example, `abcdef`) allowed in a password:
			// * `4` through `8` &mdash; The maximum consecutive characters length. The length is `n` minus `1`, where `n` is the provided value. For example, if you provide the `4` value, there can only be a maximum of `3` consecutive characters in a password (for example, `abc1x@8fdh`).
			// * `0` &mdash; Do not apply a consecutive character restriction.
			ConsecutiveCharactersLength *int `json:"consecutive_characters_length,omitempty"`

			// HaveLetter Whether the password must contain at least one letter character.
			HaveLetter *bool `json:"have_letter,omitempty"`

			// HaveNumber Whether the password must contain at least one numeric character.
			HaveNumber *bool `json:"have_number,omitempty"`

			// HaveSpecialCharacter Whether the password must contain at least one special character. For example, `!`, `@`, and/or `#` characters.
			HaveSpecialCharacter *bool `json:"have_special_character,omitempty"`

			// HaveUpperAndLowerCharacters Whether the password must include uppercase and lowercase characters.
			HaveUpperAndLowerCharacters *bool `json:"have_upper_and_lower_characters,omitempty"`

			// Length The password's minimum length.
			Length *int `json:"length,omitempty"`

			// OnlyAllowNumeric Whether the password must contain **only** numeric characters.
			OnlyAllowNumeric *bool `json:"only_allow_numeric,omitempty"`

			// WeakEnhanceDetection Whether users will be informed when the provided password is weak.
			WeakEnhanceDetection *bool `json:"weak_enhance_detection,omitempty"`
		} `json:"meeting_password_requirement,omitempty"`

		// OnlyAuthenticatedCanJoinFromWebclient Whether to specify that only authenticated users can join the meeting from the web client.
		OnlyAuthenticatedCanJoinFromWebclient *bool `json:"only_authenticated_can_join_from_webclient,omitempty"`

		// PhonePassword Whether to require a password for participants joining by phone.
		//
		//  If enabled and the meeting is password-protected, a numeric password is required for participants to join by phone. For meetings with alphanumeric passwords, a numeric password will be generated.
		PhonePassword *bool `json:"phone_password,omitempty"`

		// PmiPassword Whether all Personal Meeting ID (PMI) meetings that users can join via client or Zoom Rooms systems are password-protected.
		PmiPassword *bool `json:"pmi_password,omitempty"`

		// RequirePasswordForScheduledMeeting Whether to require a password for meetings that have already been scheduled.
		RequirePasswordForScheduledMeeting *bool `json:"require_password_for_scheduled_meeting,omitempty"`

		// RequirePasswordForScheduledWebinar Whether to require a password for webinars that have already been scheduled.
		RequirePasswordForScheduledWebinar *bool `json:"require_password_for_scheduled_webinar,omitempty"`

		// WaitingRoom Whether participants are placed in the [**Waiting Room**](https://support.zoom.us/hc/en-us/articles/115000332726-Waiting-Room) when they join a meeting.
		//
		//  If the **Waiting Room** feature is enabled, the [**Allow participants to join before host**](https://support.zoom.us/hc/en-us/articles/202828525-Allow-participants-to-join-before-host) setting is automatically disabled.
		WaitingRoom *bool `json:"waiting_room,omitempty"`

		// WaitingRoomSettings Information about the Waiting Room settings.
		WaitingRoomSettings *struct {
			// ParticipantsToPlaceInWaitingRoom The type of participants to be admitted to the Waiting Room:
			// * `0` &mdash; All attendees.
			// * `1` &mdash; Users who are not in your account.
			// * `2` &mdash; Users who are not in your account and are not part of your [allowed domains list](https://support.zoom.us/hc/en-us/articles/360037117472-Configuring-authentication-profiles#h_e3cf0d5f-eec7-4c2a-ad29-ef2a5079a7da).
			ParticipantsToPlaceInWaitingRoom *int `json:"participants_to_place_in_waiting_room,omitempty"`

			// UsersWhoCanAdmitParticipantsFromWaitingRoom The users who can admit participants from the Waiting Room:
			// * `0` &mdash; Host and co-hosts only.
			// * `1` &mdash; Host, co-hosts, and anyone who bypassed the Waiting Room if the host and co-hosts are not present.
			UsersWhoCanAdmitParticipantsFromWaitingRoom *int `json:"users_who_can_admit_participants_from_waiting_room,omitempty"`

			// WhitelistedDomainsForWaitingRoom If the `participants_to_place_in_waiting_room` field is `2`, a comma-separated list of the domains that can bypass the Waiting Room (`&quot;example.com,example2.com&quot;`).
			WhitelistedDomainsForWaitingRoom *string `json:"whitelisted_domains_for_waiting_room,omitempty"`
		} `json:"waiting_room_settings,omitempty"`

		// WebinarPassword Whether to generate a password when scheduling webinars. Participants must use the generated password to join the scheduled webinar.
		WebinarPassword *bool `json:"webinar_password,omitempty"`
	} `json:"meeting_security,omitempty"`
}

// DelUserVBParams defines parameters for DelUserVB.
type DelUserVBParams struct {
	// FileIds A comma-separated list of the Virtual Background file IDs to delete.
	FileIds *string `form:"file_ids,omitempty" json:"file_ids,omitempty"`
}

// UploadVBuserMultipartBody defines parameters for UploadVBuser.
type UploadVBuserMultipartBody struct {
	// File The Virtual Background's file path.
	File *string `json:"file,omitempty"`
}

// UserStatusJSONBody defines parameters for UserStatus.
type UserStatusJSONBody struct {
	// Action The action types:
	//  `activate` - Activate a deactivated user.
	//  `deactivate` - Deactivate a user.
	Action string `json:"action"`
}

// UserStatusParamsUserId0 defines parameters for UserStatus.
type UserStatusParamsUserId0 = string

// UserStatusParamsUserId1 defines parameters for UserStatus.
type UserStatusParamsUserId1 = openapi_types.Email

// UserStatusParamsUserId2 defines parameters for UserStatus.
type UserStatusParamsUserId2 = string

// UserSSOTokenDeleteParamsUserId0 defines parameters for UserSSOTokenDelete.
type UserSSOTokenDeleteParamsUserId0 = string

// UserSSOTokenDeleteParamsUserId1 defines parameters for UserSSOTokenDelete.
type UserSSOTokenDeleteParamsUserId1 = openapi_types.Email

// UserSSOTokenDeleteParamsUserId2 defines parameters for UserSSOTokenDelete.
type UserSSOTokenDeleteParamsUserId2 = string

// UserTokenParams defines parameters for UserToken.
type UserTokenParams struct {
	// Type The user token type:
	// * `zak` &mdash; A Zoom Access Key (ZAK) is used to generate a URL to start meetings. See [Getting a Zoom Access Key (ZAK)](https://marketplace.zoom.us/docs/sdk/native-sdks/auth#generating-zoom-access-token-zak) for details. The ZAK's expiration time is two hours. For API users, the expiration time is 90 days. An API user is a user created via the `custCreate` action in the **[Create users](https://marketplace.zoom.us/docs/api-reference/zoom-api/methods/#operation/userCreate)** API. The maximum length of this value is `512`.
	// * `token` &mdash; **Deprecated.** A Zoom token. This token expires in 14 days. You must make the request again after expiration to receive a new token. This query parameter returns a null value if the user signed in to Zoom via Google or Facebook. The maximum length of this value is `512`.
	//
	//  This value defaults to `token`.
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Ttl The ZAK expiration time to live (TTL). The value of this query parameter denotes the expiry time of the ZAK, in seconds. To update the user's ZAK TTL, use this field with the `zak` value for the `type` query parameter.
	//
	//  This value defaults to `7200` or `7776000` (90 days) for API users. The maximum value is one year.
	Ttl *int `form:"ttl,omitempty" json:"ttl,omitempty"`
}

// UserTokenParamsUserId0 defines parameters for UserToken.
type UserTokenParamsUserId0 = string

// UserTokenParamsUserId1 defines parameters for UserToken.
type UserTokenParamsUserId1 = openapi_types.Email

// UserTokenParamsUserId2 defines parameters for UserToken.
type UserTokenParamsUserId2 = string

// InMeetingControlJSONRequestBody defines body for InMeetingControl for application/json ContentType.
type InMeetingControlJSONRequestBody InMeetingControlJSONBody

// MeetingUpdateJSONRequestBody defines body for MeetingUpdate for application/json ContentType.
type MeetingUpdateJSONRequestBody MeetingUpdateJSONBody

// CreateBatchPollsJSONRequestBody defines body for CreateBatchPolls for application/json ContentType.
type CreateBatchPollsJSONRequestBody CreateBatchPollsJSONBody

// AddBatchRegistrantsJSONRequestBody defines body for AddBatchRegistrants for application/json ContentType.
type AddBatchRegistrantsJSONRequestBody AddBatchRegistrantsJSONBody

// MeetingInviteLinksCreateJSONRequestBody defines body for MeetingInviteLinksCreate for application/json ContentType.
type MeetingInviteLinksCreateJSONRequestBody MeetingInviteLinksCreateJSONBody

// MeetingLiveStreamUpdateJSONRequestBody defines body for MeetingLiveStreamUpdate for application/json ContentType.
type MeetingLiveStreamUpdateJSONRequestBody MeetingLiveStreamUpdateJSONBody

// MeetingLiveStreamStatusUpdateJSONRequestBody defines body for MeetingLiveStreamStatusUpdate for application/json ContentType.
type MeetingLiveStreamStatusUpdateJSONRequestBody MeetingLiveStreamStatusUpdateJSONBody

// MeetingPollCreateJSONRequestBody defines body for MeetingPollCreate for application/json ContentType.
type MeetingPollCreateJSONRequestBody MeetingPollCreateJSONBody

// MeetingPollUpdateJSONRequestBody defines body for MeetingPollUpdate for application/json ContentType.
type MeetingPollUpdateJSONRequestBody MeetingPollUpdateJSONBody

// MeetingRegistrantCreateJSONRequestBody defines body for MeetingRegistrantCreate for application/json ContentType.
type MeetingRegistrantCreateJSONRequestBody MeetingRegistrantCreateJSONBody

// MeetingRegistrantQuestionUpdateJSONRequestBody defines body for MeetingRegistrantQuestionUpdate for application/json ContentType.
type MeetingRegistrantQuestionUpdateJSONRequestBody MeetingRegistrantQuestionUpdateJSONBody

// MeetingRegistrantStatusJSONRequestBody defines body for MeetingRegistrantStatus for application/json ContentType.
type MeetingRegistrantStatusJSONRequestBody MeetingRegistrantStatusJSONBody

// GetSipDialingWithPasscodeJSONRequestBody defines body for GetSipDialingWithPasscode for application/json ContentType.
type GetSipDialingWithPasscodeJSONRequestBody GetSipDialingWithPasscodeJSONBody

// MeetingStatusJSONRequestBody defines body for MeetingStatus for application/json ContentType.
type MeetingStatusJSONRequestBody MeetingStatusJSONBody

// MeetingSurveyUpdateJSONRequestBody defines body for MeetingSurveyUpdate for application/json ContentType.
type MeetingSurveyUpdateJSONRequestBody MeetingSurveyUpdateJSONBody

// UserCreateJSONRequestBody defines body for UserCreate for application/json ContentType.
type UserCreateJSONRequestBody UserCreateJSONBody

// BulkUpdateFeatureJSONRequestBody defines body for BulkUpdateFeature for application/json ContentType.
type BulkUpdateFeatureJSONRequestBody BulkUpdateFeatureJSONBody

// UserUpdateJSONRequestBody defines body for UserUpdate for application/json ContentType.
type UserUpdateJSONRequestBody UserUpdateJSONBody

// SwitchAUsersAccountJSONRequestBody defines body for SwitchAUsersAccount for application/json ContentType.
type SwitchAUsersAccountJSONRequestBody SwitchAUsersAccountJSONBody

// UserAssistantCreateJSONRequestBody defines body for UserAssistantCreate for application/json ContentType.
type UserAssistantCreateJSONRequestBody UserAssistantCreateJSONBody

// UserEmailUpdateJSONRequestBody defines body for UserEmailUpdate for application/json ContentType.
type UserEmailUpdateJSONRequestBody UserEmailUpdateJSONBody

// MeetingTemplateCreateJSONRequestBody defines body for MeetingTemplateCreate for application/json ContentType.
type MeetingTemplateCreateJSONRequestBody MeetingTemplateCreateJSONBody

// MeetingCreateJSONRequestBody defines body for MeetingCreate for application/json ContentType.
type MeetingCreateJSONRequestBody MeetingCreateJSONBody

// UserPasswordJSONRequestBody defines body for UserPassword for application/json ContentType.
type UserPasswordJSONRequestBody UserPasswordJSONBody

// UserPictureMultipartRequestBody defines body for UserPicture for multipart/form-data ContentType.
type UserPictureMultipartRequestBody UserPictureMultipartBody

// UpdatePresenceStatusJSONRequestBody defines body for UpdatePresenceStatus for application/json ContentType.
type UpdatePresenceStatusJSONRequestBody UpdatePresenceStatusJSONBody

// UserSettingsUpdateJSONRequestBody defines body for UserSettingsUpdate for application/json ContentType.
type UserSettingsUpdateJSONRequestBody UserSettingsUpdateJSONBody

// UploadVBuserMultipartRequestBody defines body for UploadVBuser for multipart/form-data ContentType.
type UploadVBuserMultipartRequestBody UploadVBuserMultipartBody

// UserStatusJSONRequestBody defines body for UserStatus for application/json ContentType.
type UserStatusJSONRequestBody UserStatusJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// DeleteMeetingChatMessageById request
	DeleteMeetingChatMessageById(ctx context.Context, meetingId int64, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// InMeetingControl request with any body
	InMeetingControlWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	InMeetingControl(ctx context.Context, meetingId string, body InMeetingControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingDelete request
	MeetingDelete(ctx context.Context, meetingId int64, params *MeetingDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Meeting request
	Meeting(ctx context.Context, meetingId int64, params *MeetingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingUpdate request with any body
	MeetingUpdateWithBody(ctx context.Context, meetingId int64, params *MeetingUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingUpdate(ctx context.Context, meetingId int64, params *MeetingUpdateParams, body MeetingUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBatchPolls request with any body
	CreateBatchPollsWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateBatchPolls(ctx context.Context, meetingId string, body CreateBatchPollsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddBatchRegistrants request with any body
	AddBatchRegistrantsWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddBatchRegistrants(ctx context.Context, meetingId string, body AddBatchRegistrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingInvitation request
	MeetingInvitation(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingInviteLinksCreate request with any body
	MeetingInviteLinksCreateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingInviteLinksCreate(ctx context.Context, meetingId int64, body MeetingInviteLinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingLiveStreamingJoinToken request
	MeetingLiveStreamingJoinToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingLocalArchivingArchiveToken request
	MeetingLocalArchivingArchiveToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingLocalRecordingJoinToken request
	MeetingLocalRecordingJoinToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeetingLiveStreamDetails request
	GetMeetingLiveStreamDetails(ctx context.Context, meetingId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingLiveStreamUpdate request with any body
	MeetingLiveStreamUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingLiveStreamUpdate(ctx context.Context, meetingId int64, body MeetingLiveStreamUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingLiveStreamStatusUpdate request with any body
	MeetingLiveStreamStatusUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingLiveStreamStatusUpdate(ctx context.Context, meetingId int64, body MeetingLiveStreamStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingPolls request
	MeetingPolls(ctx context.Context, meetingId int64, params *MeetingPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingPollCreate request with any body
	MeetingPollCreateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingPollCreate(ctx context.Context, meetingId int64, body MeetingPollCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingPollDelete request
	MeetingPollDelete(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingPollGet request
	MeetingPollGet(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingPollUpdate request with any body
	MeetingPollUpdateWithBody(ctx context.Context, meetingId int64, pollId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingPollUpdate(ctx context.Context, meetingId int64, pollId string, body MeetingPollUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrants request
	MeetingRegistrants(ctx context.Context, meetingId int64, params *MeetingRegistrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrantCreate request with any body
	MeetingRegistrantCreateWithBody(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingRegistrantCreate(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, body MeetingRegistrantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrantsQuestionsGet request
	MeetingRegistrantsQuestionsGet(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrantQuestionUpdate request with any body
	MeetingRegistrantQuestionUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingRegistrantQuestionUpdate(ctx context.Context, meetingId int64, body MeetingRegistrantQuestionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrantStatus request with any body
	MeetingRegistrantStatusWithBody(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingRegistrantStatus(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, body MeetingRegistrantStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Meetingregistrantdelete request
	Meetingregistrantdelete(ctx context.Context, meetingId int, registrantId string, params *MeetingregistrantdeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingRegistrantGet request
	MeetingRegistrantGet(ctx context.Context, meetingId int64, registrantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSipDialingWithPasscode request with any body
	GetSipDialingWithPasscodeWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetSipDialingWithPasscode(ctx context.Context, meetingId int64, body GetSipDialingWithPasscodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingStatus request with any body
	MeetingStatusWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingStatus(ctx context.Context, meetingId int64, body MeetingStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingSurveyDelete request
	MeetingSurveyDelete(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingSurveyGet request
	MeetingSurveyGet(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingSurveyUpdate request with any body
	MeetingSurveyUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingSurveyUpdate(ctx context.Context, meetingId int64, body MeetingSurveyUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingToken request
	MeetingToken(ctx context.Context, meetingId int64, params *MeetingTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PastMeetingDetails request
	PastMeetingDetails(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PastMeetings request
	PastMeetings(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PastMeetingParticipants request
	PastMeetingParticipants(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, params *PastMeetingParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPastMeetingPolls request
	ListPastMeetingPolls(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPastMeetingQA request
	ListPastMeetingQA(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Users request
	Users(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserCreate request with any body
	UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserEmail request
	UserEmail(ctx context.Context, params *UserEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUpdateFeature request with any body
	BulkUpdateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BulkUpdateFeature(ctx context.Context, body BulkUpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserZak request
	UserZak(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSummary request
	UserSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserVanityName request
	UserVanityName(ctx context.Context, params *UserVanityNameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserDelete request
	UserDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// User request
	User(ctx context.Context, userId string, params *UserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserUpdate request with any body
	UserUpdateWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserUpdate(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserUpdateParams, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SwitchAUsersAccount request with any body
	SwitchAUsersAccountWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SwitchAUsersAccount(ctx context.Context, userId string, body SwitchAUsersAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserAssistantsDelete request
	UserAssistantsDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserAssistants request
	UserAssistants(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserAssistantCreate request with any body
	UserAssistantCreateWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserAssistantCreate(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserAssistantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserAssistantDelete request
	UserAssistantDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCollaborationDevices request
	ListCollaborationDevices(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollaborationDevice request
	GetCollaborationDevice(ctx context.Context, userId struct {
		union json.RawMessage
	}, collaborationDeviceId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserEmailUpdate request with any body
	UserEmailUpdateWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserEmailUpdate(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserEmailUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListMeetingTemplates request
	ListMeetingTemplates(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingTemplateCreate request with any body
	MeetingTemplateCreateWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingTemplateCreate(ctx context.Context, userId string, body MeetingTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Meetings request
	Meetings(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *MeetingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// MeetingCreate request with any body
	MeetingCreateWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	MeetingCreate(ctx context.Context, userId string, body MeetingCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserPassword request with any body
	UserPasswordWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserPassword(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserPermission request
	UserPermission(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserPictureDelete request
	UserPictureDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserPicture request with any body
	UserPictureWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePresenceStatus request with any body
	UpdatePresenceStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePresenceStatus(ctx context.Context, userId string, body UpdatePresenceStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSchedulersDelete request
	UserSchedulersDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSchedulers request
	UserSchedulers(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSchedulerDelete request
	UserSchedulerDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, schedulerId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSettings request
	UserSettings(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSettingsUpdate request with any body
	UserSettingsUpdateWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserSettingsUpdate(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsUpdateParams, body UserSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DelUserVB request
	DelUserVB(ctx context.Context, userId string, params *DelUserVBParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadVBuser request with any body
	UploadVBuserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserStatus request with any body
	UserStatusWithBody(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UserStatus(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserSSOTokenDelete request
	UserSSOTokenDelete(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UserToken request
	UserToken(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) DeleteMeetingChatMessageById(ctx context.Context, meetingId int64, messageId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMeetingChatMessageByIdRequest(c.Server, meetingId, messageId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InMeetingControlWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInMeetingControlRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) InMeetingControl(ctx context.Context, meetingId string, body InMeetingControlJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewInMeetingControlRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingDelete(ctx context.Context, meetingId int64, params *MeetingDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingDeleteRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Meeting(ctx context.Context, meetingId int64, params *MeetingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingUpdateWithBody(ctx context.Context, meetingId int64, params *MeetingUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingUpdateRequestWithBody(c.Server, meetingId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingUpdate(ctx context.Context, meetingId int64, params *MeetingUpdateParams, body MeetingUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingUpdateRequest(c.Server, meetingId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchPollsWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchPollsRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBatchPolls(ctx context.Context, meetingId string, body CreateBatchPollsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBatchPollsRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBatchRegistrantsWithBody(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBatchRegistrantsRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddBatchRegistrants(ctx context.Context, meetingId string, body AddBatchRegistrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddBatchRegistrantsRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingInvitation(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingInvitationRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingInviteLinksCreateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingInviteLinksCreateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingInviteLinksCreate(ctx context.Context, meetingId int64, body MeetingInviteLinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingInviteLinksCreateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLiveStreamingJoinToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLiveStreamingJoinTokenRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLocalArchivingArchiveToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLocalArchivingArchiveTokenRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLocalRecordingJoinToken(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLocalRecordingJoinTokenRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeetingLiveStreamDetails(ctx context.Context, meetingId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeetingLiveStreamDetailsRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLiveStreamUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLiveStreamUpdateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLiveStreamUpdate(ctx context.Context, meetingId int64, body MeetingLiveStreamUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLiveStreamUpdateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLiveStreamStatusUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLiveStreamStatusUpdateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingLiveStreamStatusUpdate(ctx context.Context, meetingId int64, body MeetingLiveStreamStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingLiveStreamStatusUpdateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPolls(ctx context.Context, meetingId int64, params *MeetingPollsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollsRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollCreateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollCreateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollCreate(ctx context.Context, meetingId int64, body MeetingPollCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollCreateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollDelete(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollDeleteRequest(c.Server, meetingId, pollId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollGet(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollGetRequest(c.Server, meetingId, pollId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollUpdateWithBody(ctx context.Context, meetingId int64, pollId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollUpdateRequestWithBody(c.Server, meetingId, pollId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingPollUpdate(ctx context.Context, meetingId int64, pollId string, body MeetingPollUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingPollUpdateRequest(c.Server, meetingId, pollId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrants(ctx context.Context, meetingId int64, params *MeetingRegistrantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantsRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantCreateWithBody(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantCreateRequestWithBody(c.Server, meetingId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantCreate(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, body MeetingRegistrantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantCreateRequest(c.Server, meetingId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantsQuestionsGet(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantsQuestionsGetRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantQuestionUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantQuestionUpdateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantQuestionUpdate(ctx context.Context, meetingId int64, body MeetingRegistrantQuestionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantQuestionUpdateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantStatusWithBody(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantStatusRequestWithBody(c.Server, meetingId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantStatus(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, body MeetingRegistrantStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantStatusRequest(c.Server, meetingId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Meetingregistrantdelete(ctx context.Context, meetingId int, registrantId string, params *MeetingregistrantdeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingregistrantdeleteRequest(c.Server, meetingId, registrantId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingRegistrantGet(ctx context.Context, meetingId int64, registrantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingRegistrantGetRequest(c.Server, meetingId, registrantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSipDialingWithPasscodeWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSipDialingWithPasscodeRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSipDialingWithPasscode(ctx context.Context, meetingId int64, body GetSipDialingWithPasscodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSipDialingWithPasscodeRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingStatusWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingStatusRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingStatus(ctx context.Context, meetingId int64, body MeetingStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingStatusRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingSurveyDelete(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingSurveyDeleteRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingSurveyGet(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingSurveyGetRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingSurveyUpdateWithBody(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingSurveyUpdateRequestWithBody(c.Server, meetingId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingSurveyUpdate(ctx context.Context, meetingId int64, body MeetingSurveyUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingSurveyUpdateRequest(c.Server, meetingId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingToken(ctx context.Context, meetingId int64, params *MeetingTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingTokenRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PastMeetingDetails(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPastMeetingDetailsRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PastMeetings(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPastMeetingsRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PastMeetingParticipants(ctx context.Context, meetingId struct {
	union json.RawMessage
}, params *PastMeetingParticipantsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPastMeetingParticipantsRequest(c.Server, meetingId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPastMeetingPolls(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPastMeetingPollsRequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPastMeetingQA(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPastMeetingQARequest(c.Server, meetingId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Users(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserCreate(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserEmail(ctx context.Context, params *UserEmailParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserEmailRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateFeatureWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateFeatureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUpdateFeature(ctx context.Context, body BulkUpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUpdateFeatureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserZak(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserZakRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSummary(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSummaryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserVanityName(ctx context.Context, params *UserVanityNameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserVanityNameRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserDeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserDeleteRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) User(ctx context.Context, userId string, params *UserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdateWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserUpdate(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserUpdateRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwitchAUsersAccountWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwitchAUsersAccountRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SwitchAUsersAccount(ctx context.Context, userId string, body SwitchAUsersAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSwitchAUsersAccountRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserAssistantsDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserAssistantsDeleteRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserAssistants(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserAssistantsRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserAssistantCreateWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserAssistantCreateRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserAssistantCreate(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserAssistantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserAssistantCreateRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserAssistantDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, assistantId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserAssistantDeleteRequest(c.Server, userId, assistantId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCollaborationDevices(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollaborationDevicesRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollaborationDevice(ctx context.Context, userId struct {
	union json.RawMessage
}, collaborationDeviceId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollaborationDeviceRequest(c.Server, userId, collaborationDeviceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserEmailUpdateWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserEmailUpdateRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserEmailUpdate(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserEmailUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserEmailUpdateRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListMeetingTemplates(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListMeetingTemplatesRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingTemplateCreateWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingTemplateCreateRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingTemplateCreate(ctx context.Context, userId string, body MeetingTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingTemplateCreateRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Meetings(ctx context.Context, userId struct {
	union json.RawMessage
}, params *MeetingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingCreateWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingCreateRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) MeetingCreate(ctx context.Context, userId string, body MeetingCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewMeetingCreateRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPasswordWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPasswordRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPassword(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPasswordRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPermission(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPermissionRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPictureDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPictureDeleteRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserPictureWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserPictureRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePresenceStatusWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePresenceStatusRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePresenceStatus(ctx context.Context, userId string, body UpdatePresenceStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePresenceStatusRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSchedulersDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSchedulersDeleteRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSchedulers(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSchedulersRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSchedulerDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, schedulerId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSchedulerDeleteRequest(c.Server, userId, schedulerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSettings(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSettingsRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSettingsUpdateWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSettingsUpdateRequestWithBody(c.Server, userId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSettingsUpdate(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, body UserSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSettingsUpdateRequest(c.Server, userId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DelUserVB(ctx context.Context, userId string, params *DelUserVBParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDelUserVBRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadVBuserWithBody(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadVBuserRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserStatusWithBody(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserStatusRequestWithBody(c.Server, userId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserStatus(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserStatusRequest(c.Server, userId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserSSOTokenDelete(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserSSOTokenDeleteRequest(c.Server, userId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UserToken(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserTokenParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUserTokenRequest(c.Server, userId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewDeleteMeetingChatMessageByIdRequest generates requests for DeleteMeetingChatMessageById
func NewDeleteMeetingChatMessageByIdRequest(server string, meetingId int64, messageId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "messageId", runtime.ParamLocationPath, messageId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/live_meetings/%s/chat/messages/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInMeetingControlRequest calls the generic InMeetingControl builder with application/json body
func NewInMeetingControlRequest(server string, meetingId string, body InMeetingControlJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewInMeetingControlRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewInMeetingControlRequestWithBody generates requests for InMeetingControl with any type of body
func NewInMeetingControlRequestWithBody(server string, meetingId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/live_meetings/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingDeleteRequest generates requests for MeetingDelete
func NewMeetingDeleteRequest(server string, meetingId int64, params *MeetingDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduleForReminder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "schedule_for_reminder", runtime.ParamLocationQuery, *params.ScheduleForReminder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CancelMeetingReminder != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cancel_meeting_reminder", runtime.ParamLocationQuery, *params.CancelMeetingReminder); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingRequest generates requests for Meeting
func NewMeetingRequest(server string, meetingId int64, params *MeetingParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("SIMPLE", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("FORM", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowPreviousOccurrences != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("FORM", true, "show_previous_occurrences", runtime.ParamLocationQuery, *params.ShowPreviousOccurrences); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingUpdateRequest calls the generic MeetingUpdate builder with application/json body
func NewMeetingUpdateRequest(server string, meetingId int64, params *MeetingUpdateParams, body MeetingUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingUpdateRequestWithBody(server, meetingId, params, "application/json", bodyReader)
}

// NewMeetingUpdateRequestWithBody generates requests for MeetingUpdate with any type of body
func NewMeetingUpdateRequestWithBody(server string, meetingId int64, params *MeetingUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateBatchPollsRequest calls the generic CreateBatchPolls builder with application/json body
func NewCreateBatchPollsRequest(server string, meetingId string, body CreateBatchPollsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateBatchPollsRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewCreateBatchPollsRequestWithBody generates requests for CreateBatchPolls with any type of body
func NewCreateBatchPollsRequestWithBody(server string, meetingId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/batch_polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddBatchRegistrantsRequest calls the generic AddBatchRegistrants builder with application/json body
func NewAddBatchRegistrantsRequest(server string, meetingId string, body AddBatchRegistrantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddBatchRegistrantsRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewAddBatchRegistrantsRequestWithBody generates requests for AddBatchRegistrants with any type of body
func NewAddBatchRegistrantsRequestWithBody(server string, meetingId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/batch_registrants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingInvitationRequest generates requests for MeetingInvitation
func NewMeetingInvitationRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("SIMPLE", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/invitation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingInviteLinksCreateRequest calls the generic MeetingInviteLinksCreate builder with application/json body
func NewMeetingInviteLinksCreateRequest(server string, meetingId int64, body MeetingInviteLinksCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingInviteLinksCreateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingInviteLinksCreateRequestWithBody generates requests for MeetingInviteLinksCreate with any type of body
func NewMeetingInviteLinksCreateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/invite_links", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingLiveStreamingJoinTokenRequest generates requests for MeetingLiveStreamingJoinToken
func NewMeetingLiveStreamingJoinTokenRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/jointoken/live_streaming", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingLocalArchivingArchiveTokenRequest generates requests for MeetingLocalArchivingArchiveToken
func NewMeetingLocalArchivingArchiveTokenRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/jointoken/local_archiving", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingLocalRecordingJoinTokenRequest generates requests for MeetingLocalRecordingJoinToken
func NewMeetingLocalRecordingJoinTokenRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/jointoken/local_recording", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeetingLiveStreamDetailsRequest generates requests for GetMeetingLiveStreamDetails
func NewGetMeetingLiveStreamDetailsRequest(server string, meetingId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/livestream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingLiveStreamUpdateRequest calls the generic MeetingLiveStreamUpdate builder with application/json body
func NewMeetingLiveStreamUpdateRequest(server string, meetingId int64, body MeetingLiveStreamUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingLiveStreamUpdateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingLiveStreamUpdateRequestWithBody generates requests for MeetingLiveStreamUpdate with any type of body
func NewMeetingLiveStreamUpdateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/livestream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingLiveStreamStatusUpdateRequest calls the generic MeetingLiveStreamStatusUpdate builder with application/json body
func NewMeetingLiveStreamStatusUpdateRequest(server string, meetingId int64, body MeetingLiveStreamStatusUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingLiveStreamStatusUpdateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingLiveStreamStatusUpdateRequestWithBody generates requests for MeetingLiveStreamStatusUpdate with any type of body
func NewMeetingLiveStreamStatusUpdateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/livestream/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingPollsRequest generates requests for MeetingPolls
func NewMeetingPollsRequest(server string, meetingId int64, params *MeetingPollsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Anonymous != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "anonymous", runtime.ParamLocationQuery, *params.Anonymous); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingPollCreateRequest calls the generic MeetingPollCreate builder with application/json body
func NewMeetingPollCreateRequest(server string, meetingId int64, body MeetingPollCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingPollCreateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingPollCreateRequestWithBody generates requests for MeetingPollCreate with any type of body
func NewMeetingPollCreateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingPollDeleteRequest generates requests for MeetingPollDelete
func NewMeetingPollDeleteRequest(server string, meetingId int64, pollId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pollId", runtime.ParamLocationPath, pollId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/polls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingPollGetRequest generates requests for MeetingPollGet
func NewMeetingPollGetRequest(server string, meetingId int64, pollId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pollId", runtime.ParamLocationPath, pollId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/polls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingPollUpdateRequest calls the generic MeetingPollUpdate builder with application/json body
func NewMeetingPollUpdateRequest(server string, meetingId int64, pollId string, body MeetingPollUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingPollUpdateRequestWithBody(server, meetingId, pollId, "application/json", bodyReader)
}

// NewMeetingPollUpdateRequestWithBody generates requests for MeetingPollUpdate with any type of body
func NewMeetingPollUpdateRequestWithBody(server string, meetingId int64, pollId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "pollId", runtime.ParamLocationPath, pollId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/polls/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingRegistrantsRequest generates requests for MeetingRegistrants
func NewMeetingRegistrantsRequest(server string, meetingId int64, params *MeetingRegistrantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingRegistrantCreateRequest calls the generic MeetingRegistrantCreate builder with application/json body
func NewMeetingRegistrantCreateRequest(server string, meetingId int64, params *MeetingRegistrantCreateParams, body MeetingRegistrantCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingRegistrantCreateRequestWithBody(server, meetingId, params, "application/json", bodyReader)
}

// NewMeetingRegistrantCreateRequestWithBody generates requests for MeetingRegistrantCreate with any type of body
func NewMeetingRegistrantCreateRequestWithBody(server string, meetingId int64, params *MeetingRegistrantCreateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_ids", runtime.ParamLocationQuery, *params.OccurrenceIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingRegistrantsQuestionsGetRequest generates requests for MeetingRegistrantsQuestionsGet
func NewMeetingRegistrantsQuestionsGetRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants/questions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingRegistrantQuestionUpdateRequest calls the generic MeetingRegistrantQuestionUpdate builder with application/json body
func NewMeetingRegistrantQuestionUpdateRequest(server string, meetingId int64, body MeetingRegistrantQuestionUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingRegistrantQuestionUpdateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingRegistrantQuestionUpdateRequestWithBody generates requests for MeetingRegistrantQuestionUpdate with any type of body
func NewMeetingRegistrantQuestionUpdateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants/questions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingRegistrantStatusRequest calls the generic MeetingRegistrantStatus builder with application/json body
func NewMeetingRegistrantStatusRequest(server string, meetingId int64, params *MeetingRegistrantStatusParams, body MeetingRegistrantStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingRegistrantStatusRequestWithBody(server, meetingId, params, "application/json", bodyReader)
}

// NewMeetingRegistrantStatusRequestWithBody generates requests for MeetingRegistrantStatus with any type of body
func NewMeetingRegistrantStatusRequestWithBody(server string, meetingId int64, params *MeetingRegistrantStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingregistrantdeleteRequest generates requests for Meetingregistrantdelete
func NewMeetingregistrantdeleteRequest(server string, meetingId int, registrantId string, params *MeetingregistrantdeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "registrantId", runtime.ParamLocationPath, registrantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.OccurrenceId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "occurrence_id", runtime.ParamLocationQuery, *params.OccurrenceId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingRegistrantGetRequest generates requests for MeetingRegistrantGet
func NewMeetingRegistrantGetRequest(server string, meetingId int64, registrantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "registrantId", runtime.ParamLocationPath, registrantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/registrants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSipDialingWithPasscodeRequest calls the generic GetSipDialingWithPasscode builder with application/json body
func NewGetSipDialingWithPasscodeRequest(server string, meetingId int64, body GetSipDialingWithPasscodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetSipDialingWithPasscodeRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewGetSipDialingWithPasscodeRequestWithBody generates requests for GetSipDialingWithPasscode with any type of body
func NewGetSipDialingWithPasscodeRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/sip_dialing", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingStatusRequest calls the generic MeetingStatus builder with application/json body
func NewMeetingStatusRequest(server string, meetingId int64, body MeetingStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingStatusRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingStatusRequestWithBody generates requests for MeetingStatus with any type of body
func NewMeetingStatusRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingSurveyDeleteRequest generates requests for MeetingSurveyDelete
func NewMeetingSurveyDeleteRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/survey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingSurveyGetRequest generates requests for MeetingSurveyGet
func NewMeetingSurveyGetRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/survey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingSurveyUpdateRequest calls the generic MeetingSurveyUpdate builder with application/json body
func NewMeetingSurveyUpdateRequest(server string, meetingId int64, body MeetingSurveyUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingSurveyUpdateRequestWithBody(server, meetingId, "application/json", bodyReader)
}

// NewMeetingSurveyUpdateRequestWithBody generates requests for MeetingSurveyUpdate with any type of body
func NewMeetingSurveyUpdateRequestWithBody(server string, meetingId int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/survey", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingTokenRequest generates requests for MeetingToken
func NewMeetingTokenRequest(server string, meetingId int64, params *MeetingTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/meetings/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPastMeetingDetailsRequest generates requests for PastMeetingDetails
func NewPastMeetingDetailsRequest(server string, meetingId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/past_meetings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPastMeetingsRequest generates requests for PastMeetings
func NewPastMeetingsRequest(server string, meetingId int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/past_meetings/%s/instances", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPastMeetingParticipantsRequest generates requests for PastMeetingParticipants
func NewPastMeetingParticipantsRequest(server string, meetingId struct {
	union json.RawMessage
}, params *PastMeetingParticipantsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/past_meetings/%s/participants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPastMeetingPollsRequest generates requests for ListPastMeetingPolls
func NewListPastMeetingPollsRequest(server string, meetingId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/past_meetings/%s/polls", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPastMeetingQARequest generates requests for ListPastMeetingQA
func NewListPastMeetingQARequest(server string, meetingId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "meetingId", runtime.ParamLocationPath, meetingId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/past_meetings/%s/qa", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUsersRequest generates requests for Users
func NewUsersRequest(server string, params *UsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RoleId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role_id", runtime.ParamLocationQuery, *params.RoleId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_fields", runtime.ParamLocationQuery, *params.IncludeFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserCreateRequest calls the generic UserCreate builder with application/json body
func NewUserCreateRequest(server string, body UserCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewUserCreateRequestWithBody generates requests for UserCreate with any type of body
func NewUserCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserEmailRequest generates requests for UserEmail
func NewUserEmailRequest(server string, params *UserEmailParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "email", runtime.ParamLocationQuery, params.Email); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUpdateFeatureRequest calls the generic BulkUpdateFeature builder with application/json body
func NewBulkUpdateFeatureRequest(server string, body BulkUpdateFeatureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBulkUpdateFeatureRequestWithBody(server, "application/json", bodyReader)
}

// NewBulkUpdateFeatureRequestWithBody generates requests for BulkUpdateFeature with any type of body
func NewBulkUpdateFeatureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/features")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserZakRequest generates requests for UserZak
func NewUserZakRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/me/zak")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSummaryRequest generates requests for UserSummary
func NewUserSummaryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/summary")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserVanityNameRequest generates requests for UserVanityName
func NewUserVanityNameRequest(server string, params *UserVanityNameParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/vanity_name")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "vanity_name", runtime.ParamLocationQuery, params.VanityName); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserDeleteRequest generates requests for UserDelete
func NewUserDeleteRequest(server string, userId struct {
	union json.RawMessage
}, params *UserDeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Action != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, *params.Action); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EncryptedEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "encrypted_email", runtime.ParamLocationQuery, *params.EncryptedEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfer_email", runtime.ParamLocationQuery, *params.TransferEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferMeeting != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfer_meeting", runtime.ParamLocationQuery, *params.TransferMeeting); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferWebinar != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfer_webinar", runtime.ParamLocationQuery, *params.TransferWebinar); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferRecording != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfer_recording", runtime.ParamLocationQuery, *params.TransferRecording); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferWhiteboard != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfer_whiteboard", runtime.ParamLocationQuery, *params.TransferWhiteboard); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserRequest generates requests for User
func NewUserRequest(server string, userId string, params *UserParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("SIMPLE", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoginType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("FORM", true, "login_type", runtime.ParamLocationQuery, *params.LoginType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EncryptedEmail != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("FORM", true, "encrypted_email", runtime.ParamLocationQuery, *params.EncryptedEmail); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SearchByUniqueId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("FORM", true, "search_by_unique_id", runtime.ParamLocationQuery, *params.SearchByUniqueId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserUpdateRequest calls the generic UserUpdate builder with application/json body
func NewUserUpdateRequest(server string, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, body UserUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserUpdateRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewUserUpdateRequestWithBody generates requests for UserUpdate with any type of body
func NewUserUpdateRequestWithBody(server string, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoginType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_type", runtime.ParamLocationQuery, *params.LoginType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.RemoveTspCredentials != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remove_tsp_credentials", runtime.ParamLocationQuery, *params.RemoveTspCredentials); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSwitchAUsersAccountRequest calls the generic SwitchAUsersAccount builder with application/json body
func NewSwitchAUsersAccountRequest(server string, userId string, body SwitchAUsersAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSwitchAUsersAccountRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewSwitchAUsersAccountRequestWithBody generates requests for SwitchAUsersAccount with any type of body
func NewSwitchAUsersAccountRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/account", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserAssistantsDeleteRequest generates requests for UserAssistantsDelete
func NewUserAssistantsDeleteRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/assistants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserAssistantsRequest generates requests for UserAssistants
func NewUserAssistantsRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/assistants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserAssistantCreateRequest calls the generic UserAssistantCreate builder with application/json body
func NewUserAssistantCreateRequest(server string, userId struct {
	union json.RawMessage
}, body UserAssistantCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserAssistantCreateRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUserAssistantCreateRequestWithBody generates requests for UserAssistantCreate with any type of body
func NewUserAssistantCreateRequestWithBody(server string, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/assistants", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserAssistantDeleteRequest generates requests for UserAssistantDelete
func NewUserAssistantDeleteRequest(server string, userId struct {
	union json.RawMessage
}, assistantId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "assistantId", runtime.ParamLocationPath, assistantId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/assistants/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCollaborationDevicesRequest generates requests for ListCollaborationDevices
func NewListCollaborationDevicesRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/collaboration_devices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollaborationDeviceRequest generates requests for GetCollaborationDevice
func NewGetCollaborationDeviceRequest(server string, userId struct {
	union json.RawMessage
}, collaborationDeviceId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "collaborationDeviceId", runtime.ParamLocationPath, collaborationDeviceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/collaboration_devices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserEmailUpdateRequest calls the generic UserEmailUpdate builder with application/json body
func NewUserEmailUpdateRequest(server string, userId struct {
	union json.RawMessage
}, body UserEmailUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserEmailUpdateRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUserEmailUpdateRequestWithBody generates requests for UserEmailUpdate with any type of body
func NewUserEmailUpdateRequestWithBody(server string, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/email", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListMeetingTemplatesRequest generates requests for ListMeetingTemplates
func NewListMeetingTemplatesRequest(server string, userId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/meeting_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingTemplateCreateRequest calls the generic MeetingTemplateCreate builder with application/json body
func NewMeetingTemplateCreateRequest(server string, userId string, body MeetingTemplateCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingTemplateCreateRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewMeetingTemplateCreateRequestWithBody generates requests for MeetingTemplateCreate with any type of body
func NewMeetingTemplateCreateRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/meeting_templates", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewMeetingsRequest generates requests for Meetings
func NewMeetingsRequest(server string, userId struct {
	union json.RawMessage
}, params *MeetingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/meetings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageSize != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_size", runtime.ParamLocationQuery, *params.PageSize); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.NextPageToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page_token", runtime.ParamLocationQuery, *params.NextPageToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageNumber != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page_number", runtime.ParamLocationQuery, *params.PageNumber); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewMeetingCreateRequest calls the generic MeetingCreate builder with application/json body
func NewMeetingCreateRequest(server string, userId string, body MeetingCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewMeetingCreateRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewMeetingCreateRequestWithBody generates requests for MeetingCreate with any type of body
func NewMeetingCreateRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("SIMPLE", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/meetings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserPasswordRequest calls the generic UserPassword builder with application/json body
func NewUserPasswordRequest(server string, userId struct {
	union json.RawMessage
}, body UserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserPasswordRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUserPasswordRequestWithBody generates requests for UserPassword with any type of body
func NewUserPasswordRequestWithBody(server string, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/password", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserPermissionRequest generates requests for UserPermission
func NewUserPermissionRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/permissions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserPictureDeleteRequest generates requests for UserPictureDelete
func NewUserPictureDeleteRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/picture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserPictureRequestWithBody generates requests for UserPicture with any type of body
func NewUserPictureRequestWithBody(server string, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/picture", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdatePresenceStatusRequest calls the generic UpdatePresenceStatus builder with application/json body
func NewUpdatePresenceStatusRequest(server string, userId string, body UpdatePresenceStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePresenceStatusRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUpdatePresenceStatusRequestWithBody generates requests for UpdatePresenceStatus with any type of body
func NewUpdatePresenceStatusRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/presence_status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserSchedulersDeleteRequest generates requests for UserSchedulersDelete
func NewUserSchedulersDeleteRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/schedulers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSchedulersRequest generates requests for UserSchedulers
func NewUserSchedulersRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/schedulers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSchedulerDeleteRequest generates requests for UserSchedulerDelete
func NewUserSchedulerDeleteRequest(server string, userId struct {
	union json.RawMessage
}, schedulerId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "schedulerId", runtime.ParamLocationPath, schedulerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/schedulers/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSettingsRequest generates requests for UserSettings
func NewUserSettingsRequest(server string, userId struct {
	union json.RawMessage
}, params *UserSettingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LoginType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "login_type", runtime.ParamLocationQuery, *params.LoginType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Option != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "option", runtime.ParamLocationQuery, *params.Option); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CustomQueryFields != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "custom_query_fields", runtime.ParamLocationQuery, *params.CustomQueryFields); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserSettingsUpdateRequest calls the generic UserSettingsUpdate builder with application/json body
func NewUserSettingsUpdateRequest(server string, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, body UserSettingsUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserSettingsUpdateRequestWithBody(server, userId, params, "application/json", bodyReader)
}

// NewUserSettingsUpdateRequestWithBody generates requests for UserSettingsUpdate with any type of body
func NewUserSettingsUpdateRequestWithBody(server string, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Option != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "option", runtime.ParamLocationQuery, *params.Option); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDelUserVBRequest generates requests for DelUserVB
func NewDelUserVBRequest(server string, userId string, params *DelUserVBParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings/virtual_backgrounds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.FileIds != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "file_ids", runtime.ParamLocationQuery, *params.FileIds); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadVBuserRequestWithBody generates requests for UploadVBuser with any type of body
func NewUploadVBuserRequestWithBody(server string, userId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/settings/virtual_backgrounds", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserStatusRequest calls the generic UserStatus builder with application/json body
func NewUserStatusRequest(server string, userId struct {
	union json.RawMessage
}, body UserStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUserStatusRequestWithBody(server, userId, "application/json", bodyReader)
}

// NewUserStatusRequestWithBody generates requests for UserStatus with any type of body
func NewUserStatusRequestWithBody(server string, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUserSSOTokenDeleteRequest generates requests for UserSSOTokenDelete
func NewUserSSOTokenDeleteRequest(server string, userId struct {
	union json.RawMessage
}) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUserTokenRequest generates requests for UserToken
func NewUserTokenRequest(server string, userId struct {
	union json.RawMessage
}, params *UserTokenParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "userId", runtime.ParamLocationPath, userId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/token", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ttl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ttl", runtime.ParamLocationQuery, *params.Ttl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// DeleteMeetingChatMessageById request
	DeleteMeetingChatMessageByIdWithResponse(ctx context.Context, meetingId int64, messageId string, reqEditors ...RequestEditorFn) (*DeleteMeetingChatMessageByIdResponse, error)

	// InMeetingControl request with any body
	InMeetingControlWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InMeetingControlResponse, error)

	InMeetingControlWithResponse(ctx context.Context, meetingId string, body InMeetingControlJSONRequestBody, reqEditors ...RequestEditorFn) (*InMeetingControlResponse, error)

	// MeetingDelete request
	MeetingDeleteWithResponse(ctx context.Context, meetingId int64, params *MeetingDeleteParams, reqEditors ...RequestEditorFn) (*MeetingDeleteResponse, error)

	// Meeting request
	MeetingWithResponse(ctx context.Context, meetingId int64, params *MeetingParams, reqEditors ...RequestEditorFn) (*MeetingResponse, error)

	// MeetingUpdate request with any body
	MeetingUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingUpdateResponse, error)

	MeetingUpdateWithResponse(ctx context.Context, meetingId int64, params *MeetingUpdateParams, body MeetingUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingUpdateResponse, error)

	// CreateBatchPolls request with any body
	CreateBatchPollsWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchPollsResponse, error)

	CreateBatchPollsWithResponse(ctx context.Context, meetingId string, body CreateBatchPollsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchPollsResponse, error)

	// AddBatchRegistrants request with any body
	AddBatchRegistrantsWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBatchRegistrantsResponse, error)

	AddBatchRegistrantsWithResponse(ctx context.Context, meetingId string, body AddBatchRegistrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBatchRegistrantsResponse, error)

	// MeetingInvitation request
	MeetingInvitationWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingInvitationResponse, error)

	// MeetingInviteLinksCreate request with any body
	MeetingInviteLinksCreateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingInviteLinksCreateResponse, error)

	MeetingInviteLinksCreateWithResponse(ctx context.Context, meetingId int64, body MeetingInviteLinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingInviteLinksCreateResponse, error)

	// MeetingLiveStreamingJoinToken request
	MeetingLiveStreamingJoinTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLiveStreamingJoinTokenResponse, error)

	// MeetingLocalArchivingArchiveToken request
	MeetingLocalArchivingArchiveTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLocalArchivingArchiveTokenResponse, error)

	// MeetingLocalRecordingJoinToken request
	MeetingLocalRecordingJoinTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLocalRecordingJoinTokenResponse, error)

	// GetMeetingLiveStreamDetails request
	GetMeetingLiveStreamDetailsWithResponse(ctx context.Context, meetingId string, reqEditors ...RequestEditorFn) (*GetMeetingLiveStreamDetailsResponse, error)

	// MeetingLiveStreamUpdate request with any body
	MeetingLiveStreamUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingLiveStreamUpdateResponse, error)

	MeetingLiveStreamUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingLiveStreamUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingLiveStreamUpdateResponse, error)

	// MeetingLiveStreamStatusUpdate request with any body
	MeetingLiveStreamStatusUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingLiveStreamStatusUpdateResponse, error)

	MeetingLiveStreamStatusUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingLiveStreamStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingLiveStreamStatusUpdateResponse, error)

	// MeetingPolls request
	MeetingPollsWithResponse(ctx context.Context, meetingId int64, params *MeetingPollsParams, reqEditors ...RequestEditorFn) (*MeetingPollsResponse, error)

	// MeetingPollCreate request with any body
	MeetingPollCreateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingPollCreateResponse, error)

	MeetingPollCreateWithResponse(ctx context.Context, meetingId int64, body MeetingPollCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingPollCreateResponse, error)

	// MeetingPollDelete request
	MeetingPollDeleteWithResponse(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*MeetingPollDeleteResponse, error)

	// MeetingPollGet request
	MeetingPollGetWithResponse(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*MeetingPollGetResponse, error)

	// MeetingPollUpdate request with any body
	MeetingPollUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, pollId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingPollUpdateResponse, error)

	MeetingPollUpdateWithResponse(ctx context.Context, meetingId int64, pollId string, body MeetingPollUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingPollUpdateResponse, error)

	// MeetingRegistrants request
	MeetingRegistrantsWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantsParams, reqEditors ...RequestEditorFn) (*MeetingRegistrantsResponse, error)

	// MeetingRegistrantCreate request with any body
	MeetingRegistrantCreateWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantCreateResponse, error)

	MeetingRegistrantCreateWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, body MeetingRegistrantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantCreateResponse, error)

	// MeetingRegistrantsQuestionsGet request
	MeetingRegistrantsQuestionsGetWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingRegistrantsQuestionsGetResponse, error)

	// MeetingRegistrantQuestionUpdate request with any body
	MeetingRegistrantQuestionUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantQuestionUpdateResponse, error)

	MeetingRegistrantQuestionUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingRegistrantQuestionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantQuestionUpdateResponse, error)

	// MeetingRegistrantStatus request with any body
	MeetingRegistrantStatusWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantStatusResponse, error)

	MeetingRegistrantStatusWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, body MeetingRegistrantStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantStatusResponse, error)

	// Meetingregistrantdelete request
	MeetingregistrantdeleteWithResponse(ctx context.Context, meetingId int, registrantId string, params *MeetingregistrantdeleteParams, reqEditors ...RequestEditorFn) (*MeetingregistrantdeleteResponse, error)

	// MeetingRegistrantGet request
	MeetingRegistrantGetWithResponse(ctx context.Context, meetingId int64, registrantId string, reqEditors ...RequestEditorFn) (*MeetingRegistrantGetResponse, error)

	// GetSipDialingWithPasscode request with any body
	GetSipDialingWithPasscodeWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSipDialingWithPasscodeResponse, error)

	GetSipDialingWithPasscodeWithResponse(ctx context.Context, meetingId int64, body GetSipDialingWithPasscodeJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSipDialingWithPasscodeResponse, error)

	// MeetingStatus request with any body
	MeetingStatusWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingStatusResponse, error)

	MeetingStatusWithResponse(ctx context.Context, meetingId int64, body MeetingStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingStatusResponse, error)

	// MeetingSurveyDelete request
	MeetingSurveyDeleteWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingSurveyDeleteResponse, error)

	// MeetingSurveyGet request
	MeetingSurveyGetWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingSurveyGetResponse, error)

	// MeetingSurveyUpdate request with any body
	MeetingSurveyUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingSurveyUpdateResponse, error)

	MeetingSurveyUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingSurveyUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingSurveyUpdateResponse, error)

	// MeetingToken request
	MeetingTokenWithResponse(ctx context.Context, meetingId int64, params *MeetingTokenParams, reqEditors ...RequestEditorFn) (*MeetingTokenResponse, error)

	// PastMeetingDetails request
	PastMeetingDetailsWithResponse(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*PastMeetingDetailsResponse, error)

	// PastMeetings request
	PastMeetingsWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*PastMeetingsResponse, error)

	// PastMeetingParticipants request
	PastMeetingParticipantsWithResponse(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, params *PastMeetingParticipantsParams, reqEditors ...RequestEditorFn) (*PastMeetingParticipantsResponse, error)

	// ListPastMeetingPolls request
	ListPastMeetingPollsWithResponse(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*ListPastMeetingPollsResponse, error)

	// ListPastMeetingQA request
	ListPastMeetingQAWithResponse(ctx context.Context, meetingId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*ListPastMeetingQAResponse, error)

	// Users request
	UsersWithResponse(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error)

	// UserCreate request with any body
	UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error)

	// UserEmail request
	UserEmailWithResponse(ctx context.Context, params *UserEmailParams, reqEditors ...RequestEditorFn) (*UserEmailResponse, error)

	// BulkUpdateFeature request with any body
	BulkUpdateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateFeatureResponse, error)

	BulkUpdateFeatureWithResponse(ctx context.Context, body BulkUpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateFeatureResponse, error)

	// UserZak request
	UserZakWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserZakResponse, error)

	// UserSummary request
	UserSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserSummaryResponse, error)

	// UserVanityName request
	UserVanityNameWithResponse(ctx context.Context, params *UserVanityNameParams, reqEditors ...RequestEditorFn) (*UserVanityNameResponse, error)

	// UserDelete request
	UserDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserDeleteParams, reqEditors ...RequestEditorFn) (*UserDeleteResponse, error)

	// User request
	UserWithResponse(ctx context.Context, userId string, params *UserParams, reqEditors ...RequestEditorFn) (*UserResponse, error)

	// UserUpdate request with any body
	UserUpdateWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	UserUpdateWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserUpdateParams, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error)

	// SwitchAUsersAccount request with any body
	SwitchAUsersAccountWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwitchAUsersAccountResponse, error)

	SwitchAUsersAccountWithResponse(ctx context.Context, userId string, body SwitchAUsersAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*SwitchAUsersAccountResponse, error)

	// UserAssistantsDelete request
	UserAssistantsDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserAssistantsDeleteResponse, error)

	// UserAssistants request
	UserAssistantsWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserAssistantsResponse, error)

	// UserAssistantCreate request with any body
	UserAssistantCreateWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserAssistantCreateResponse, error)

	UserAssistantCreateWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserAssistantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserAssistantCreateResponse, error)

	// UserAssistantDelete request
	UserAssistantDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, assistantId string, reqEditors ...RequestEditorFn) (*UserAssistantDeleteResponse, error)

	// ListCollaborationDevices request
	ListCollaborationDevicesWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*ListCollaborationDevicesResponse, error)

	// GetCollaborationDevice request
	GetCollaborationDeviceWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, collaborationDeviceId string, reqEditors ...RequestEditorFn) (*GetCollaborationDeviceResponse, error)

	// UserEmailUpdate request with any body
	UserEmailUpdateWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserEmailUpdateResponse, error)

	UserEmailUpdateWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserEmailUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserEmailUpdateResponse, error)

	// ListMeetingTemplates request
	ListMeetingTemplatesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ListMeetingTemplatesResponse, error)

	// MeetingTemplateCreate request with any body
	MeetingTemplateCreateWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingTemplateCreateResponse, error)

	MeetingTemplateCreateWithResponse(ctx context.Context, userId string, body MeetingTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingTemplateCreateResponse, error)

	// Meetings request
	MeetingsWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *MeetingsParams, reqEditors ...RequestEditorFn) (*MeetingsResponse, error)

	// MeetingCreate request with any body
	MeetingCreateWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingCreateResponse, error)

	MeetingCreateWithResponse(ctx context.Context, userId string, body MeetingCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingCreateResponse, error)

	// UserPassword request with any body
	UserPasswordWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserPasswordResponse, error)

	UserPasswordWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserPasswordResponse, error)

	// UserPermission request
	UserPermissionWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserPermissionResponse, error)

	// UserPictureDelete request
	UserPictureDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserPictureDeleteResponse, error)

	// UserPicture request with any body
	UserPictureWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserPictureResponse, error)

	// UpdatePresenceStatus request with any body
	UpdatePresenceStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePresenceStatusResponse, error)

	UpdatePresenceStatusWithResponse(ctx context.Context, userId string, body UpdatePresenceStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePresenceStatusResponse, error)

	// UserSchedulersDelete request
	UserSchedulersDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserSchedulersDeleteResponse, error)

	// UserSchedulers request
	UserSchedulersWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserSchedulersResponse, error)

	// UserSchedulerDelete request
	UserSchedulerDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, schedulerId string, reqEditors ...RequestEditorFn) (*UserSchedulerDeleteResponse, error)

	// UserSettings request
	UserSettingsWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsParams, reqEditors ...RequestEditorFn) (*UserSettingsResponse, error)

	// UserSettingsUpdate request with any body
	UserSettingsUpdateWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserSettingsUpdateResponse, error)

	UserSettingsUpdateWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserSettingsUpdateParams, body UserSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserSettingsUpdateResponse, error)

	// DelUserVB request
	DelUserVBWithResponse(ctx context.Context, userId string, params *DelUserVBParams, reqEditors ...RequestEditorFn) (*DelUserVBResponse, error)

	// UploadVBuser request with any body
	UploadVBuserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadVBuserResponse, error)

	// UserStatus request with any body
	UserStatusWithBodyWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserStatusResponse, error)

	UserStatusWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, body UserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UserStatusResponse, error)

	// UserSSOTokenDelete request
	UserSSOTokenDeleteWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, reqEditors ...RequestEditorFn) (*UserSSOTokenDeleteResponse, error)

	// UserToken request
	UserTokenWithResponse(ctx context.Context, userId struct {
		union json.RawMessage
	}, params *UserTokenParams, reqEditors ...RequestEditorFn) (*UserTokenResponse, error)
}

type DeleteMeetingChatMessageByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteMeetingChatMessageByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMeetingChatMessageByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type InMeetingControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r InMeetingControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r InMeetingControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Agenda Meeting description
		Agenda *string `json:"agenda,omitempty"`

		// AssistantId The ID of the user who scheduled this meeting on behalf of the host.
		AssistantId *string `json:"assistant_id,omitempty"`

		// ChatJoinUrl The URL to join the chat.
		ChatJoinUrl *string `json:"chat_join_url,omitempty"`

		// CreatedAt Time of creation.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Duration Meeting duration.
		Duration *int `json:"duration,omitempty"`

		// EncryptedPassword Encrypted passcode for third party endpoints (H323/SIP).
		EncryptedPassword *string `json:"encrypted_password,omitempty"`

		// H323Password H.323/SIP room system passcode.
		H323Password *string `json:"h323_password,omitempty"`

		// HostEmail Email address of the meeting host.
		HostEmail *openapi_types.Email `json:"host_email,omitempty"`

		// HostId ID of the user who is set as host of meeting.
		HostId *string `json:"host_id,omitempty"`

		// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
		Id *int64 `json:"id,omitempty"`

		// JoinUrl URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
		JoinUrl *string `json:"join_url,omitempty"`

		// Occurrences Array of occurrence objects.
		Occurrences *[]struct {
			// Duration Duration.
			Duration *int `json:"duration,omitempty"`

			// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring meeting. [Recurring meetings](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings) can have a maximum of 50 occurrences.
			OccurrenceId *string `json:"occurrence_id,omitempty"`

			// StartTime Start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Status Occurrence status.
			Status *string `json:"status,omitempty"`
		} `json:"occurrences,omitempty"`

		// Password Meeting passcode.
		Password *string `json:"password,omitempty"`

		// Pmi [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
		Pmi *string `json:"pmi,omitempty"`

		// PreSchedule Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time):
		// * `true` - A GSuite prescheduled meeting.
		// * `false` - A regular meeting.
		PreSchedule *bool `json:"pre_schedule,omitempty"`

		// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
		Recurrence *struct {
			// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
			EndDateTime *time.Time `json:"end_date_time,omitempty"`

			// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
			EndTimes *int `json:"end_times,omitempty"`

			// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
			//
			// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
			MonthlyDay *int `json:"monthly_day,omitempty"`

			// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
			//  `-1` - Last week of the month.
			//  `1` - First week of the month.
			//  `2` - Second week of the month.
			//  `3` - Third week of the month.
			//  `4` - Fourth week of the month.
			MonthlyWeek *int `json:"monthly_week,omitempty"`

			// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
			//
			//
			//  `1` - Sunday.
			//  `2` - Monday.
			//  `3` - Tuesday.
			//  `4` -  Wednesday.
			//  `5` - Thursday.
			//  `6` - Friday.
			//  `7` - Saturday.
			MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

			// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
			//
			// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
			//
			RepeatInterval *int `json:"repeat_interval,omitempty"`

			// Type Recurrence meeting types:
			//  `1` - Daily.
			//  `2` - Weekly.
			//  `3` - Monthly.
			Type int `json:"type"`

			// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
			//
			//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
			//
			//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
			//
			//
			//  `1`  - Sunday.
			//  `2` - Monday.
			//  `3` - Tuesday.
			//  `4` -  Wednesday.
			//  `5` -  Thursday.
			//  `6` - Friday.
			//  `7` - Saturday.
			WeeklyDays *string `json:"weekly_days,omitempty"`
		} `json:"recurrence,omitempty"`

		// Settings Meeting settings.
		Settings *struct {
			// AllowMultipleDevices Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
			AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

			// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
			AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

			// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
			AlternativeHosts *string `json:"alternative_hosts,omitempty"`

			// AlternativeHostsEmailNotification Flag to determine whether to send email notifications to alternative hosts, default value is true.
			AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

			// ApprovalType Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**
			//
			//
			//
			// `0` - Automatically approve.
			//  `1` - Manually approve.
			//  `2` - No registration required.
			ApprovalType *int `json:"approval_type,omitempty"`

			// ApprovedOrDeniedCountriesOrRegions Approve or block users from specific regions/countries from joining this meeting.
			ApprovedOrDeniedCountriesOrRegions *struct {
				// ApprovedList List of countries/regions from where participants can join this meeting.
				ApprovedList *[]string `json:"approved_list,omitempty"`

				// DeniedList List of countries/regions from where participants can not join this meeting.
				DeniedList *[]string `json:"denied_list,omitempty"`

				// Enable `true`: Setting enabled to either allow users or block users from specific regions to join your meetings.
				//
				//
				// `false`: Setting disabled.
				Enable *bool `json:"enable,omitempty"`

				// Method Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.
				//
				//
				// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.
				//
				//
				// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
				Method *string `json:"method,omitempty"`
			} `json:"approved_or_denied_countries_or_regions,omitempty"`

			// Audio Determine how participants can join the audio portion of the meeting.
			//  `both` - Both Telephony and VoIP.
			//  `telephony` - Telephony only.
			//  `voip` - VoIP only.
			//  `thirdParty` - Third party audio conference.
			Audio *string `json:"audio,omitempty"`

			// AudioConferenceInfo Third party audio conference info.
			AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

			// AuthenticationDomains If user has configured [&quot;Sign Into Zoom with Specified Domains&quot;](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
			AuthenticationDomains *string `json:"authentication_domains,omitempty"`

			// AuthenticationException The participants added here will receive unique meeting invite links and bypass authentication.
			AuthenticationException *[]struct {
				// Email Email address of the participant.
				Email *openapi_types.Email `json:"email,omitempty"`

				// JoinUrl URL for participants to join the meeting
				JoinUrl *string `json:"join_url,omitempty"`

				// Name Name of the participant.
				Name *string `json:"name,omitempty"`
			} `json:"authentication_exception,omitempty"`

			// AuthenticationName Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
			AuthenticationName *string `json:"authentication_name,omitempty"`

			// AuthenticationOption Meeting authentication option id.
			AuthenticationOption *string `json:"authentication_option,omitempty"`

			// AutoRecording Automatic recording:
			//  `local` - Record on local.
			//  `cloud` -  Record on cloud.
			//  `none` - Disabled.
			AutoRecording *string `json:"auto_recording,omitempty"`

			// BreakoutRoom Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
			BreakoutRoom *struct {
				// Enable Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
				Enable *bool `json:"enable,omitempty"`

				// Rooms Create room(s).
				Rooms *[]struct {
					// Name Name of the breakout room.
					Name *string `json:"name,omitempty"`

					// Participants Email addresses of the participants who are to be assigned to the breakout room.
					Participants *[]string `json:"participants,omitempty"`
				} `json:"rooms,omitempty"`
			} `json:"breakout_room,omitempty"`

			// CalendarType Indicates the type of calendar integration used to schedule the meeting:
			// * `1` &mdash; [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
			// * `2` &mdash; [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
			//
			// Works with the `private_meeting` field to determine whether to share details of meetings or not.
			CalendarType *int `json:"calendar_type,omitempty"`

			// CloseRegistration Close registration after event date
			CloseRegistration *bool `json:"close_registration,omitempty"`

			// CnMeeting Host meeting in China.
			// Deprecated:
			CnMeeting *bool `json:"cn_meeting,omitempty"`

			// ContactEmail Contact email for registration
			ContactEmail *string `json:"contact_email,omitempty"`

			// ContactName Contact name for registration
			ContactName *string `json:"contact_name,omitempty"`

			// CustomKeys Custom keys and values assigned to the meeting.
			CustomKeys *[]struct {
				// Key Custom key associated with the user.
				Key *string `json:"key,omitempty"`

				// Value Value of the custom key associated with the user.
				Value *string `json:"value,omitempty"`
			} `json:"custom_keys,omitempty"`

			// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
			EmailNotification *bool `json:"email_notification,omitempty"`

			// EncryptionType Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.
			//
			//  The value of this field can be one of the following:
			//
			// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option.
			//
			//
			// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
			EncryptionType *string `json:"encryption_type,omitempty"`

			// EnforceLogin Only signed in users can join this meeting.
			//
			// **This field is deprecated and will not be supported in the future.**
			//
			//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
			// Deprecated:
			EnforceLogin *bool `json:"enforce_login,omitempty"`

			// EnforceLoginDomains Only signed in users with specified domains can join meetings.
			//
			// **This field is deprecated and will not be supported in the future.**
			//
			//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
			// Deprecated:
			EnforceLoginDomains *string `json:"enforce_login_domains,omitempty"`

			// FocusMode Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
			FocusMode *bool `json:"focus_mode,omitempty"`

			// GlobalDialInCountries List of global dial-in countries
			GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

			// GlobalDialInNumbers Global Dial-in Countries/Regions
			GlobalDialInNumbers *[]struct {
				// City City of the number, if any. For example, Chicago.
				City *string `json:"city,omitempty"`

				// Country Country code. For example, BR.
				Country *string `json:"country,omitempty"`

				// CountryName Full name of country. For example, Brazil.
				CountryName *string `json:"country_name,omitempty"`

				// Number Phone number. For example, +1 2332357613.
				Number *string `json:"number,omitempty"`

				// Type Type of number.
				Type *string `json:"type,omitempty"`
			} `json:"global_dial_in_numbers,omitempty"`

			// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
			HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

			// HostVideo Start video when the host joins the meeting.
			HostVideo *bool `json:"host_video,omitempty"`

			// InMeeting Host meeting in India.
			// Deprecated:
			InMeeting *bool `json:"in_meeting,omitempty"`

			// JbhTime If the value of &quot;join_before_host&quot; field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
			//
			// *  `0`: Allow participant to join anytime.
			// *  `5`: Allow participant to join 5 minutes before meeting start time.
			//  * `10`: Allow participant to join 10 minutes before meeting start time.
			JbhTime *int `json:"jbh_time,omitempty"`

			// JoinBeforeHost Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
			JoinBeforeHost *bool `json:"join_before_host,omitempty"`

			// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
			//
			// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
			LanguageInterpretation *struct {
				// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
				Enable *bool `json:"enable,omitempty"`

				// Interpreters Information about the meeting's language interpreters.
				Interpreters *[]struct {
					// Email The interpreter's email address.
					Email *openapi_types.Email `json:"email,omitempty"`

					// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
					//
					// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
					Languages *string `json:"languages,omitempty"`
				} `json:"interpreters,omitempty"`
			} `json:"language_interpretation,omitempty"`

			// MeetingAuthentication `true`- Only authenticated users can join meetings.
			MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

			// MuteUponEntry Mute participants upon entry.
			MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

			// ParticipantVideo Start video when participants join the meeting.
			ParticipantVideo *bool `json:"participant_video,omitempty"`

			// PrivateMeeting Whether the meeting is set as private.
			PrivateMeeting *bool `json:"private_meeting,omitempty"`

			// RegistrantsConfirmationEmail Whether to send registrants an email confirmation:
			// * `true` &mdash; Send a confirmation email.
			// * `false` &mdash; Do not send a confirmation email.
			RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

			// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
			//
			// * `true` &mdash; Send an email notification.
			// * `false` &mdash; Do not send an email notification.
			//
			//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
			RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

			// RegistrationType Registration type. Used for recurring meeting with fixed time only.
			//  `1` Attendees register once and can attend any of the occurrences.
			//  `2` Attendees need to register for each occurrence to attend.
			//  `3` Attendees register once and can choose one or more occurrences to attend.
			RegistrationType *int `json:"registration_type,omitempty"`

			// ShowShareButton Show social share buttons on the meeting registration page.
			// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
			ShowShareButton *bool `json:"show_share_button,omitempty"`

			// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
			//
			// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
			SignLanguageInterpretation *struct {
				// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
				Enable *bool `json:"enable,omitempty"`

				// Interpreters Information about the meeting's sign language interpreters.
				Interpreters *[]struct {
					// Email The interpreter's email address.
					Email *openapi_types.Email `json:"email,omitempty"`

					// SignLanguage The interpreter's sign language.
					//
					//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
					SignLanguage *string `json:"sign_language,omitempty"`
				} `json:"interpreters,omitempty"`
			} `json:"sign_language_interpretation,omitempty"`

			// UsePmi Use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
			UsePmi *bool `json:"use_pmi,omitempty"`

			// WaitingRoom Enable waiting room
			WaitingRoom *bool `json:"waiting_room,omitempty"`

			// Watermark Add watermark when viewing a shared screen.
			Watermark *bool `json:"watermark,omitempty"`
		} `json:"settings,omitempty"`

		// StartTime Meeting start time in GMT/UTC. Start time will not be returned if the meeting is an **instant** meeting.
		StartTime *time.Time `json:"start_time,omitempty"`

		// StartUrl
		//  &lt;aside&gt;The &lt;code&gt;start_url&lt;/code&gt; of a Meeting is a URL using which a host or an alternative host can start the Meeting.
		//
		// The expiration time for the &lt;code&gt;start_url&lt;/code&gt; field listed in the response of the [**Create a meeting**](/docs/api-reference/zoom-api/methods#operation/meetingCreate) API is two hours for all regular users.
		//
		// For users created using the &lt;code&gt;custCreate&lt;/code&gt; option via the [**Create users**](/docs/api-reference/zoom-api/methods#operation/userCreate) API, the expiration time of the &lt;code&gt;start_url&lt;/code&gt; field is 90 days.
		//
		// For security reasons, to retrieve the updated value for the &lt;code&gt;start_url&lt;/code&gt; field programmatically (after the expiry time), you must call the [**Get a meeting](/docs/api-reference/zoom-api/methods#operation/meeting) API and refer to the value of the &lt;code&gt;start_url&lt;/code&gt; field in the response.&lt;/aside&gt;
		//  This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
		StartUrl *string `json:"start_url,omitempty"`

		// Status Meeting status
		Status *string `json:"status,omitempty"`

		// Timezone Timezone to format the meeting start time on the .
		Timezone *string `json:"timezone,omitempty"`

		// Topic Meeting topic.
		Topic *string `json:"topic,omitempty"`

		// TrackingFields Tracking fields
		TrackingFields *[]struct {
			// Field Label of the tracking field.
			Field *string `json:"field,omitempty"`

			// Value Value for the field.
			Value *string `json:"value,omitempty"`

			// Visible Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
			//
			// `true`: Tracking field is visible.
			//
			//
			// `false`: Tracking field is not visible to the users when they look at the meeting details in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
			Visible *bool `json:"visible,omitempty"`
		} `json:"tracking_fields,omitempty"`

		// Type Meeting Types:
		//  `1` - Instant meeting.
		//  `2` - Scheduled meeting.
		//  `3` - Recurring meeting with no fixed time.
		//  `4` - PMI Meeting
		//
		// `8` - Recurring meeting with a fixed time.
		Type *int `json:"type,omitempty"`

		// Uuid Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). You can retrieve a list of UUIDs from past meeting instances using the [**List past meeting instances**](/docs/api-reference/zoom-api/methods#operation/pastMeetings) API. [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBatchPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Polls *[]struct {
			// Anonymous Whether to allow meeting participants to answer poll questions anonymously:
			// * `true` &mdash; Anonymous polls enabled.
			// * `false` &mdash; Participants cannot answer poll questions anonymously.
			Anonymous *bool `json:"anonymous,omitempty"`

			// Id Meeting Poll ID
			Id *string `json:"id,omitempty"`

			// PollType The type of poll:
			// * `1` &mdash; Poll.
			// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
			// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
			PollType *int `json:"poll_type,omitempty"`

			// Questions Information about the poll's questions.
			Questions *[]struct {
				// AnswerMaxCharacter The allowed maximum number of characters. This field only returns for `short_answer` and `long_answer` polls.
				AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

				// AnswerMinCharacter The allowed minimum number of characters. This field only returns for `short_answer` and `long_answer` polls.
				AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

				// AnswerRequired Whether participants must answer the question:
				// * `true` &mdash; The participant must answer the question.
				// * `false` &mdash; The participant does not need to answer the question.
				AnswerRequired *bool `json:"answer_required,omitempty"`

				// Answers The poll question's available answers.
				Answers *[]string `json:"answers,omitempty"`

				// CaseSensitive Whether the correct answer is case sensitive. This field only returns for `fill_in_the_blank` polls:
				// * `true` &mdash; The answer is case-sensitive.
				// * `false` &mdash; The answer is not case-sensitive.
				CaseSensitive *bool `json:"case_sensitive,omitempty"`

				// Name The poll question's title. For `fill_in_the_blank` polls, this field is the poll's question.
				Name *string `json:"name,omitempty"`

				// Prompts Information about the prompt questions. This object only returns for `matching` and `rank_order` polls.
				Prompts *[]struct {
					// PromptQuestion The question prompt's title.
					PromptQuestion *string `json:"prompt_question,omitempty"`

					// PromptRightAnswers The question prompt's correct answers.
					PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
				} `json:"prompts,omitempty"`

				// RatingMaxLabel The high score label used for the `rating_max_value` field. This field only returns for `rating_scale` polls.
				RatingMaxLabel *string `json:"rating_max_label,omitempty"`

				// RatingMaxValue The rating scale's maximum value. This field only returns for `rating_scale` polls.
				RatingMaxValue *int `json:"rating_max_value,omitempty"`

				// RatingMinLabel The low score label used for the `rating_min_value` field. This field only returns for `rating_scale` polls.
				RatingMinLabel *string `json:"rating_min_label,omitempty"`

				// RatingMinValue The rating scale's minimum value. This field only returns for `rating_scale` polls.
				RatingMinValue *int `json:"rating_min_value,omitempty"`

				// RightAnswers The poll question's correct answer(s).
				RightAnswers *[]string `json:"right_answers,omitempty"`

				// ShowAsDropdown Whether to display the radio selection as a drop-down box:
				// * `true` &mdash; Show as a drop-down box.
				// * `false` &mdash; Do not show as a drop-down box.
				ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

				// Type The poll's question and answer type:
				// * `single` &mdash; Single choice.
				// * `multiple` &mdash; Multiple choice.
				// * `matching` &mdash; Matching.
				// * `rank_order` &mdash; Rank order.
				// * `short_answer` &mdash; Short answer.
				// * `long_answer` &mdash; Long answer.
				// * `fill_in_the_blank` &mdash; Fill in the blank.
				// * `rating_scale` &mdash; Rating scale.
				Type *string `json:"type,omitempty"`
			} `json:"questions,omitempty"`

			// Status Status of the Meeting Poll:
			//  `notstart` - Poll not started
			//  `started` - Poll started
			//  `ended` - Poll ended
			//  `sharing` - Sharing poll results
			Status *string `json:"status,omitempty"`

			// Title Title for the Poll
			Title *string `json:"title,omitempty"`
		} `json:"polls,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateBatchPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBatchPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddBatchRegistrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Registrants *[]struct {
			// Email Email address of the registrant.
			Email *string `json:"email,omitempty"`

			// JoinUrl Unique URL using which registrant can join the meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
			ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

			// RegistrantId Unique identifier of the registrant.
			RegistrantId *string `json:"registrant_id,omitempty"`
		} `json:"registrants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r AddBatchRegistrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddBatchRegistrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Invitation Meeting invitation.
		Invitation *string `json:"invitation,omitempty"`

		// SipLinks A list of SIP phone addresses.
		SipLinks *[]string `json:"sip_links,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingInviteLinksCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Attendees The attendee list.
		Attendees *[]struct {
			// JoinUrl The URL to join the meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// Name The user's display name.
			Name *string `json:"name,omitempty"`
		} `json:"attendees,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingInviteLinksCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingInviteLinksCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingLiveStreamingJoinTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExpireIn The number of seconds the join token is valid for before it expires. This value always returns `120`.
		ExpireIn *int64 `json:"expire_in,omitempty"`

		// Token The join token.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingLiveStreamingJoinTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingLiveStreamingJoinTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingLocalArchivingArchiveTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExpireIn The number of seconds the archive token is valid for before it expires. This value always returns `120`.
		ExpireIn *int64 `json:"expire_in,omitempty"`

		// Token The archive token.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingLocalArchivingArchiveTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingLocalArchivingArchiveTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingLocalRecordingJoinTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExpireIn The number of seconds the join token is valid for before it expires. This value always returns `120`.
		ExpireIn *int64 `json:"expire_in,omitempty"`

		// Token The join token.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingLocalRecordingJoinTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingLocalRecordingJoinTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeetingLiveStreamDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// PageUrl Live streaming page URL. This is the URL using which anyone can view the livestream of the meeting.
		PageUrl *string `json:"page_url,omitempty"`

		// Resolution The number of pixels in each dimension that the video camera can display.
		Resolution *string `json:"resolution,omitempty"`

		// StreamKey Stream Key.
		StreamKey *string `json:"stream_key,omitempty"`

		// StreamUrl Stream URL.
		StreamUrl *string `json:"stream_url,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMeetingLiveStreamDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeetingLiveStreamDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingLiveStreamUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingLiveStreamUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingLiveStreamUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingLiveStreamStatusUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingLiveStreamStatusUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingLiveStreamStatusUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Polls Array of Polls
		Polls *[]struct {
			// Anonymous Allow meeting participants to answer poll questions anonymously.
			//
			// This value defaults to `false`.
			Anonymous *bool `json:"anonymous,omitempty"`

			// Id ID of Poll
			Id *string `json:"id,omitempty"`

			// PollType The type of poll:
			// * `1` &mdash; Poll.
			// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
			// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
			//
			//  This value defaults to `1`.
			PollType *int `json:"poll_type,omitempty"`

			// Questions Information about the poll's questions.
			Questions *[]struct {
				// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
				// * For `short_answer` polls, a maximum of 500 characters.
				// * For `long_answer` polls, a maximum of 2,000 characters.
				AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

				// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
				AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

				// AnswerRequired Whether participants must answer the question:
				// * `true` &mdash; The participant must answer the question.
				// * `false` &mdash; The participant does not need to answer the question.
				//
				// **Note:**
				// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
				// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
				AnswerRequired *bool `json:"answer_required,omitempty"`

				// Answers The poll question's available answers. This field requires a **minimum** of two answers.
				//
				// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
				// * For `matching` polls, you can only provide a maximum of 16 answers.
				// * For `rank_order` polls, you can only provide a maximum of seven answers.
				Answers *[]string `json:"answers,omitempty"`

				// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
				// * `true` &mdash; The answer is case-sensitive.
				// * `false` &mdash; The answer is not case-sensitive.
				//
				// This value defaults to `false`.
				CaseSensitive *bool `json:"case_sensitive,omitempty"`

				// Name The poll question, up to 255 characters.
				//
				// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
				Name *string `json:"name,omitempty"`

				// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
				Prompts *[]struct {
					// PromptQuestion The question prompt's title.
					PromptQuestion *string `json:"prompt_question,omitempty"`

					// PromptRightAnswers The question prompt's correct answers:
					// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
					// * For `rank_order` polls, you can only provide one correct answer.
					PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
				} `json:"prompts,omitempty"`

				// RatingMaxLabel The high score label used for the `rating_max_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxLabel *string `json:"rating_max_label,omitempty"`

				// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxValue *int `json:"rating_max_value,omitempty"`

				// RatingMinLabel The low score label used for the `rating_min_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinLabel *string `json:"rating_min_label,omitempty"`

				// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinValue *int `json:"rating_min_value,omitempty"`

				// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
				//
				//  For `single` and `matching` polls, this field only accepts one answer.
				RightAnswers *[]string `json:"right_answers,omitempty"`

				// ShowAsDropdown Whether to display the radio selection as a drop-down box:
				// * `true` &mdash; Show as a drop-down box.
				// * `false` &mdash; Do not show as a drop-down box.
				//
				// This value defaults to `false`.
				ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

				// Type The poll's question and answer type:
				// * `single` &mdash; Single choice.
				// * `multiple` &mdash; Multiple choice.
				// * `matching` &mdash; Matching.
				// * `rank_order` &mdash; Rank order.
				// * `short_answer` &mdash; Short answer.
				// * `long_answer` &mdash; Long answer.
				// * `fill_in_the_blank` &mdash; Fill in the blank.
				// * `rating_scale` &mdash; Rating scale.
				Type *string `json:"type,omitempty"`
			} `json:"questions,omitempty"`

			// Status Status of Poll:
			//  `notstart` - Poll not started
			//  `started` - Poll started
			//  `ended` - Poll ended
			//  `sharing` - Sharing poll results
			Status *string `json:"status,omitempty"`

			// Title The poll's title, up to 64 characters.
			Title *string `json:"title,omitempty"`
		} `json:"polls,omitempty"`

		// TotalRecords The number of all records available across pages
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingPollCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Anonymous Allow meeting participants to answer poll questions anonymously.
		//
		// This value defaults to `false`.
		Anonymous *bool `json:"anonymous,omitempty"`

		// Id Meeting Poll ID
		Id *string `json:"id,omitempty"`

		// PollType The type of poll:
		// * `1` &mdash; Poll.
		// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
		// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
		//
		//  This value defaults to `1`.
		PollType *int `json:"poll_type,omitempty"`

		// Questions Information about the poll's questions.
		Questions *[]struct {
			// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
			// * For `short_answer` polls, a maximum of 500 characters.
			// * For `long_answer` polls, a maximum of 2,000 characters.
			AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

			// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
			AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

			// AnswerRequired Whether participants must answer the question:
			// * `true` &mdash; The participant must answer the question.
			// * `false` &mdash; The participant does not need to answer the question.
			//
			// **Note:**
			// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
			// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
			AnswerRequired *bool `json:"answer_required,omitempty"`

			// Answers The poll question's available answers. This field requires a **minimum** of two answers.
			//
			// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
			// * For `matching` polls, you can only provide a maximum of 16 answers.
			// * For `rank_order` polls, you can only provide a maximum of seven answers.
			Answers *[]string `json:"answers,omitempty"`

			// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
			// * `true` &mdash; The answer is case-sensitive.
			// * `false` &mdash; The answer is not case-sensitive.
			//
			// This value defaults to `false`.
			CaseSensitive *bool `json:"case_sensitive,omitempty"`

			// Name The poll question, up to 255 characters.
			//
			// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
			Name *string `json:"name,omitempty"`

			// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
			Prompts *[]struct {
				// PromptQuestion The question prompt's title.
				PromptQuestion *string `json:"prompt_question,omitempty"`

				// PromptRightAnswers The question prompt's correct answers:
				// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
				// * For `rank_order` polls, you can only provide one correct answer.
				PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
			} `json:"prompts,omitempty"`

			// RatingMaxLabel The high score label used for the `rating_max_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxLabel *string `json:"rating_max_label,omitempty"`

			// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxValue *int `json:"rating_max_value,omitempty"`

			// RatingMinLabel The low score label used for the `rating_min_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinLabel *string `json:"rating_min_label,omitempty"`

			// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinValue *int `json:"rating_min_value,omitempty"`

			// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
			//
			//  For `single` and `matching` polls, this field only accepts one answer.
			RightAnswers *[]string `json:"right_answers,omitempty"`

			// ShowAsDropdown Whether to display the radio selection as a drop-down box:
			// * `true` &mdash; Show as a drop-down box.
			// * `false` &mdash; Do not show as a drop-down box.
			//
			// This value defaults to `false`.
			ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

			// Type The poll's question and answer type:
			// * `single` &mdash; Single choice.
			// * `multiple` &mdash; Multiple choice.
			// * `matching` &mdash; Matching.
			// * `rank_order` &mdash; Rank order.
			// * `short_answer` &mdash; Short answer.
			// * `long_answer` &mdash; Long answer.
			// * `fill_in_the_blank` &mdash; Fill in the blank.
			// * `rating_scale` &mdash; Rating scale.
			Type *string `json:"type,omitempty"`
		} `json:"questions,omitempty"`

		// Status Status of the Meeting Poll:
		//  `notstart` - Poll not started
		//  `started` - Poll started
		//  `ended` - Poll ended
		//  `sharing` - Sharing poll results
		Status *string `json:"status,omitempty"`

		// Title The poll's title, up to 64 characters.
		Title *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingPollCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingPollCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingPollDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingPollDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingPollDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingPollGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Anonymous Allow meeting participants to answer poll questions anonymously.
		//
		// This value defaults to `false`.
		Anonymous *bool `json:"anonymous,omitempty"`

		// Id Meeting Poll ID
		Id *string `json:"id,omitempty"`

		// PollType The type of poll:
		// * `1` &mdash; Poll.
		// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
		// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
		//
		//  This value defaults to `1`.
		PollType *int `json:"poll_type,omitempty"`

		// Questions Information about the poll's questions.
		Questions *[]struct {
			// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
			// * For `short_answer` polls, a maximum of 500 characters.
			// * For `long_answer` polls, a maximum of 2,000 characters.
			AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

			// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
			AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

			// AnswerRequired Whether participants must answer the question:
			// * `true` &mdash; The participant must answer the question.
			// * `false` &mdash; The participant does not need to answer the question.
			//
			// **Note:**
			// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
			// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
			AnswerRequired *bool `json:"answer_required,omitempty"`

			// Answers The poll question's available answers. This field requires a **minimum** of two answers.
			//
			// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
			// * For `matching` polls, you can only provide a maximum of 16 answers.
			// * For `rank_order` polls, you can only provide a maximum of seven answers.
			Answers *[]string `json:"answers,omitempty"`

			// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
			// * `true` &mdash; The answer is case-sensitive.
			// * `false` &mdash; The answer is not case-sensitive.
			//
			// This value defaults to `false`.
			CaseSensitive *bool `json:"case_sensitive,omitempty"`

			// Name The poll question, up to 255 characters.
			//
			// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
			Name *string `json:"name,omitempty"`

			// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
			Prompts *[]struct {
				// PromptQuestion The question prompt's title.
				PromptQuestion *string `json:"prompt_question,omitempty"`

				// PromptRightAnswers The question prompt's correct answers:
				// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
				// * For `rank_order` polls, you can only provide one correct answer.
				PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
			} `json:"prompts,omitempty"`

			// RatingMaxLabel The high score label used for the `rating_max_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxLabel *string `json:"rating_max_label,omitempty"`

			// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMaxValue *int `json:"rating_max_value,omitempty"`

			// RatingMinLabel The low score label used for the `rating_min_value` field.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinLabel *string `json:"rating_min_label,omitempty"`

			// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
			//
			// This field only applies to the `rating_scale` poll.
			RatingMinValue *int `json:"rating_min_value,omitempty"`

			// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
			//
			//  For `single` and `matching` polls, this field only accepts one answer.
			RightAnswers *[]string `json:"right_answers,omitempty"`

			// ShowAsDropdown Whether to display the radio selection as a drop-down box:
			// * `true` &mdash; Show as a drop-down box.
			// * `false` &mdash; Do not show as a drop-down box.
			//
			// This value defaults to `false`.
			ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

			// Type The poll's question and answer type:
			// * `single` &mdash; Single choice.
			// * `multiple` &mdash; Multiple choice.
			// * `matching` &mdash; Matching.
			// * `rank_order` &mdash; Rank order.
			// * `short_answer` &mdash; Short answer.
			// * `long_answer` &mdash; Long answer.
			// * `fill_in_the_blank` &mdash; Fill in the blank.
			// * `rating_scale` &mdash; Rating scale.
			Type *string `json:"type,omitempty"`
		} `json:"questions,omitempty"`

		// Status Status of the Meeting Poll:
		//  `notstart` - Poll not started
		//  `started` - Poll started
		//  `ended` - Poll ended
		//  `sharing` - Sharing poll results
		Status *string `json:"status,omitempty"`

		// Title The poll's title, up to 64 characters.
		Title *string `json:"title,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingPollGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingPollGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingPollUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingPollUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingPollUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
		NextPageToken *string `json:"next_page_token,omitempty"`

		// PageCount The number of pages returned for the request made.
		PageCount *int `json:"page_count,omitempty"`

		// PageNumber **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
		// Deprecated:
		PageNumber *int `json:"page_number,omitempty"`

		// PageSize The number of records returned with a single API call.
		PageSize *int `json:"page_size,omitempty"`

		// Registrants List of registrant objects.
		Registrants *[]struct {
			// Address The registrant's address.
			Address *string `json:"address,omitempty"`

			// City The registrant's city.
			City *string `json:"city,omitempty"`

			// Comments The registrant's questions and comments.
			Comments *string `json:"comments,omitempty"`

			// Country The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
			Country *string `json:"country,omitempty"`

			// CreateTime The time at which the registrant registered.
			CreateTime *time.Time `json:"create_time,omitempty"`

			// CustomQuestions Information about custom questions.
			CustomQuestions *[]struct {
				// Title The title of the custom question.
				Title *string `json:"title,omitempty"`

				// Value The custom question's response value. This has a limit of 128 characters.
				Value *string `json:"value,omitempty"`
			} `json:"custom_questions,omitempty"`

			// Email The registrant's email address. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for return value details.
			Email openapi_types.Email `json:"email"`

			// FirstName The registrant's first name.
			FirstName string `json:"first_name"`

			// Id Registrant ID.
			Id *string `json:"id,omitempty"`

			// Industry The registrant's industry.
			Industry *string `json:"industry,omitempty"`

			// JobTitle The registrant's job title.
			JobTitle *string `json:"job_title,omitempty"`

			// JoinUrl The URL using which an approved registrant can join the meeting or webinar.
			JoinUrl *string `json:"join_url,omitempty"`

			// LastName The registrant's last name.
			LastName *string `json:"last_name,omitempty"`

			// NoOfEmployees The registrant's number of employees:
			// * `1-20`
			// * `21-50`
			// * `51-100`
			// * `101-250`
			// * `251-500`
			// * `501-1,000`
			// * `1,001-5,000`
			// * `5,001-10,000`
			// * `More than 10,000`
			NoOfEmployees *string `json:"no_of_employees,omitempty"`

			// Org The registrant's organization.
			Org *string `json:"org,omitempty"`

			// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
			ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

			// Phone The registrant's phone number.
			Phone *string `json:"phone,omitempty"`

			// PurchasingTimeFrame The registrant's purchasing time frame:
			// * `Within a month`
			// * `1-3 months`
			// * `4-6 months`
			// * `More than 6 months`
			// * `No timeframe`
			PurchasingTimeFrame *string `json:"purchasing_time_frame,omitempty"`

			// RoleInPurchaseProcess The registrant's role in the purchase process:
			// * `Decision Maker`
			// * `Evaluator/Recommender`
			// * `Influencer`
			// * `Not involved`
			RoleInPurchaseProcess *string `json:"role_in_purchase_process,omitempty"`

			// State The registrant's state or province.
			State *string `json:"state,omitempty"`

			// Status The status of the registrant's registration.
			//   `approved`: User has been successfully approved for the webinar.
			//   `pending`:  The registration is still pending.
			//   `denied`: User has been denied from joining the webinar.
			Status *string `json:"status,omitempty"`

			// Zip The registrant's ZIP or postal code.
			Zip *string `json:"zip,omitempty"`
		} `json:"registrants,omitempty"`

		// TotalRecords The total number of all the records available across pages.
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id The meeting ID.
		Id *int64 `json:"id,omitempty"`

		// JoinUrl The URL the registrant can use to join the meeting.
		//
		// The API will not return this field if the meeting was [created](/docs/api-reference/zoom-api/methods#operation/meetingCreate) with the `approval_type` field value of `1` (manual approval).
		JoinUrl *string `json:"join_url,omitempty"`

		// Occurrences Array of occurrence objects.
		Occurrences *[]struct {
			// Duration Duration.
			Duration *int `json:"duration,omitempty"`

			// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
			OccurrenceId *string `json:"occurrence_id,omitempty"`

			// StartTime Start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Status Occurrence status.
			Status *string `json:"status,omitempty"`
		} `json:"occurrences,omitempty"`

		// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
		ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

		// RegistrantId The registrant's ID.
		RegistrantId *string `json:"registrant_id,omitempty"`

		// StartTime The meeting's start time.
		StartTime *time.Time `json:"start_time,omitempty"`

		// Topic The meeting's topic.
		Topic *string `json:"topic,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantsQuestionsGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CustomQuestions Array of Registrant Custom Questions
		CustomQuestions *[]struct {
			// Answers Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
			Answers *[]string `json:"answers,omitempty"`

			// Required Indicates whether or not the custom question is required to be answered by participants or not.
			Required *bool `json:"required,omitempty"`

			// Title Title of the custom question.
			Title *string `json:"title,omitempty"`

			// Type Type of the question being asked.
			Type *string `json:"type,omitempty"`
		} `json:"custom_questions,omitempty"`

		// Questions Array of Registrant Questions
		Questions *[]struct {
			// FieldName Field name of the question.
			FieldName *string `json:"field_name,omitempty"`

			// Required Indicates whether or not the displayed fields are required to be filled out by registrants.
			Required *bool `json:"required,omitempty"`
		} `json:"questions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantsQuestionsGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantsQuestionsGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantQuestionUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantQuestionUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantQuestionUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingregistrantdeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingregistrantdeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingregistrantdeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingRegistrantGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Address The registrant's address.
		Address *string `json:"address,omitempty"`

		// City The registrant's city.
		City *string `json:"city,omitempty"`

		// Comments The registrant's questions and comments.
		Comments *string `json:"comments,omitempty"`

		// Country The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
		Country *string `json:"country,omitempty"`

		// CreateTime The registrant's registration date and time.
		CreateTime *time.Time `json:"create_time,omitempty"`

		// CustomQuestions Information about custom questions.
		CustomQuestions *[]struct {
			// Title The title of the custom question.
			Title *string `json:"title,omitempty"`

			// Value The custom question's response value. This has a limit of 128 characters.
			Value *string `json:"value,omitempty"`
		} `json:"custom_questions,omitempty"`

		// Email The registrant's email address. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for return value details.
		Email openapi_types.Email `json:"email"`

		// FirstName The registrant's first name.
		FirstName string  `json:"first_name"`
		Id        *string `json:"id,omitempty"`

		// Industry The registrant's industry.
		Industry *string `json:"industry,omitempty"`

		// JobTitle The registrant's job title.
		JobTitle *string `json:"job_title,omitempty"`

		// JoinUrl The URL with which the approved registrant can join the meeting.
		JoinUrl *string `json:"join_url,omitempty"`

		// LastName The registrant's last name.
		LastName *string `json:"last_name,omitempty"`

		// NoOfEmployees The registrant's number of employees:
		// * `1-20`
		// * `21-50`
		// * `51-100`
		// * `101-250`
		// * `251-500`
		// * `501-1,000`
		// * `1,001-5,000`
		// * `5,001-10,000`
		// * `More than 10,000`
		NoOfEmployees *string `json:"no_of_employees,omitempty"`

		// Org The registrant's organization.
		Org *string `json:"org,omitempty"`

		// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
		ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

		// Phone The registrant's phone number.
		Phone *string `json:"phone,omitempty"`

		// PurchasingTimeFrame The registrant's purchasing time frame:
		// * `Within a month`
		// * `1-3 months`
		// * `4-6 months`
		// * `More than 6 months`
		// * `No timeframe`
		PurchasingTimeFrame *string `json:"purchasing_time_frame,omitempty"`

		// RoleInPurchaseProcess The registrant's role in the purchase process:
		// * `Decision Maker`
		// * `Evaluator/Recommender`
		// * `Influencer`
		// * `Not involved`
		RoleInPurchaseProcess *string `json:"role_in_purchase_process,omitempty"`

		// State The registrant's state or province.
		State *string `json:"state,omitempty"`

		// Status The registrant's registration status:
		// * `approved` &mdash; The registrant is approved to join the meeting.
		// * `pending` &mdash; The registrant's registration is pending.
		// * `denied` &mdash; The registrant was declined to join the meeting.
		Status *string `json:"status,omitempty"`

		// Zip The registrant's ZIP or postal code.
		Zip *string `json:"zip,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingRegistrantGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingRegistrantGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSipDialingWithPasscodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExpireIn The number of seconds the encoded SIP URI is valid before it expires.
		ExpireIn *int64 `json:"expire_in,omitempty"`

		// PaidCrcPlanParticipant Whether the API caller has a CRC (Conference Room Connector) plan.
		PaidCrcPlanParticipant *bool `json:"paid_crc_plan_participant,omitempty"`

		// ParticipantIdentifierCode This value identifies the meeting participant. It is automatically embedded in the SIP URI if the API caller has a CRC (Conference Room Connector) plan.
		ParticipantIdentifierCode *string `json:"participant_identifier_code,omitempty"`

		// SipDialing The meeting's encoded SIP URI.
		SipDialing *string `json:"sip_dialing,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSipDialingWithPasscodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSipDialingWithPasscodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingSurveyDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingSurveyDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingSurveyDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingSurveyGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// CustomSurvey Information about the customized meeting survey.
		CustomSurvey *struct {
			// Anonymous Allow participants to anonymously answer survey questions.
			//
			//  This value defaults to `true`.
			Anonymous *bool `json:"anonymous,omitempty"`

			// Questions Information about the meeting survey's questions.
			Questions *[]struct {
				// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
				AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

				// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
				AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

				// AnswerRequired Whether participants must answer the question:
				// * `true` &mdash; The participant must answer the question.
				// * `false` &mdash; The participant does not need to answer the question.
				//
				//  This value defaults to `false`.
				AnswerRequired *bool `json:"answer_required,omitempty"`

				// Answers The survey question's available answers. This field requires a **minimum** of two answers.
				//
				// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
				// * For `matching` polls, you can only provide a maximum of 16 answers.
				// * For `rank_order` polls, you can only provide a maximum of seven answers.
				Answers *[]string `json:"answers,omitempty"`

				// Name The survey question, up to 255 characters.
				Name *string `json:"name,omitempty"`

				// RatingMaxLabel The high score label used for the `rating_max_value` field.
				//
				//  This field only applies to the `rating_scale` survey.
				RatingMaxLabel *string `json:"rating_max_label,omitempty"`

				// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
				//
				//  This field only applies to the `rating_scale` survey.
				RatingMaxValue *int `json:"rating_max_value,omitempty"`

				// RatingMinLabel The low score label used for the `rating_min_value` field.
				//
				// T his field only applies to the `rating_scale` survey.
				RatingMinLabel *string `json:"rating_min_label,omitempty"`

				// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
				//
				//  This field only applies to the `rating_scale` survey.
				RatingMinValue *int `json:"rating_min_value,omitempty"`

				// ShowAsDropdown Display the radio selection as a drop-down box:
				// * `true` &mdash; Show as a drop-down box.
				// * `false` &mdash; Do not show as a drop-down box.
				//
				//  This value defaults to `false`.
				ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

				// Type The survey's question and answer type:
				// * `single` &mdash; Single choice.
				// * `multiple` &mdash; Multiple choice.
				// * `rating_scale` &mdash; Rating scale.
				// * `long_answer` &mdash; Long answer.
				Type *string `json:"type,omitempty"`
			} `json:"questions,omitempty"`
		} `json:"custom_survey,omitempty"`

		// ShowInTheBrowser Whether the **Show in the browser when the meeting ends** option is enabled:
		// * `true` &mdash; Enabled.
		// * `false` &mdash; Disabled.
		//
		//  This value defaults to `true`.
		ShowInTheBrowser *bool `json:"show_in_the_browser,omitempty"`

		// ThirdPartySurvey The link to the third party meeting survey.
		ThirdPartySurvey *string `json:"third_party_survey,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingSurveyGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingSurveyGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingSurveyUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r MeetingSurveyUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingSurveyUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token The generated meeting token.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PastMeetingDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Dept The meeting host's department.
		Dept *string `json:"dept,omitempty"`

		// Duration The meeting's duration, in minutes.
		Duration *int `json:"duration,omitempty"`

		// EndTime The meeting's end date and time.
		EndTime *time.Time `json:"end_time,omitempty"`

		// HostId The host's ID.
		HostId *string `json:"host_id,omitempty"`

		// Id The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID).
		Id *int64 `json:"id,omitempty"`

		// ParticipantsCount The number of meeting participants.
		ParticipantsCount *int `json:"participants_count,omitempty"`

		// Source Whether the meeting was created directly through Zoom or via an API request:
		// * If the meeting was created via an OAuth app, this field returns the OAuth app's name.
		// * If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.
		Source *string `json:"source,omitempty"`

		// StartTime The meeting's start date and time.
		StartTime *time.Time `json:"start_time,omitempty"`

		// Topic The meeting's topic.
		Topic *string `json:"topic,omitempty"`

		// TotalMinutes The total number of minutes attended by the meeting's host and participants.
		TotalMinutes *int `json:"total_minutes,omitempty"`

		// Type The meeting type:
		// * `0` &mdash; A prescheduled meeting.
		// * `1` &mdash; An instant meeting.
		// * `2` &mdash; A scheduled meeting.
		// * `3` &mdash; A recurring meeting with no fixed time.
		// * `4` &mdash; A [personal meeting room](https://support.zoom.us/hc/en-us/articles/201362843).
		// * `7` &mdash; A [PAC (Personal Audio Conference)](https://support.zoom.us/hc/en-us/articles/205172455-Hosting-a-Personal-Audio-Conference-PAC-meeting) meeting.
		// * `8` &mdash; A recurring meeting with a fixed time.
		Type *int `json:"type,omitempty"`

		// UserEmail The user's email address.
		UserEmail *openapi_types.Email `json:"user_email,omitempty"`

		// UserName The user's display name.
		UserName *string `json:"user_name,omitempty"`

		// Uuid The meeting's UUID. You **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) this value if the meeting UUID begins with a `/` character or contains the `//` character.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PastMeetingDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PastMeetingDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PastMeetingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Meetings List of ended meeting instances.
		Meetings *[]struct {
			// StartTime Start time
			StartTime *time.Time `json:"start_time,omitempty"`

			// Uuid Meeting UUID. Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
			//
			Uuid *string `json:"uuid,omitempty"`
		} `json:"meetings,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PastMeetingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PastMeetingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PastMeetingParticipantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
		NextPageToken *string `json:"next_page_token,omitempty"`

		// PageCount The number of pages returned for the request made.
		PageCount *int `json:"page_count,omitempty"`

		// PageSize The number of records returned within a single API call.
		PageSize *int `json:"page_size,omitempty"`

		// Participants The Array of meeting participant objects.
		Participants *[]struct {
			// Duration The participant's duration.
			Duration *int `json:"duration,omitempty"`

			// Failover Indicates if failover happened during the meeting.
			Failover *bool `json:"failover,omitempty"`

			// Id Universal unique identifier of the participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
			Id *string `json:"id,omitempty"`

			// JoinTime The participant's join time.
			JoinTime *time.Time `json:"join_time,omitempty"`

			// LeaveTime The participant's leave time.
			LeaveTime *time.Time `json:"leave_time,omitempty"`

			// Name The participant's display name.
			Name *string `json:"name,omitempty"`

			// RegistrantId The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter.
			//
			// This field does not return if the `type` query parameter is the `live` value.
			RegistrantId *string `json:"registrant_id,omitempty"`

			// Status The participant's status.
			// * `in_meeting` &mdash; In a meeting.
			// * `in_waiting_room` &mdash; In a waiting room.
			Status *string `json:"status,omitempty"`

			// UserEmail The email address of the user. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
			UserEmail *string `json:"user_email,omitempty"`

			// UserId The participant's ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.
			UserId *string `json:"user_id,omitempty"`
		} `json:"participants,omitempty"`

		// TotalRecords The number of all records available across pages.
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PastMeetingParticipantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PastMeetingParticipantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPastMeetingPollsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
		Id        *int64 `json:"id,omitempty"`
		Questions *[]struct {
			// Email Email address of the user who submitted answers to the poll. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
			Email *string `json:"email,omitempty"`

			// Name Name of the user who submitted answers to the poll. If &quot;anonymous&quot; option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be &quot;Anonymous Attendee&quot;.
			Name            *string `json:"name,omitempty"`
			QuestionDetails *[]struct {
				// Answer Answer submitted by the user.
				Answer *string `json:"answer,omitempty"`

				// DateTime Date and time at which the answer to the poll was submitted.
				DateTime *time.Time `json:"date_time,omitempty"`

				// PollingId Unique identifier of the poll.
				PollingId *string `json:"polling_id,omitempty"`

				// Question Question asked during the poll.
				Question *string `json:"question,omitempty"`
			} `json:"question_details,omitempty"`
		} `json:"questions,omitempty"`

		// StartTime The start time of the meeting.
		StartTime *time.Time `json:"start_time,omitempty"`

		// Uuid Meeting UUID.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPastMeetingPollsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPastMeetingPollsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPastMeetingQAResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
		Id        *int64 `json:"id,omitempty"`
		Questions *[]struct {
			// Email The user's email address. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
			Email *string `json:"email,omitempty"`

			// Name The user's name. If &quot;anonymous&quot; option is enabled for the Q&amp;A, the participant's information is be kept anonymous and the value of `name` field is &quot;Anonymous Attendee&quot;.
			Name            *string `json:"name,omitempty"`
			QuestionDetails *[]struct {
				// Answer An answer submitted for the question. The value is 'live answered' if this is a live answer.
				Answer *string `json:"answer,omitempty"`

				// Question A question asked during the Q&amp;A.
				Question *string `json:"question,omitempty"`
			} `json:"question_details,omitempty"`
		} `json:"questions,omitempty"`

		// StartTime The meeting's start time.
		StartTime *time.Time `json:"start_time,omitempty"`

		// Uuid Meeting UUID.
		Uuid *string `json:"uuid,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPastMeetingQAResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPastMeetingQAResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UsersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
		NextPageToken *string `json:"next_page_token,omitempty"`

		// PageCount The number of pages returned for the request made.
		PageCount *int `json:"page_count,omitempty"`

		// PageNumber The page number of the current results.
		PageNumber *int `json:"page_number,omitempty"`

		// PageSize The number of records returned within a single API call.
		PageSize *int `json:"page_size,omitempty"`

		// TotalRecords The total number of all the records available across pages.
		TotalRecords *int `json:"total_records,omitempty"`

		// Users Information about the users.
		Users *[]struct {
			// CreatedAt The date and time at which this user's latest login type was created.
			// Deprecated:
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// CustomAttributes Information about the user's custom attributes.
			//
			// This field is **only** returned if users are assigned custom attributes and you provided the `custom_attributes` value for the `include_fields` query parameter in the API request.
			CustomAttributes *[]struct {
				// Key The custom attribute's unique ID.
				Key *string `json:"key,omitempty"`

				// Name The custom attribute's name.
				Name *string `json:"name,omitempty"`

				// Value The custom attribute's value.
				Value *string `json:"value,omitempty"`
			} `json:"custom_attributes,omitempty"`

			// Dept The user's department.
			Dept *string `json:"dept,omitempty"`

			// DisplayName The user's display name.
			DisplayName *string `json:"display_name,omitempty"`

			// Email The user's email address.
			Email openapi_types.Email `json:"email"`

			// EmployeeUniqueId The employee's unique ID. The this field only returns when:
			// * SAML single sign-on (SSO) is enabled.
			// * The `login_type` value is `101` (SSO).
			EmployeeUniqueId *string `json:"employee_unique_id,omitempty"`

			// FirstName The user's first name.
			FirstName *string `json:"first_name,omitempty"`

			// GroupIds The IDs of groups where the user is a member.
			GroupIds *[]string `json:"group_ids,omitempty"`

			// Id The user's ID.
			//
			// The API does **not** return this value for users with the `pending` status.
			Id *string `json:"id,omitempty"`

			// ImGroupIds The IDs of IM directory groups where the user is a member.
			ImGroupIds *[]string `json:"im_group_ids,omitempty"`

			// LastClientVersion The last client version that user used to log in.
			LastClientVersion *string `json:"last_client_version,omitempty"`

			// LastLoginTime The user's last login time. This field has a three-day buffer period.
			//
			// For example, if user first logged in on `2020-01-01` and then logged out and logged in on `2020-01-02`, this value will still reflect the login time of `2020-01-01`. However, if the user logs in on `2020-01-04`, the value of this field will reflect the corresponding login time since it exceeds the three-day buffer period.
			LastLoginTime *time.Time `json:"last_login_time,omitempty"`

			// LastName The user's last name.
			LastName *string `json:"last_name,omitempty"`

			// PlanUnitedType This field is returned if the user is enrolled in the [Zoom United](https://zoom.us/pricing/zoom-bundles) plan. The license option:
			// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
			// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
			// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
			// * `8` &mdash; Zoom United Pro-United with Global Select.
			// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
			// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
			// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
			// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
			// * `256` &mdash; Zoom United Biz-United with Global Select.
			// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
			// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
			// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
			// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
			// * `8192` &mdash; Zoom United Ent-United with Global Select.
			// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
			// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
			// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
			// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
			PlanUnitedType *string `json:"plan_united_type,omitempty"`

			// Pmi The user's [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi).
			Pmi *int64 `json:"pmi,omitempty"`

			// RoleId The unique ID of the user's assigned [role](/docs/api-reference/zoom-api/methods#operation/roles).
			RoleId *string `json:"role_id,omitempty"`

			// Status The user's status:
			// * `active` &mdash; An active user.
			// * `inactive` &mdash; A deactivated user.
			// * `pending` &mdash; A pending user.
			Status *string `json:"status,omitempty"`

			// Timezone The user's timezone.
			Timezone *string `json:"timezone,omitempty"`

			// Type The user's assigned plan type:
			// * `1` &mdash; Basic.
			// * `2` &mdash; Licensed.
			// * `99` &mdash; None (this can only be set with `ssoCreate`).
			Type int `json:"type"`

			// UserCreatedAt The date and time at which this user was created.
			UserCreatedAt *time.Time `json:"user_created_at,omitempty"`

			// Verified Display whether the user's email address for the Zoom account is verified:
			// * `1` &mdash; A verified user email.
			// * `0` &mdash; The user's email **not** verified.
			Verified *int `json:"verified,omitempty"`
		} `json:"users,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Email User email address.
		Email *string `json:"email,omitempty"`

		// FirstName The user's first name.
		FirstName *string `json:"first_name,omitempty"`

		// Id User ID.
		Id *string `json:"id,omitempty"`

		// LastName The user's last name.
		LastName *string `json:"last_name,omitempty"`

		// Type User type.
		//  `1` - Basic.
		//  `2` - Licensed.
		//  `99` - None (this can only be set with `ssoCreate`).
		Type *int `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ExistedEmail Indicates whether or not the email already exists in Zoom.
		ExistedEmail *bool `json:"existed_email,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUpdateFeatureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// FailDetails The details why these users' feature was not updated successfully.
		FailDetails *[]struct {
			// Reason The reason why the feature for these users was not updated successfully.
			Reason *string `json:"reason,omitempty"`

			// UserIds The IDs of users for whom the feature was not updated successfully.
			UserIds *[]string `json:"user_ids,omitempty"`
		} `json:"fail_details,omitempty"`

		// SuccessUserIds The IDs of users for whom the feature was updated successfully
		SuccessUserIds *[]string `json:"success_user_ids,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BulkUpdateFeatureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUpdateFeatureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserZakResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token The user's Zoom Access Key (ZAK).
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserZakResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserZakResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BasicUsersCount The number of basic users.
		BasicUsersCount *int `json:"basic_users_count,omitempty"`

		// JoinOnlyUsersCount The number of users without licenses.
		JoinOnlyUsersCount *int `json:"join_only_users_count,omitempty"`

		// LicensedUsersCount The number of licensed users.
		LicensedUsersCount *int `json:"licensed_users_count,omitempty"`

		// OnPremUsersCount The number of on-prem users.
		OnPremUsersCount *int `json:"on_prem_users_count,omitempty"`

		// PendingUsersCount The number of users with a pending activation meeting license.
		PendingUsersCount *int `json:"pending_users_count,omitempty"`

		// RoomUsersCount The number of Zoom rooms.
		RoomUsersCount *int `json:"room_users_count,omitempty"`

		// TotalUsersCount The total number of `licensed_users_count`, `basic_users_count`, `on_prem_users_count`, `join_only_users_count` and `room_users_count`.
		TotalUsersCount *int `json:"total_users_count,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserVanityNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Existed If `true`, it indicates that the personal meeting room with the given name exists.
		//   `false` - The room name does not exist.
		Existed *bool `json:"existed,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserVanityNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserVanityNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AccountId User's account ID.
		AccountId *string `json:"account_id,omitempty"`

		// AccountNumber The user's account number.
		AccountNumber *int64 `json:"account_number,omitempty"`

		// Cluster The user's cluster.
		Cluster *string `json:"cluster,omitempty"`

		// CmsUserId CMS ID of user, only enabled for Kaltura integration.
		CmsUserId *string `json:"cms_user_id,omitempty"`

		// Company User's company.
		Company *string `json:"company,omitempty"`

		// CreatedAt The date and time at which this user's latest login type was created.
		// Deprecated:
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// CustomAttributes Custom attribute(s) that have been assigned to the user.
		CustomAttributes *[]struct {
			// Key Identifier for the custom attribute.
			Key *string `json:"key,omitempty"`

			// Name Name of the custom attribute.
			Name *string `json:"name,omitempty"`

			// Value Value of the custom attribute.
			Value *string `json:"value,omitempty"`
		} `json:"custom_attributes,omitempty"`

		// Dept Department.
		Dept *string `json:"dept,omitempty"`

		// DisplayName User's display name.
		DisplayName *string `json:"display_name,omitempty"`

		// Email User's email address.
		Email string `json:"email"`

		// EmployeeUniqueId The employee's unique ID. This field only returns when:
		// * SAML single sign-on (SSO) is enabled.
		// * The `login_type` value is `101` (SSO).
		EmployeeUniqueId *string `json:"employee_unique_id,omitempty"`

		// FirstName User's first name.
		FirstName *string `json:"first_name,omitempty"`

		// GroupIds IDs of the web groups user belongs to.
		GroupIds *[]string `json:"group_ids,omitempty"`

		// Id User ID.
		Id *string `json:"id,omitempty"`

		// ImGroupIds IM IDs of the groups user belongs to.
		ImGroupIds *[]string `json:"im_group_ids,omitempty"`
		Jid        *string   `json:"jid,omitempty"`

		// JobTitle User's job title.
		JobTitle *string `json:"job_title,omitempty"`

		// Language Default language for the Zoom Web Portal.
		Language *string `json:"language,omitempty"`

		// LastClientVersion User last login client version.
		LastClientVersion *string `json:"last_client_version,omitempty"`

		// LastLoginTime User last login time.
		LastLoginTime *time.Time `json:"last_login_time,omitempty"`

		// LastName User's last name.
		LastName *string `json:"last_name,omitempty"`

		// Location User's location.
		Location *string `json:"location,omitempty"`

		// LoginTypes The user's login method:
		//
		// `0` &mdash; Facebook OAuth&lt;/br&gt;`1` &mdash; Google OAuth&lt;/br&gt;`24` &mdash; Apple OAuth&lt;/br&gt;`27` &mdash; Microsoft OAuth&lt;/br&gt;`97` &mdash; Mobile device&lt;/br&gt;`98` &mdash; RingCentral OAuth&lt;/br&gt;`99` &mdash; API user&lt;/br&gt;`100` &mdash; Zoom Work email&lt;/br&gt;`101` &mdash; Single Sign-On (SSO)
		//
		// The following login methods are only available in China:
		//
		// `11` &mdash; Phone number&lt;/br&gt;`21` &mdash; WeChat&lt;/br&gt;`23` &mdash; Alipay
		LoginTypes *[]int `json:"login_types,omitempty"`

		// Manager The manager for the user.
		Manager *openapi_types.Email `json:"manager,omitempty"`

		// PersonalMeetingUrl User's personal meeting url.
		PersonalMeetingUrl *string `json:"personal_meeting_url,omitempty"`

		// PhoneCountry **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field.
		//   User's country for Company Phone Number.
		// Deprecated:
		PhoneCountry *string `json:"phone_country,omitempty"`

		// PhoneNumber **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field.
		//   User's phone number.
		// Deprecated:
		PhoneNumber  *string `json:"phone_number,omitempty"`
		PhoneNumbers *[]struct {
			// Code The phone number's country code. For example, for United States phone numbers, this will be a `+1` value.
			Code *string `json:"code,omitempty"`

			// Country The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). For example, if the phone number provided in the `number` field is a Brazil-based number, this will be the `BR` value.
			Country *string `json:"country,omitempty"`

			// Label The phone number's label:
			// * `Mobile`
			// * `Office`
			// * `Home`
			//  * `Fax`
			Label *string `json:"label,omitempty"`

			// Number The user's phone number.
			Number *string `json:"number,omitempty"`

			// Verified Whether Zoom has verified the phone number.
			Verified *bool `json:"verified,omitempty"`
		} `json:"phone_numbers,omitempty"`

		// PicUrl The URL for user's profile picture.
		PicUrl *string `json:"pic_url,omitempty"`

		// PlanUnitedType This field is returned if the user is enrolled in the [Zoom United](https://zoom.us/pricing/zoom-bundles) plan. The license option:
		// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
		// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
		// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
		// * `8` &mdash; Zoom United Pro-United with Global Select.
		// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
		// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
		// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
		// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
		// * `256` &mdash; Zoom United Biz-United with Global Select.
		// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
		// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
		// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
		// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
		// * `8192` &mdash; Zoom United Ent-United with Global Select.
		// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
		// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
		// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
		// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
		PlanUnitedType *string `json:"plan_united_type,omitempty"`

		// Pmi [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi).
		Pmi *int64 `json:"pmi,omitempty"`

		// Pronouns The user's pronouns.
		Pronouns *string `json:"pronouns,omitempty"`

		// PronounsOption The user's display pronouns setting:
		// * `1` &mdash; Ask the user every time they join meetings and webinars.
		// * `2` &mdash; Always display pronouns in meetings and webinars.
		// * `3` &mdash; Do not display pronouns in meetings and webinars.
		PronounsOption *int `json:"pronouns_option,omitempty"`

		// RoleId Unique identifier of the [role](/docs/api-reference/zoom-api/methods#operation/roles) assigned to the user.
		RoleId *string `json:"role_id,omitempty"`

		// RoleName User's [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) name.
		RoleName *string `json:"role_name,omitempty"`

		// Status Status of user's account.
		Status *string `json:"status,omitempty"`

		// Timezone The time zone of the user.
		Timezone *string `json:"timezone,omitempty"`

		// Type User's plan type:
		//  `1` - Basic.
		//  `2` - Licensed.
		//  `99` - None (this can only be set with `ssoCreate`).
		Type int `json:"type"`

		// UsePmi Displays `true` if user has enabled a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi) for instant meetings, `false` otherwise.
		UsePmi *bool `json:"use_pmi,omitempty"`

		// UserCreatedAt The date and time at which this user was created.
		UserCreatedAt *time.Time `json:"user_created_at,omitempty"`

		// VanityUrl Personal meeting room URL, if the user has one.
		VanityUrl *string `json:"vanity_url,omitempty"`

		// Verified Displays whether user is verified or not.
		//
		// `1` - Account verified.
		//
		// `0` - Account not verified.
		Verified *int `json:"verified,omitempty"`

		// ZoomOneType The user's Zoom One plan option.
		//  `4` - Zoom One Enterprise.
		//  `8` - Zoom One Enterprise Plus.
		//  `16` - Zoom One Business Plus with US/CA Unlimited.
		//  `32` - Zoom One Business Plus with UK/IR Unlimited.
		//  `64` - Zoom One Business Plus with AU/NZ Unlimited.
		//  `128` - Zoom One Business Plus with Japan Unlimited.
		//  `33554432` - Zoom One Business Plus with Global Select.
		//
		//  The Zoom One plan option for Gov accounts:
		//  `4` - Zoom One Enterprise.
		//  `8` - Zoom One Enterprise Plus.
		//  `16` - Zoom One Business Plus.
		ZoomOneType *int `json:"zoom_one_type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SwitchAUsersAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SwitchAUsersAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SwitchAUsersAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserAssistantsDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserAssistantsDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserAssistantsDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserAssistantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Assistants List of User's assistants.
		Assistants *[]struct {
			// Email Assistant's email address.
			Email *string `json:"email,omitempty"`

			// Id Assistant's user ID.
			Id *string `json:"id,omitempty"`
		} `json:"assistants,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserAssistantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserAssistantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserAssistantCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		AddAt *time.Time `json:"add_at,omitempty"`

		// Ids User ID.
		Ids *string `json:"ids,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserAssistantCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserAssistantCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserAssistantDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserAssistantDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserAssistantDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCollaborationDevicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CollaborationDevices *[]struct {
			// DeviceName Name of the Personal Zoom Room's device.
			DeviceName *string `json:"device_name,omitempty"`

			// Id Unique identifier of the device.
			Id *string `json:"id,omitempty"`

			// RoomName Name of the Personal Zoom Room.
			RoomName *string `json:"room_name,omitempty"`

			// RoomUserId Unique Identifier of the Zoom Room.
			RoomUserId *string `json:"room_user_id,omitempty"`

			// Status Status of the device. The value can be either `Online` or `Offline`.
			Status *string `json:"status,omitempty"`
		} `json:"collaboration_devices,omitempty"`

		// TotalRecords Total number of records returned.
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCollaborationDevicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollaborationDevicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollaborationDeviceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DeviceName Name of the Personal Zoom Room's device.
		DeviceName *string `json:"device_name,omitempty"`

		// Id Unique identifier of the device.
		Id *string `json:"id,omitempty"`

		// RoomName Name of the Personal Zoom Room.
		RoomName *string `json:"room_name,omitempty"`

		// RoomUserId Unique Identifier of the Zoom Room.
		RoomUserId *string `json:"room_user_id,omitempty"`

		// Status Status of the device. The value can be either `Online` or `Offline`.
		Status *string `json:"status,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCollaborationDeviceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollaborationDeviceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserEmailUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserEmailUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserEmailUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListMeetingTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Templates *[]struct {
			// Id The template ID.
			Id *string `json:"id,omitempty"`

			// Name The template name.
			Name *string `json:"name,omitempty"`

			// Type The template type:
			//
			// `1`: Meeting template
			//
			// `2`: Admin meeting template
			Type *int `json:"type,omitempty"`
		} `json:"templates,omitempty"`

		// TotalRecords Total records found for this request.
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListMeetingTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListMeetingTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingTemplateCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id The template ID.
		Id *string `json:"id,omitempty"`

		// Name The template name.
		Name *string `json:"name,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingTemplateCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingTemplateCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Meetings List of Meeting objects.
		Meetings *[]struct {
			// Agenda Meeting description. The length of agenda gets truncated to 250 characters when you list all meetings for a user. To view the complete agenda of a meeting, retrieve details for a single meeting, use the [**Get a meeting**](/docs/api-reference/zoom-api/methods#operation/meeting) API.
			Agenda *string `json:"agenda,omitempty"`

			// CreatedAt Time of creation.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Duration Meeting duration.
			Duration *int `json:"duration,omitempty"`

			// HostId ID of the user who is set as the host of the meeting.
			HostId *string `json:"host_id,omitempty"`

			// Id Meeting ID - also known as the meeting number in long (int64) format.
			Id *int64 `json:"id,omitempty"`

			// JoinUrl URL using which participants can join a meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// Pmi [Personal meeting ID](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#understanding-personal-meeting-id-pmi). This field is only returned if PMI was used to schedule the meeting.
			Pmi *string `json:"pmi,omitempty"`

			// StartTime Meeting start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Timezone Timezone to format the meeting start time.
			Timezone *string `json:"timezone,omitempty"`

			// Topic Meeting topic.
			Topic *string `json:"topic,omitempty"`

			// Type Meeting Types:
			//  `1` - Instant meeting.
			//  `2` - Scheduled meeting.
			//  `3` - Recurring meeting with no fixed time.
			//  `8` - Recurring meeting with fixed time.
			Type *int `json:"type,omitempty"`

			// Uuid Unique Meeting ID. Each meeting instance will generate its own Meeting UUID.
			Uuid *string `json:"uuid,omitempty"`
		} `json:"meetings,omitempty"`

		// NextPageToken Use the next page token to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
		NextPageToken *string `json:"next_page_token,omitempty"`

		// PageCount The number of pages returned for the request made.
		PageCount *int `json:"page_count,omitempty"`

		// PageNumber The page number of the current results.
		PageNumber *int `json:"page_number,omitempty"`

		// PageSize The number of records returned with a single API call.
		PageSize *int `json:"page_size,omitempty"`

		// TotalRecords The total number of all the records available across pages.
		TotalRecords *int `json:"total_records,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type MeetingCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Agenda Agenda
		Agenda *string `json:"agenda,omitempty"`

		// AssistantId The ID of the user who scheduled this meeting on behalf of the host.
		AssistantId *string `json:"assistant_id,omitempty"`

		// ChatJoinUrl The URL to join the chat.
		ChatJoinUrl *string `json:"chat_join_url,omitempty"`

		// CreatedAt The date and time at which this meeting was created.
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Duration Meeting duration.
		Duration *int `json:"duration,omitempty"`

		// H323Password H.323/SIP room system password
		H323Password *string `json:"h323_password,omitempty"`

		// HostEmail Email address of the meeting host.
		HostEmail *openapi_types.Email `json:"host_email,omitempty"`

		// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
		Id *int64 `json:"id,omitempty"`

		// JoinUrl URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
		JoinUrl *string `json:"join_url,omitempty"`

		// Occurrences Array of occurrence objects.
		Occurrences *[]struct {
			// Duration Duration.
			Duration *int `json:"duration,omitempty"`

			// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
			OccurrenceId *string `json:"occurrence_id,omitempty"`

			// StartTime Start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Status Occurrence status.
			Status *string `json:"status,omitempty"`
		} `json:"occurrences,omitempty"`

		// Password Meeting password. Password may only contain the following characters: `[a-z A-Z 0-9 @ - _ * !]`
		//
		// If &quot;Require a password when scheduling new meetings&quot; setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the password field will be autogenerated in the response even if it is not provided in the API request.
		//
		//
		Password *string `json:"password,omitempty"`

		// Pmi [Personal Meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
		Pmi *string `json:"pmi,omitempty"`

		// PreSchedule Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time):
		// * `true` &mdash; A GSuite prescheduled meeting.
		// * `false` &mdash; A regular meeting.
		PreSchedule *bool `json:"pre_schedule,omitempty"`

		// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
		Recurrence *struct {
			// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
			EndDateTime *time.Time `json:"end_date_time,omitempty"`

			// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
			EndTimes *int `json:"end_times,omitempty"`

			// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
			//
			// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
			MonthlyDay *int `json:"monthly_day,omitempty"`

			// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
			//  `-1` - Last week of the month.
			//  `1` - First week of the month.
			//  `2` - Second week of the month.
			//  `3` - Third week of the month.
			//  `4` - Fourth week of the month.
			MonthlyWeek *int `json:"monthly_week,omitempty"`

			// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
			//
			//
			//  `1` - Sunday.
			//  `2` - Monday.
			//  `3` - Tuesday.
			//  `4` -  Wednesday.
			//  `5` - Thursday.
			//  `6` - Friday.
			//  `7` - Saturday.
			MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

			// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
			//
			// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
			//
			RepeatInterval *int `json:"repeat_interval,omitempty"`

			// Type Recurrence meeting types:
			//  `1` - Daily.
			//  `2` - Weekly.
			//  `3` - Monthly.
			Type int `json:"type"`

			// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
			//
			//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
			//
			//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
			//
			//
			//  `1`  - Sunday.
			//  `2` - Monday.
			//  `3` - Tuesday.
			//  `4` -  Wednesday.
			//  `5` -  Thursday.
			//  `6` - Friday.
			//  `7` - Saturday.
			WeeklyDays *string `json:"weekly_days,omitempty"`
		} `json:"recurrence,omitempty"`

		// RegistrationUrl URL using which registrants can register for a meeting. This field is only returned for meetings that have enabled registration.
		RegistrationUrl *string `json:"registration_url,omitempty"`

		// Settings Meeting settings.
		Settings *struct {
			// AllowMultipleDevices Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
			AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

			// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
			AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

			// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
			AlternativeHosts *string `json:"alternative_hosts,omitempty"`

			// AlternativeHostsEmailNotification Flag to determine whether to send email notifications to alternative hosts, default value is true.
			AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

			// ApprovalType Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**
			//
			//
			//
			// `0` - Automatically approve.
			//  `1` - Manually approve.
			//  `2` - No registration required.
			ApprovalType *int `json:"approval_type,omitempty"`

			// ApprovedOrDeniedCountriesOrRegions Approve or block users from specific regions/countries from joining this meeting.
			ApprovedOrDeniedCountriesOrRegions *struct {
				// ApprovedList List of countries/regions from where participants can join this meeting.
				ApprovedList *[]string `json:"approved_list,omitempty"`

				// DeniedList List of countries/regions from where participants can not join this meeting.
				DeniedList *[]string `json:"denied_list,omitempty"`

				// Enable `true`: Setting enabled to either allow users or block users from specific regions to join your meetings.
				//
				//
				// `false`: Setting disabled.
				Enable *bool `json:"enable,omitempty"`

				// Method Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.
				//
				//
				// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.
				//
				//
				// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
				Method *string `json:"method,omitempty"`
			} `json:"approved_or_denied_countries_or_regions,omitempty"`

			// Audio Determine how participants can join the audio portion of the meeting.
			//  `both` - Both Telephony and VoIP.
			//  `telephony` - Telephony only.
			//  `voip` - VoIP only.
			//  `thirdParty` - Third party audio conference.
			Audio *string `json:"audio,omitempty"`

			// AudioConferenceInfo Third party audio conference info.
			AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

			// AuthenticationDomains If user has configured [&quot;Sign Into Zoom with Specified Domains&quot;](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
			AuthenticationDomains *string `json:"authentication_domains,omitempty"`

			// AuthenticationException The participants added here will receive unique meeting invite links and bypass authentication.
			AuthenticationException *[]struct {
				// Email Email address of the participant.
				Email *openapi_types.Email `json:"email,omitempty"`

				// JoinUrl URL for participants to join the meeting
				JoinUrl *string `json:"join_url,omitempty"`

				// Name Name of the participant.
				Name *string `json:"name,omitempty"`
			} `json:"authentication_exception,omitempty"`

			// AuthenticationName Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
			AuthenticationName *string `json:"authentication_name,omitempty"`

			// AuthenticationOption Meeting authentication option id.
			AuthenticationOption *string `json:"authentication_option,omitempty"`

			// AutoRecording Automatic recording:
			//  `local` - Record on local.
			//  `cloud` -  Record on cloud.
			//  `none` - Disabled.
			AutoRecording *string `json:"auto_recording,omitempty"`

			// BreakoutRoom Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
			BreakoutRoom *struct {
				// Enable Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
				Enable *bool `json:"enable,omitempty"`

				// Rooms Create room(s).
				Rooms *[]struct {
					// Name Name of the breakout room.
					Name *string `json:"name,omitempty"`

					// Participants Email addresses of the participants who are to be assigned to the breakout room.
					Participants *[]string `json:"participants,omitempty"`
				} `json:"rooms,omitempty"`
			} `json:"breakout_room,omitempty"`

			// CalendarType Indicates the type of calendar integration used to schedule the meeting:
			// * `1` &mdash; [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
			// * `2` &mdash; [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
			//
			// Works with the `private_meeting` field to determine whether to share details of meetings or not.
			CalendarType *int `json:"calendar_type,omitempty"`

			// CloseRegistration Close registration after event date
			CloseRegistration *bool `json:"close_registration,omitempty"`

			// CnMeeting Host meeting in China.
			// Deprecated:
			CnMeeting *bool `json:"cn_meeting,omitempty"`

			// ContactEmail Contact email for registration
			ContactEmail *string `json:"contact_email,omitempty"`

			// ContactName Contact name for registration
			ContactName *string `json:"contact_name,omitempty"`

			// CustomKeys Custom keys and values assigned to the meeting.
			CustomKeys *[]struct {
				// Key Custom key associated with the user.
				Key *string `json:"key,omitempty"`

				// Value Value of the custom key associated with the user.
				Value *string `json:"value,omitempty"`
			} `json:"custom_keys,omitempty"`

			// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
			EmailNotification *bool `json:"email_notification,omitempty"`

			// EncryptionType Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.
			//
			//  The value of this field can be one of the following:
			//
			// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option.
			//
			//
			// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
			EncryptionType *string `json:"encryption_type,omitempty"`

			// EnforceLogin Only signed in users can join this meeting.
			//
			// **This field is deprecated and will not be supported in the future.**
			//
			//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
			// Deprecated:
			EnforceLogin *bool `json:"enforce_login,omitempty"`

			// EnforceLoginDomains Only signed in users with specified domains can join meetings.
			//
			// **This field is deprecated and will not be supported in the future.**
			//
			//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
			// Deprecated:
			EnforceLoginDomains *string `json:"enforce_login_domains,omitempty"`

			// FocusMode Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
			FocusMode *bool `json:"focus_mode,omitempty"`

			// GlobalDialInCountries List of global dial-in countries
			GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

			// GlobalDialInNumbers Global Dial-in Countries/Regions
			GlobalDialInNumbers *[]struct {
				// City City of the number, if any. For example, Chicago.
				City *string `json:"city,omitempty"`

				// Country Country code. For example, BR.
				Country *string `json:"country,omitempty"`

				// CountryName Full name of country. For example, Brazil.
				CountryName *string `json:"country_name,omitempty"`

				// Number Phone number. For example, +1 2332357613.
				Number *string `json:"number,omitempty"`

				// Type Type of number.
				Type *string `json:"type,omitempty"`
			} `json:"global_dial_in_numbers,omitempty"`

			// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
			HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

			// HostVideo Start video when the host joins the meeting.
			HostVideo *bool `json:"host_video,omitempty"`

			// InMeeting Host meeting in India.
			// Deprecated:
			InMeeting *bool `json:"in_meeting,omitempty"`

			// JbhTime If the value of &quot;join_before_host&quot; field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
			//
			// *  `0`: Allow participant to join anytime.
			// *  `5`: Allow participant to join 5 minutes before meeting start time.
			//  * `10`: Allow participant to join 10 minutes before meeting start time.
			JbhTime *int `json:"jbh_time,omitempty"`

			// JoinBeforeHost Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
			JoinBeforeHost *bool `json:"join_before_host,omitempty"`

			// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
			//
			// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
			LanguageInterpretation *struct {
				// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
				Enable *bool `json:"enable,omitempty"`

				// Interpreters Information about the meeting's language interpreters.
				Interpreters *[]struct {
					// Email The interpreter's email address.
					Email *openapi_types.Email `json:"email,omitempty"`

					// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](/docs/api/rest/other-references/abbreviation-lists/#countries).
					//
					// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
					Languages *string `json:"languages,omitempty"`
				} `json:"interpreters,omitempty"`
			} `json:"language_interpretation,omitempty"`

			// MeetingAuthentication `true`- Only authenticated users can join meetings.
			MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

			// MuteUponEntry Mute participants upon entry.
			MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

			// ParticipantVideo Start video when participants join the meeting.
			ParticipantVideo *bool `json:"participant_video,omitempty"`

			// PrivateMeeting Whether the meeting is set as private.
			PrivateMeeting *bool `json:"private_meeting,omitempty"`

			// RegistrantsConfirmationEmail Whether to send registrants an email confirmation.
			// * `true` - Send a confirmation email.
			// * `false` - Do not send a confirmation email.
			RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

			// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection.
			//
			// * `true` - Send an email notification.
			// * `false` - Do not send an email notification.
			//
			//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
			RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

			// RegistrationType Registration type. Used for recurring meeting with fixed time only.
			//  `1` Attendees register once and can attend any of the occurrences.
			//  `2` Attendees need to register for each occurrence to attend.
			//  `3` Attendees register once and can choose one or more occurrences to attend.
			RegistrationType *int `json:"registration_type,omitempty"`

			// ShowShareButton Show social share buttons on the meeting registration page.
			// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
			ShowShareButton *bool `json:"show_share_button,omitempty"`

			// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
			//
			// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
			SignLanguageInterpretation *struct {
				// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
				Enable *bool `json:"enable,omitempty"`

				// Interpreters Information about the meeting's sign language interpreters.
				Interpreters *[]struct {
					// Email The interpreter's email address.
					Email *openapi_types.Email `json:"email,omitempty"`

					// SignLanguage The interpreter's sign language.
					//
					//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
					SignLanguage *string `json:"sign_language,omitempty"`
				} `json:"interpreters,omitempty"`
			} `json:"sign_language_interpretation,omitempty"`

			// UsePmi Use a [Personal Meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
			UsePmi *bool `json:"use_pmi,omitempty"`

			// WaitingRoom Enable waiting room
			WaitingRoom *bool `json:"waiting_room,omitempty"`

			// Watermark Add watermark when viewing a shared screen.
			Watermark *bool `json:"watermark,omitempty"`
		} `json:"settings,omitempty"`

		// StartTime Meeting start date-time in UTC/GMT. Example: &quot;2020-03-31T12:02:00Z&quot;
		StartTime *time.Time `json:"start_time,omitempty"`

		// StartUrl URL to start the meeting. This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
		StartUrl *string `json:"start_url,omitempty"`

		// Timezone Timezone to format start_time
		Timezone *string `json:"timezone,omitempty"`

		// Topic Meeting topic
		Topic *string `json:"topic,omitempty"`

		// TrackingFields Tracking fields
		TrackingFields *[]struct {
			// Field Label of the tracking field.
			Field *string `json:"field,omitempty"`

			// Value Value for the field.
			Value *string `json:"value,omitempty"`

			// Visible Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
			//
			// `true`: Tracking field is visible.
			//
			//
			// `false`: Tracking field is not visible to the users in the meeting options in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
			Visible *bool `json:"visible,omitempty"`
		} `json:"tracking_fields,omitempty"`

		// Type Meeting Type
		Type *int `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r MeetingCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r MeetingCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserPermissionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Permissions List of user permissions.
		Permissions *[]string `json:"permissions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserPermissionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserPermissionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserPictureDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserPictureDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserPictureDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserPictureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserPictureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserPictureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePresenceStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdatePresenceStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePresenceStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSchedulersDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserSchedulersDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSchedulersDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSchedulersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Schedulers List of users for whom the current user can schedule meetings.
		Schedulers *[]struct {
			// Email Email address of the scheduler.
			Email *string `json:"email,omitempty"`

			// Id Unique Identifier (User ID) of the Scheduler.
			Id *string `json:"id,omitempty"`

			// Pmi PMI of the meeting host in long (int64) format.
			Pmi *int64 `json:"pmi,omitempty"`
		} `json:"schedulers,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserSchedulersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSchedulersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSchedulerDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserSchedulerDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSchedulerDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r UserSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSettingsUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserSettingsUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSettingsUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DelUserVBResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DelUserVBResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DelUserVBResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadVBuserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Id The virtual background file's ID.
		Id *string `json:"id,omitempty"`

		// IsDefault Whether the virtual background file is set as the default virtual background:
		// * `true` &mdash; The default virtual background.
		// * `false` &mdash; Not the default virtual background.
		IsDefault *bool `json:"is_default,omitempty"`

		// Name The virtual background file's name.
		Name *string `json:"name,omitempty"`

		// Size The virtual background file's size, in bytes.
		Size *int `json:"size,omitempty"`

		// Type The virtual background file's file type:
		// * `image` &mdash; An image file.
		// * `video` &mdash; A video file.
		Type *string `json:"type,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UploadVBuserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadVBuserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserSSOTokenDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UserSSOTokenDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserSSOTokenDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UserTokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Token The user's ZAK or token value.
		Token *string `json:"token,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UserTokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UserTokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// DeleteMeetingChatMessageByIdWithResponse request returning *DeleteMeetingChatMessageByIdResponse
func (c *ClientWithResponses) DeleteMeetingChatMessageByIdWithResponse(ctx context.Context, meetingId int64, messageId string, reqEditors ...RequestEditorFn) (*DeleteMeetingChatMessageByIdResponse, error) {
	rsp, err := c.DeleteMeetingChatMessageById(ctx, meetingId, messageId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMeetingChatMessageByIdResponse(rsp)
}

// InMeetingControlWithBodyWithResponse request with arbitrary body returning *InMeetingControlResponse
func (c *ClientWithResponses) InMeetingControlWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*InMeetingControlResponse, error) {
	rsp, err := c.InMeetingControlWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInMeetingControlResponse(rsp)
}

func (c *ClientWithResponses) InMeetingControlWithResponse(ctx context.Context, meetingId string, body InMeetingControlJSONRequestBody, reqEditors ...RequestEditorFn) (*InMeetingControlResponse, error) {
	rsp, err := c.InMeetingControl(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseInMeetingControlResponse(rsp)
}

// MeetingDeleteWithResponse request returning *MeetingDeleteResponse
func (c *ClientWithResponses) MeetingDeleteWithResponse(ctx context.Context, meetingId int64, params *MeetingDeleteParams, reqEditors ...RequestEditorFn) (*MeetingDeleteResponse, error) {
	rsp, err := c.MeetingDelete(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingDeleteResponse(rsp)
}

// MeetingWithResponse request returning *MeetingResponse
func (c *ClientWithResponses) MeetingWithResponse(ctx context.Context, meetingId int64, params *MeetingParams, reqEditors ...RequestEditorFn) (*MeetingResponse, error) {
	rsp, err := c.Meeting(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingResponse(rsp)
}

// MeetingUpdateWithBodyWithResponse request with arbitrary body returning *MeetingUpdateResponse
func (c *ClientWithResponses) MeetingUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingUpdateResponse, error) {
	rsp, err := c.MeetingUpdateWithBody(ctx, meetingId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingUpdateWithResponse(ctx context.Context, meetingId int64, params *MeetingUpdateParams, body MeetingUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingUpdateResponse, error) {
	rsp, err := c.MeetingUpdate(ctx, meetingId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingUpdateResponse(rsp)
}

// CreateBatchPollsWithBodyWithResponse request with arbitrary body returning *CreateBatchPollsResponse
func (c *ClientWithResponses) CreateBatchPollsWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateBatchPollsResponse, error) {
	rsp, err := c.CreateBatchPollsWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchPollsResponse(rsp)
}

func (c *ClientWithResponses) CreateBatchPollsWithResponse(ctx context.Context, meetingId string, body CreateBatchPollsJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateBatchPollsResponse, error) {
	rsp, err := c.CreateBatchPolls(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBatchPollsResponse(rsp)
}

// AddBatchRegistrantsWithBodyWithResponse request with arbitrary body returning *AddBatchRegistrantsResponse
func (c *ClientWithResponses) AddBatchRegistrantsWithBodyWithResponse(ctx context.Context, meetingId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddBatchRegistrantsResponse, error) {
	rsp, err := c.AddBatchRegistrantsWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBatchRegistrantsResponse(rsp)
}

func (c *ClientWithResponses) AddBatchRegistrantsWithResponse(ctx context.Context, meetingId string, body AddBatchRegistrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*AddBatchRegistrantsResponse, error) {
	rsp, err := c.AddBatchRegistrants(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddBatchRegistrantsResponse(rsp)
}

// MeetingInvitationWithResponse request returning *MeetingInvitationResponse
func (c *ClientWithResponses) MeetingInvitationWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingInvitationResponse, error) {
	rsp, err := c.MeetingInvitation(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingInvitationResponse(rsp)
}

// MeetingInviteLinksCreateWithBodyWithResponse request with arbitrary body returning *MeetingInviteLinksCreateResponse
func (c *ClientWithResponses) MeetingInviteLinksCreateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingInviteLinksCreateResponse, error) {
	rsp, err := c.MeetingInviteLinksCreateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingInviteLinksCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingInviteLinksCreateWithResponse(ctx context.Context, meetingId int64, body MeetingInviteLinksCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingInviteLinksCreateResponse, error) {
	rsp, err := c.MeetingInviteLinksCreate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingInviteLinksCreateResponse(rsp)
}

// MeetingLiveStreamingJoinTokenWithResponse request returning *MeetingLiveStreamingJoinTokenResponse
func (c *ClientWithResponses) MeetingLiveStreamingJoinTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLiveStreamingJoinTokenResponse, error) {
	rsp, err := c.MeetingLiveStreamingJoinToken(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLiveStreamingJoinTokenResponse(rsp)
}

// MeetingLocalArchivingArchiveTokenWithResponse request returning *MeetingLocalArchivingArchiveTokenResponse
func (c *ClientWithResponses) MeetingLocalArchivingArchiveTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLocalArchivingArchiveTokenResponse, error) {
	rsp, err := c.MeetingLocalArchivingArchiveToken(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLocalArchivingArchiveTokenResponse(rsp)
}

// MeetingLocalRecordingJoinTokenWithResponse request returning *MeetingLocalRecordingJoinTokenResponse
func (c *ClientWithResponses) MeetingLocalRecordingJoinTokenWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingLocalRecordingJoinTokenResponse, error) {
	rsp, err := c.MeetingLocalRecordingJoinToken(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLocalRecordingJoinTokenResponse(rsp)
}

// GetMeetingLiveStreamDetailsWithResponse request returning *GetMeetingLiveStreamDetailsResponse
func (c *ClientWithResponses) GetMeetingLiveStreamDetailsWithResponse(ctx context.Context, meetingId string, reqEditors ...RequestEditorFn) (*GetMeetingLiveStreamDetailsResponse, error) {
	rsp, err := c.GetMeetingLiveStreamDetails(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeetingLiveStreamDetailsResponse(rsp)
}

// MeetingLiveStreamUpdateWithBodyWithResponse request with arbitrary body returning *MeetingLiveStreamUpdateResponse
func (c *ClientWithResponses) MeetingLiveStreamUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingLiveStreamUpdateResponse, error) {
	rsp, err := c.MeetingLiveStreamUpdateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLiveStreamUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingLiveStreamUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingLiveStreamUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingLiveStreamUpdateResponse, error) {
	rsp, err := c.MeetingLiveStreamUpdate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLiveStreamUpdateResponse(rsp)
}

// MeetingLiveStreamStatusUpdateWithBodyWithResponse request with arbitrary body returning *MeetingLiveStreamStatusUpdateResponse
func (c *ClientWithResponses) MeetingLiveStreamStatusUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingLiveStreamStatusUpdateResponse, error) {
	rsp, err := c.MeetingLiveStreamStatusUpdateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLiveStreamStatusUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingLiveStreamStatusUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingLiveStreamStatusUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingLiveStreamStatusUpdateResponse, error) {
	rsp, err := c.MeetingLiveStreamStatusUpdate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingLiveStreamStatusUpdateResponse(rsp)
}

// MeetingPollsWithResponse request returning *MeetingPollsResponse
func (c *ClientWithResponses) MeetingPollsWithResponse(ctx context.Context, meetingId int64, params *MeetingPollsParams, reqEditors ...RequestEditorFn) (*MeetingPollsResponse, error) {
	rsp, err := c.MeetingPolls(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollsResponse(rsp)
}

// MeetingPollCreateWithBodyWithResponse request with arbitrary body returning *MeetingPollCreateResponse
func (c *ClientWithResponses) MeetingPollCreateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingPollCreateResponse, error) {
	rsp, err := c.MeetingPollCreateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingPollCreateWithResponse(ctx context.Context, meetingId int64, body MeetingPollCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingPollCreateResponse, error) {
	rsp, err := c.MeetingPollCreate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollCreateResponse(rsp)
}

// MeetingPollDeleteWithResponse request returning *MeetingPollDeleteResponse
func (c *ClientWithResponses) MeetingPollDeleteWithResponse(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*MeetingPollDeleteResponse, error) {
	rsp, err := c.MeetingPollDelete(ctx, meetingId, pollId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollDeleteResponse(rsp)
}

// MeetingPollGetWithResponse request returning *MeetingPollGetResponse
func (c *ClientWithResponses) MeetingPollGetWithResponse(ctx context.Context, meetingId int64, pollId string, reqEditors ...RequestEditorFn) (*MeetingPollGetResponse, error) {
	rsp, err := c.MeetingPollGet(ctx, meetingId, pollId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollGetResponse(rsp)
}

// MeetingPollUpdateWithBodyWithResponse request with arbitrary body returning *MeetingPollUpdateResponse
func (c *ClientWithResponses) MeetingPollUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, pollId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingPollUpdateResponse, error) {
	rsp, err := c.MeetingPollUpdateWithBody(ctx, meetingId, pollId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingPollUpdateWithResponse(ctx context.Context, meetingId int64, pollId string, body MeetingPollUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingPollUpdateResponse, error) {
	rsp, err := c.MeetingPollUpdate(ctx, meetingId, pollId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingPollUpdateResponse(rsp)
}

// MeetingRegistrantsWithResponse request returning *MeetingRegistrantsResponse
func (c *ClientWithResponses) MeetingRegistrantsWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantsParams, reqEditors ...RequestEditorFn) (*MeetingRegistrantsResponse, error) {
	rsp, err := c.MeetingRegistrants(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantsResponse(rsp)
}

// MeetingRegistrantCreateWithBodyWithResponse request with arbitrary body returning *MeetingRegistrantCreateResponse
func (c *ClientWithResponses) MeetingRegistrantCreateWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantCreateResponse, error) {
	rsp, err := c.MeetingRegistrantCreateWithBody(ctx, meetingId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingRegistrantCreateWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantCreateParams, body MeetingRegistrantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantCreateResponse, error) {
	rsp, err := c.MeetingRegistrantCreate(ctx, meetingId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantCreateResponse(rsp)
}

// MeetingRegistrantsQuestionsGetWithResponse request returning *MeetingRegistrantsQuestionsGetResponse
func (c *ClientWithResponses) MeetingRegistrantsQuestionsGetWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingRegistrantsQuestionsGetResponse, error) {
	rsp, err := c.MeetingRegistrantsQuestionsGet(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantsQuestionsGetResponse(rsp)
}

// MeetingRegistrantQuestionUpdateWithBodyWithResponse request with arbitrary body returning *MeetingRegistrantQuestionUpdateResponse
func (c *ClientWithResponses) MeetingRegistrantQuestionUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantQuestionUpdateResponse, error) {
	rsp, err := c.MeetingRegistrantQuestionUpdateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantQuestionUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingRegistrantQuestionUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingRegistrantQuestionUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantQuestionUpdateResponse, error) {
	rsp, err := c.MeetingRegistrantQuestionUpdate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantQuestionUpdateResponse(rsp)
}

// MeetingRegistrantStatusWithBodyWithResponse request with arbitrary body returning *MeetingRegistrantStatusResponse
func (c *ClientWithResponses) MeetingRegistrantStatusWithBodyWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingRegistrantStatusResponse, error) {
	rsp, err := c.MeetingRegistrantStatusWithBody(ctx, meetingId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantStatusResponse(rsp)
}

func (c *ClientWithResponses) MeetingRegistrantStatusWithResponse(ctx context.Context, meetingId int64, params *MeetingRegistrantStatusParams, body MeetingRegistrantStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingRegistrantStatusResponse, error) {
	rsp, err := c.MeetingRegistrantStatus(ctx, meetingId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantStatusResponse(rsp)
}

// MeetingregistrantdeleteWithResponse request returning *MeetingregistrantdeleteResponse
func (c *ClientWithResponses) MeetingregistrantdeleteWithResponse(ctx context.Context, meetingId int, registrantId string, params *MeetingregistrantdeleteParams, reqEditors ...RequestEditorFn) (*MeetingregistrantdeleteResponse, error) {
	rsp, err := c.Meetingregistrantdelete(ctx, meetingId, registrantId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingregistrantdeleteResponse(rsp)
}

// MeetingRegistrantGetWithResponse request returning *MeetingRegistrantGetResponse
func (c *ClientWithResponses) MeetingRegistrantGetWithResponse(ctx context.Context, meetingId int64, registrantId string, reqEditors ...RequestEditorFn) (*MeetingRegistrantGetResponse, error) {
	rsp, err := c.MeetingRegistrantGet(ctx, meetingId, registrantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingRegistrantGetResponse(rsp)
}

// GetSipDialingWithPasscodeWithBodyWithResponse request with arbitrary body returning *GetSipDialingWithPasscodeResponse
func (c *ClientWithResponses) GetSipDialingWithPasscodeWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetSipDialingWithPasscodeResponse, error) {
	rsp, err := c.GetSipDialingWithPasscodeWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSipDialingWithPasscodeResponse(rsp)
}

func (c *ClientWithResponses) GetSipDialingWithPasscodeWithResponse(ctx context.Context, meetingId int64, body GetSipDialingWithPasscodeJSONRequestBody, reqEditors ...RequestEditorFn) (*GetSipDialingWithPasscodeResponse, error) {
	rsp, err := c.GetSipDialingWithPasscode(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSipDialingWithPasscodeResponse(rsp)
}

// MeetingStatusWithBodyWithResponse request with arbitrary body returning *MeetingStatusResponse
func (c *ClientWithResponses) MeetingStatusWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingStatusResponse, error) {
	rsp, err := c.MeetingStatusWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingStatusResponse(rsp)
}

func (c *ClientWithResponses) MeetingStatusWithResponse(ctx context.Context, meetingId int64, body MeetingStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingStatusResponse, error) {
	rsp, err := c.MeetingStatus(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingStatusResponse(rsp)
}

// MeetingSurveyDeleteWithResponse request returning *MeetingSurveyDeleteResponse
func (c *ClientWithResponses) MeetingSurveyDeleteWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingSurveyDeleteResponse, error) {
	rsp, err := c.MeetingSurveyDelete(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingSurveyDeleteResponse(rsp)
}

// MeetingSurveyGetWithResponse request returning *MeetingSurveyGetResponse
func (c *ClientWithResponses) MeetingSurveyGetWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*MeetingSurveyGetResponse, error) {
	rsp, err := c.MeetingSurveyGet(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingSurveyGetResponse(rsp)
}

// MeetingSurveyUpdateWithBodyWithResponse request with arbitrary body returning *MeetingSurveyUpdateResponse
func (c *ClientWithResponses) MeetingSurveyUpdateWithBodyWithResponse(ctx context.Context, meetingId int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingSurveyUpdateResponse, error) {
	rsp, err := c.MeetingSurveyUpdateWithBody(ctx, meetingId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingSurveyUpdateResponse(rsp)
}

func (c *ClientWithResponses) MeetingSurveyUpdateWithResponse(ctx context.Context, meetingId int64, body MeetingSurveyUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingSurveyUpdateResponse, error) {
	rsp, err := c.MeetingSurveyUpdate(ctx, meetingId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingSurveyUpdateResponse(rsp)
}

// MeetingTokenWithResponse request returning *MeetingTokenResponse
func (c *ClientWithResponses) MeetingTokenWithResponse(ctx context.Context, meetingId int64, params *MeetingTokenParams, reqEditors ...RequestEditorFn) (*MeetingTokenResponse, error) {
	rsp, err := c.MeetingToken(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingTokenResponse(rsp)
}

// PastMeetingDetailsWithResponse request returning *PastMeetingDetailsResponse
func (c *ClientWithResponses) PastMeetingDetailsWithResponse(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*PastMeetingDetailsResponse, error) {
	rsp, err := c.PastMeetingDetails(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePastMeetingDetailsResponse(rsp)
}

// PastMeetingsWithResponse request returning *PastMeetingsResponse
func (c *ClientWithResponses) PastMeetingsWithResponse(ctx context.Context, meetingId int64, reqEditors ...RequestEditorFn) (*PastMeetingsResponse, error) {
	rsp, err := c.PastMeetings(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePastMeetingsResponse(rsp)
}

// PastMeetingParticipantsWithResponse request returning *PastMeetingParticipantsResponse
func (c *ClientWithResponses) PastMeetingParticipantsWithResponse(ctx context.Context, meetingId struct {
	union json.RawMessage
}, params *PastMeetingParticipantsParams, reqEditors ...RequestEditorFn) (*PastMeetingParticipantsResponse, error) {
	rsp, err := c.PastMeetingParticipants(ctx, meetingId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePastMeetingParticipantsResponse(rsp)
}

// ListPastMeetingPollsWithResponse request returning *ListPastMeetingPollsResponse
func (c *ClientWithResponses) ListPastMeetingPollsWithResponse(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*ListPastMeetingPollsResponse, error) {
	rsp, err := c.ListPastMeetingPolls(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPastMeetingPollsResponse(rsp)
}

// ListPastMeetingQAWithResponse request returning *ListPastMeetingQAResponse
func (c *ClientWithResponses) ListPastMeetingQAWithResponse(ctx context.Context, meetingId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*ListPastMeetingQAResponse, error) {
	rsp, err := c.ListPastMeetingQA(ctx, meetingId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPastMeetingQAResponse(rsp)
}

// UsersWithResponse request returning *UsersResponse
func (c *ClientWithResponses) UsersWithResponse(ctx context.Context, params *UsersParams, reqEditors ...RequestEditorFn) (*UsersResponse, error) {
	rsp, err := c.Users(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUsersResponse(rsp)
}

// UserCreateWithBodyWithResponse request with arbitrary body returning *UserCreateResponse
func (c *ClientWithResponses) UserCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

func (c *ClientWithResponses) UserCreateWithResponse(ctx context.Context, body UserCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserCreateResponse, error) {
	rsp, err := c.UserCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserCreateResponse(rsp)
}

// UserEmailWithResponse request returning *UserEmailResponse
func (c *ClientWithResponses) UserEmailWithResponse(ctx context.Context, params *UserEmailParams, reqEditors ...RequestEditorFn) (*UserEmailResponse, error) {
	rsp, err := c.UserEmail(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserEmailResponse(rsp)
}

// BulkUpdateFeatureWithBodyWithResponse request with arbitrary body returning *BulkUpdateFeatureResponse
func (c *ClientWithResponses) BulkUpdateFeatureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUpdateFeatureResponse, error) {
	rsp, err := c.BulkUpdateFeatureWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateFeatureResponse(rsp)
}

func (c *ClientWithResponses) BulkUpdateFeatureWithResponse(ctx context.Context, body BulkUpdateFeatureJSONRequestBody, reqEditors ...RequestEditorFn) (*BulkUpdateFeatureResponse, error) {
	rsp, err := c.BulkUpdateFeature(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUpdateFeatureResponse(rsp)
}

// UserZakWithResponse request returning *UserZakResponse
func (c *ClientWithResponses) UserZakWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserZakResponse, error) {
	rsp, err := c.UserZak(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserZakResponse(rsp)
}

// UserSummaryWithResponse request returning *UserSummaryResponse
func (c *ClientWithResponses) UserSummaryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*UserSummaryResponse, error) {
	rsp, err := c.UserSummary(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSummaryResponse(rsp)
}

// UserVanityNameWithResponse request returning *UserVanityNameResponse
func (c *ClientWithResponses) UserVanityNameWithResponse(ctx context.Context, params *UserVanityNameParams, reqEditors ...RequestEditorFn) (*UserVanityNameResponse, error) {
	rsp, err := c.UserVanityName(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserVanityNameResponse(rsp)
}

// UserDeleteWithResponse request returning *UserDeleteResponse
func (c *ClientWithResponses) UserDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserDeleteParams, reqEditors ...RequestEditorFn) (*UserDeleteResponse, error) {
	rsp, err := c.UserDelete(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserDeleteResponse(rsp)
}

// UserWithResponse request returning *UserResponse
func (c *ClientWithResponses) UserWithResponse(ctx context.Context, userId string, params *UserParams, reqEditors ...RequestEditorFn) (*UserResponse, error) {
	rsp, err := c.User(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserResponse(rsp)
}

// UserUpdateWithBodyWithResponse request with arbitrary body returning *UserUpdateResponse
func (c *ClientWithResponses) UserUpdateWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdateWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserUpdateWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserUpdateParams, body UserUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserUpdateResponse, error) {
	rsp, err := c.UserUpdate(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserUpdateResponse(rsp)
}

// SwitchAUsersAccountWithBodyWithResponse request with arbitrary body returning *SwitchAUsersAccountResponse
func (c *ClientWithResponses) SwitchAUsersAccountWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SwitchAUsersAccountResponse, error) {
	rsp, err := c.SwitchAUsersAccountWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwitchAUsersAccountResponse(rsp)
}

func (c *ClientWithResponses) SwitchAUsersAccountWithResponse(ctx context.Context, userId string, body SwitchAUsersAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*SwitchAUsersAccountResponse, error) {
	rsp, err := c.SwitchAUsersAccount(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSwitchAUsersAccountResponse(rsp)
}

// UserAssistantsDeleteWithResponse request returning *UserAssistantsDeleteResponse
func (c *ClientWithResponses) UserAssistantsDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserAssistantsDeleteResponse, error) {
	rsp, err := c.UserAssistantsDelete(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserAssistantsDeleteResponse(rsp)
}

// UserAssistantsWithResponse request returning *UserAssistantsResponse
func (c *ClientWithResponses) UserAssistantsWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserAssistantsResponse, error) {
	rsp, err := c.UserAssistants(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserAssistantsResponse(rsp)
}

// UserAssistantCreateWithBodyWithResponse request with arbitrary body returning *UserAssistantCreateResponse
func (c *ClientWithResponses) UserAssistantCreateWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserAssistantCreateResponse, error) {
	rsp, err := c.UserAssistantCreateWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserAssistantCreateResponse(rsp)
}

func (c *ClientWithResponses) UserAssistantCreateWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserAssistantCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserAssistantCreateResponse, error) {
	rsp, err := c.UserAssistantCreate(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserAssistantCreateResponse(rsp)
}

// UserAssistantDeleteWithResponse request returning *UserAssistantDeleteResponse
func (c *ClientWithResponses) UserAssistantDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, assistantId string, reqEditors ...RequestEditorFn) (*UserAssistantDeleteResponse, error) {
	rsp, err := c.UserAssistantDelete(ctx, userId, assistantId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserAssistantDeleteResponse(rsp)
}

// ListCollaborationDevicesWithResponse request returning *ListCollaborationDevicesResponse
func (c *ClientWithResponses) ListCollaborationDevicesWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*ListCollaborationDevicesResponse, error) {
	rsp, err := c.ListCollaborationDevices(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollaborationDevicesResponse(rsp)
}

// GetCollaborationDeviceWithResponse request returning *GetCollaborationDeviceResponse
func (c *ClientWithResponses) GetCollaborationDeviceWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, collaborationDeviceId string, reqEditors ...RequestEditorFn) (*GetCollaborationDeviceResponse, error) {
	rsp, err := c.GetCollaborationDevice(ctx, userId, collaborationDeviceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollaborationDeviceResponse(rsp)
}

// UserEmailUpdateWithBodyWithResponse request with arbitrary body returning *UserEmailUpdateResponse
func (c *ClientWithResponses) UserEmailUpdateWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserEmailUpdateResponse, error) {
	rsp, err := c.UserEmailUpdateWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserEmailUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserEmailUpdateWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserEmailUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserEmailUpdateResponse, error) {
	rsp, err := c.UserEmailUpdate(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserEmailUpdateResponse(rsp)
}

// ListMeetingTemplatesWithResponse request returning *ListMeetingTemplatesResponse
func (c *ClientWithResponses) ListMeetingTemplatesWithResponse(ctx context.Context, userId string, reqEditors ...RequestEditorFn) (*ListMeetingTemplatesResponse, error) {
	rsp, err := c.ListMeetingTemplates(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListMeetingTemplatesResponse(rsp)
}

// MeetingTemplateCreateWithBodyWithResponse request with arbitrary body returning *MeetingTemplateCreateResponse
func (c *ClientWithResponses) MeetingTemplateCreateWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingTemplateCreateResponse, error) {
	rsp, err := c.MeetingTemplateCreateWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingTemplateCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingTemplateCreateWithResponse(ctx context.Context, userId string, body MeetingTemplateCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingTemplateCreateResponse, error) {
	rsp, err := c.MeetingTemplateCreate(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingTemplateCreateResponse(rsp)
}

// MeetingsWithResponse request returning *MeetingsResponse
func (c *ClientWithResponses) MeetingsWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *MeetingsParams, reqEditors ...RequestEditorFn) (*MeetingsResponse, error) {
	rsp, err := c.Meetings(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingsResponse(rsp)
}

// MeetingCreateWithBodyWithResponse request with arbitrary body returning *MeetingCreateResponse
func (c *ClientWithResponses) MeetingCreateWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*MeetingCreateResponse, error) {
	rsp, err := c.MeetingCreateWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingCreateResponse(rsp)
}

func (c *ClientWithResponses) MeetingCreateWithResponse(ctx context.Context, userId string, body MeetingCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*MeetingCreateResponse, error) {
	rsp, err := c.MeetingCreate(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseMeetingCreateResponse(rsp)
}

// UserPasswordWithBodyWithResponse request with arbitrary body returning *UserPasswordResponse
func (c *ClientWithResponses) UserPasswordWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserPasswordResponse, error) {
	rsp, err := c.UserPasswordWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UserPasswordWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UserPasswordResponse, error) {
	rsp, err := c.UserPassword(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPasswordResponse(rsp)
}

// UserPermissionWithResponse request returning *UserPermissionResponse
func (c *ClientWithResponses) UserPermissionWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserPermissionResponse, error) {
	rsp, err := c.UserPermission(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPermissionResponse(rsp)
}

// UserPictureDeleteWithResponse request returning *UserPictureDeleteResponse
func (c *ClientWithResponses) UserPictureDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserPictureDeleteResponse, error) {
	rsp, err := c.UserPictureDelete(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPictureDeleteResponse(rsp)
}

// UserPictureWithBodyWithResponse request with arbitrary body returning *UserPictureResponse
func (c *ClientWithResponses) UserPictureWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserPictureResponse, error) {
	rsp, err := c.UserPictureWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserPictureResponse(rsp)
}

// UpdatePresenceStatusWithBodyWithResponse request with arbitrary body returning *UpdatePresenceStatusResponse
func (c *ClientWithResponses) UpdatePresenceStatusWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePresenceStatusResponse, error) {
	rsp, err := c.UpdatePresenceStatusWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePresenceStatusResponse(rsp)
}

func (c *ClientWithResponses) UpdatePresenceStatusWithResponse(ctx context.Context, userId string, body UpdatePresenceStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePresenceStatusResponse, error) {
	rsp, err := c.UpdatePresenceStatus(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePresenceStatusResponse(rsp)
}

// UserSchedulersDeleteWithResponse request returning *UserSchedulersDeleteResponse
func (c *ClientWithResponses) UserSchedulersDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserSchedulersDeleteResponse, error) {
	rsp, err := c.UserSchedulersDelete(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSchedulersDeleteResponse(rsp)
}

// UserSchedulersWithResponse request returning *UserSchedulersResponse
func (c *ClientWithResponses) UserSchedulersWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserSchedulersResponse, error) {
	rsp, err := c.UserSchedulers(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSchedulersResponse(rsp)
}

// UserSchedulerDeleteWithResponse request returning *UserSchedulerDeleteResponse
func (c *ClientWithResponses) UserSchedulerDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, schedulerId string, reqEditors ...RequestEditorFn) (*UserSchedulerDeleteResponse, error) {
	rsp, err := c.UserSchedulerDelete(ctx, userId, schedulerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSchedulerDeleteResponse(rsp)
}

// UserSettingsWithResponse request returning *UserSettingsResponse
func (c *ClientWithResponses) UserSettingsWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsParams, reqEditors ...RequestEditorFn) (*UserSettingsResponse, error) {
	rsp, err := c.UserSettings(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSettingsResponse(rsp)
}

// UserSettingsUpdateWithBodyWithResponse request with arbitrary body returning *UserSettingsUpdateResponse
func (c *ClientWithResponses) UserSettingsUpdateWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserSettingsUpdateResponse, error) {
	rsp, err := c.UserSettingsUpdateWithBody(ctx, userId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSettingsUpdateResponse(rsp)
}

func (c *ClientWithResponses) UserSettingsUpdateWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserSettingsUpdateParams, body UserSettingsUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*UserSettingsUpdateResponse, error) {
	rsp, err := c.UserSettingsUpdate(ctx, userId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSettingsUpdateResponse(rsp)
}

// DelUserVBWithResponse request returning *DelUserVBResponse
func (c *ClientWithResponses) DelUserVBWithResponse(ctx context.Context, userId string, params *DelUserVBParams, reqEditors ...RequestEditorFn) (*DelUserVBResponse, error) {
	rsp, err := c.DelUserVB(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDelUserVBResponse(rsp)
}

// UploadVBuserWithBodyWithResponse request with arbitrary body returning *UploadVBuserResponse
func (c *ClientWithResponses) UploadVBuserWithBodyWithResponse(ctx context.Context, userId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadVBuserResponse, error) {
	rsp, err := c.UploadVBuserWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadVBuserResponse(rsp)
}

// UserStatusWithBodyWithResponse request with arbitrary body returning *UserStatusResponse
func (c *ClientWithResponses) UserStatusWithBodyWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UserStatusResponse, error) {
	rsp, err := c.UserStatusWithBody(ctx, userId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserStatusResponse(rsp)
}

func (c *ClientWithResponses) UserStatusWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, body UserStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*UserStatusResponse, error) {
	rsp, err := c.UserStatus(ctx, userId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserStatusResponse(rsp)
}

// UserSSOTokenDeleteWithResponse request returning *UserSSOTokenDeleteResponse
func (c *ClientWithResponses) UserSSOTokenDeleteWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, reqEditors ...RequestEditorFn) (*UserSSOTokenDeleteResponse, error) {
	rsp, err := c.UserSSOTokenDelete(ctx, userId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserSSOTokenDeleteResponse(rsp)
}

// UserTokenWithResponse request returning *UserTokenResponse
func (c *ClientWithResponses) UserTokenWithResponse(ctx context.Context, userId struct {
	union json.RawMessage
}, params *UserTokenParams, reqEditors ...RequestEditorFn) (*UserTokenResponse, error) {
	rsp, err := c.UserToken(ctx, userId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUserTokenResponse(rsp)
}

// ParseDeleteMeetingChatMessageByIdResponse parses an HTTP response from a DeleteMeetingChatMessageByIdWithResponse call
func ParseDeleteMeetingChatMessageByIdResponse(rsp *http.Response) (*DeleteMeetingChatMessageByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMeetingChatMessageByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseInMeetingControlResponse parses an HTTP response from a InMeetingControlWithResponse call
func ParseInMeetingControlResponse(rsp *http.Response) (*InMeetingControlResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &InMeetingControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingDeleteResponse parses an HTTP response from a MeetingDeleteWithResponse call
func ParseMeetingDeleteResponse(rsp *http.Response) (*MeetingDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingResponse parses an HTTP response from a MeetingWithResponse call
func ParseMeetingResponse(rsp *http.Response) (*MeetingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Agenda Meeting description
			Agenda *string `json:"agenda,omitempty"`

			// AssistantId The ID of the user who scheduled this meeting on behalf of the host.
			AssistantId *string `json:"assistant_id,omitempty"`

			// ChatJoinUrl The URL to join the chat.
			ChatJoinUrl *string `json:"chat_join_url,omitempty"`

			// CreatedAt Time of creation.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Duration Meeting duration.
			Duration *int `json:"duration,omitempty"`

			// EncryptedPassword Encrypted passcode for third party endpoints (H323/SIP).
			EncryptedPassword *string `json:"encrypted_password,omitempty"`

			// H323Password H.323/SIP room system passcode.
			H323Password *string `json:"h323_password,omitempty"`

			// HostEmail Email address of the meeting host.
			HostEmail *openapi_types.Email `json:"host_email,omitempty"`

			// HostId ID of the user who is set as host of meeting.
			HostId *string `json:"host_id,omitempty"`

			// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
			Id *int64 `json:"id,omitempty"`

			// JoinUrl URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// Occurrences Array of occurrence objects.
			Occurrences *[]struct {
				// Duration Duration.
				Duration *int `json:"duration,omitempty"`

				// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring meeting. [Recurring meetings](https://support.zoom.us/hc/en-us/articles/214973206-Scheduling-Recurring-Meetings) can have a maximum of 50 occurrences.
				OccurrenceId *string `json:"occurrence_id,omitempty"`

				// StartTime Start time.
				StartTime *time.Time `json:"start_time,omitempty"`

				// Status Occurrence status.
				Status *string `json:"status,omitempty"`
			} `json:"occurrences,omitempty"`

			// Password Meeting passcode.
			Password *string `json:"password,omitempty"`

			// Pmi [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
			Pmi *string `json:"pmi,omitempty"`

			// PreSchedule Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time):
			// * `true` - A GSuite prescheduled meeting.
			// * `false` - A regular meeting.
			PreSchedule *bool `json:"pre_schedule,omitempty"`

			// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
			Recurrence *struct {
				// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
				EndDateTime *time.Time `json:"end_date_time,omitempty"`

				// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
				EndTimes *int `json:"end_times,omitempty"`

				// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
				//
				// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
				MonthlyDay *int `json:"monthly_day,omitempty"`

				// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
				//  `-1` - Last week of the month.
				//  `1` - First week of the month.
				//  `2` - Second week of the month.
				//  `3` - Third week of the month.
				//  `4` - Fourth week of the month.
				MonthlyWeek *int `json:"monthly_week,omitempty"`

				// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
				//
				//
				//  `1` - Sunday.
				//  `2` - Monday.
				//  `3` - Tuesday.
				//  `4` -  Wednesday.
				//  `5` - Thursday.
				//  `6` - Friday.
				//  `7` - Saturday.
				MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

				// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
				//
				// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
				//
				RepeatInterval *int `json:"repeat_interval,omitempty"`

				// Type Recurrence meeting types:
				//  `1` - Daily.
				//  `2` - Weekly.
				//  `3` - Monthly.
				Type int `json:"type"`

				// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
				//
				//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
				//
				//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
				//
				//
				//  `1`  - Sunday.
				//  `2` - Monday.
				//  `3` - Tuesday.
				//  `4` -  Wednesday.
				//  `5` -  Thursday.
				//  `6` - Friday.
				//  `7` - Saturday.
				WeeklyDays *string `json:"weekly_days,omitempty"`
			} `json:"recurrence,omitempty"`

			// Settings Meeting settings.
			Settings *struct {
				// AllowMultipleDevices Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
				AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

				// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
				AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

				// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
				AlternativeHosts *string `json:"alternative_hosts,omitempty"`

				// AlternativeHostsEmailNotification Flag to determine whether to send email notifications to alternative hosts, default value is true.
				AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

				// ApprovalType Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**
				//
				//
				//
				// `0` - Automatically approve.
				//  `1` - Manually approve.
				//  `2` - No registration required.
				ApprovalType *int `json:"approval_type,omitempty"`

				// ApprovedOrDeniedCountriesOrRegions Approve or block users from specific regions/countries from joining this meeting.
				ApprovedOrDeniedCountriesOrRegions *struct {
					// ApprovedList List of countries/regions from where participants can join this meeting.
					ApprovedList *[]string `json:"approved_list,omitempty"`

					// DeniedList List of countries/regions from where participants can not join this meeting.
					DeniedList *[]string `json:"denied_list,omitempty"`

					// Enable `true`: Setting enabled to either allow users or block users from specific regions to join your meetings.
					//
					//
					// `false`: Setting disabled.
					Enable *bool `json:"enable,omitempty"`

					// Method Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.
					//
					//
					// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.
					//
					//
					// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
					Method *string `json:"method,omitempty"`
				} `json:"approved_or_denied_countries_or_regions,omitempty"`

				// Audio Determine how participants can join the audio portion of the meeting.
				//  `both` - Both Telephony and VoIP.
				//  `telephony` - Telephony only.
				//  `voip` - VoIP only.
				//  `thirdParty` - Third party audio conference.
				Audio *string `json:"audio,omitempty"`

				// AudioConferenceInfo Third party audio conference info.
				AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

				// AuthenticationDomains If user has configured [&quot;Sign Into Zoom with Specified Domains&quot;](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
				AuthenticationDomains *string `json:"authentication_domains,omitempty"`

				// AuthenticationException The participants added here will receive unique meeting invite links and bypass authentication.
				AuthenticationException *[]struct {
					// Email Email address of the participant.
					Email *openapi_types.Email `json:"email,omitempty"`

					// JoinUrl URL for participants to join the meeting
					JoinUrl *string `json:"join_url,omitempty"`

					// Name Name of the participant.
					Name *string `json:"name,omitempty"`
				} `json:"authentication_exception,omitempty"`

				// AuthenticationName Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
				AuthenticationName *string `json:"authentication_name,omitempty"`

				// AuthenticationOption Meeting authentication option id.
				AuthenticationOption *string `json:"authentication_option,omitempty"`

				// AutoRecording Automatic recording:
				//  `local` - Record on local.
				//  `cloud` -  Record on cloud.
				//  `none` - Disabled.
				AutoRecording *string `json:"auto_recording,omitempty"`

				// BreakoutRoom Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
				BreakoutRoom *struct {
					// Enable Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
					Enable *bool `json:"enable,omitempty"`

					// Rooms Create room(s).
					Rooms *[]struct {
						// Name Name of the breakout room.
						Name *string `json:"name,omitempty"`

						// Participants Email addresses of the participants who are to be assigned to the breakout room.
						Participants *[]string `json:"participants,omitempty"`
					} `json:"rooms,omitempty"`
				} `json:"breakout_room,omitempty"`

				// CalendarType Indicates the type of calendar integration used to schedule the meeting:
				// * `1` &mdash; [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
				// * `2` &mdash; [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
				//
				// Works with the `private_meeting` field to determine whether to share details of meetings or not.
				CalendarType *int `json:"calendar_type,omitempty"`

				// CloseRegistration Close registration after event date
				CloseRegistration *bool `json:"close_registration,omitempty"`

				// CnMeeting Host meeting in China.
				// Deprecated:
				CnMeeting *bool `json:"cn_meeting,omitempty"`

				// ContactEmail Contact email for registration
				ContactEmail *string `json:"contact_email,omitempty"`

				// ContactName Contact name for registration
				ContactName *string `json:"contact_name,omitempty"`

				// CustomKeys Custom keys and values assigned to the meeting.
				CustomKeys *[]struct {
					// Key Custom key associated with the user.
					Key *string `json:"key,omitempty"`

					// Value Value of the custom key associated with the user.
					Value *string `json:"value,omitempty"`
				} `json:"custom_keys,omitempty"`

				// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
				EmailNotification *bool `json:"email_notification,omitempty"`

				// EncryptionType Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.
				//
				//  The value of this field can be one of the following:
				//
				// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option.
				//
				//
				// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
				EncryptionType *string `json:"encryption_type,omitempty"`

				// EnforceLogin Only signed in users can join this meeting.
				//
				// **This field is deprecated and will not be supported in the future.**
				//
				//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
				// Deprecated:
				EnforceLogin *bool `json:"enforce_login,omitempty"`

				// EnforceLoginDomains Only signed in users with specified domains can join meetings.
				//
				// **This field is deprecated and will not be supported in the future.**
				//
				//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
				// Deprecated:
				EnforceLoginDomains *string `json:"enforce_login_domains,omitempty"`

				// FocusMode Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
				FocusMode *bool `json:"focus_mode,omitempty"`

				// GlobalDialInCountries List of global dial-in countries
				GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

				// GlobalDialInNumbers Global Dial-in Countries/Regions
				GlobalDialInNumbers *[]struct {
					// City City of the number, if any. For example, Chicago.
					City *string `json:"city,omitempty"`

					// Country Country code. For example, BR.
					Country *string `json:"country,omitempty"`

					// CountryName Full name of country. For example, Brazil.
					CountryName *string `json:"country_name,omitempty"`

					// Number Phone number. For example, +1 2332357613.
					Number *string `json:"number,omitempty"`

					// Type Type of number.
					Type *string `json:"type,omitempty"`
				} `json:"global_dial_in_numbers,omitempty"`

				// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
				HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

				// HostVideo Start video when the host joins the meeting.
				HostVideo *bool `json:"host_video,omitempty"`

				// InMeeting Host meeting in India.
				// Deprecated:
				InMeeting *bool `json:"in_meeting,omitempty"`

				// JbhTime If the value of &quot;join_before_host&quot; field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
				//
				// *  `0`: Allow participant to join anytime.
				// *  `5`: Allow participant to join 5 minutes before meeting start time.
				//  * `10`: Allow participant to join 10 minutes before meeting start time.
				JbhTime *int `json:"jbh_time,omitempty"`

				// JoinBeforeHost Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
				JoinBeforeHost *bool `json:"join_before_host,omitempty"`

				// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
				//
				// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
				LanguageInterpretation *struct {
					// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
					Enable *bool `json:"enable,omitempty"`

					// Interpreters Information about the meeting's language interpreters.
					Interpreters *[]struct {
						// Email The interpreter's email address.
						Email *openapi_types.Email `json:"email,omitempty"`

						// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
						//
						// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
						Languages *string `json:"languages,omitempty"`
					} `json:"interpreters,omitempty"`
				} `json:"language_interpretation,omitempty"`

				// MeetingAuthentication `true`- Only authenticated users can join meetings.
				MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

				// MuteUponEntry Mute participants upon entry.
				MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

				// ParticipantVideo Start video when participants join the meeting.
				ParticipantVideo *bool `json:"participant_video,omitempty"`

				// PrivateMeeting Whether the meeting is set as private.
				PrivateMeeting *bool `json:"private_meeting,omitempty"`

				// RegistrantsConfirmationEmail Whether to send registrants an email confirmation:
				// * `true` &mdash; Send a confirmation email.
				// * `false` &mdash; Do not send a confirmation email.
				RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

				// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection:
				//
				// * `true` &mdash; Send an email notification.
				// * `false` &mdash; Do not send an email notification.
				//
				//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
				RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

				// RegistrationType Registration type. Used for recurring meeting with fixed time only.
				//  `1` Attendees register once and can attend any of the occurrences.
				//  `2` Attendees need to register for each occurrence to attend.
				//  `3` Attendees register once and can choose one or more occurrences to attend.
				RegistrationType *int `json:"registration_type,omitempty"`

				// ShowShareButton Show social share buttons on the meeting registration page.
				// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
				ShowShareButton *bool `json:"show_share_button,omitempty"`

				// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
				//
				// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
				SignLanguageInterpretation *struct {
					// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
					Enable *bool `json:"enable,omitempty"`

					// Interpreters Information about the meeting's sign language interpreters.
					Interpreters *[]struct {
						// Email The interpreter's email address.
						Email *openapi_types.Email `json:"email,omitempty"`

						// SignLanguage The interpreter's sign language.
						//
						//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
						SignLanguage *string `json:"sign_language,omitempty"`
					} `json:"interpreters,omitempty"`
				} `json:"sign_language_interpretation,omitempty"`

				// UsePmi Use a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
				UsePmi *bool `json:"use_pmi,omitempty"`

				// WaitingRoom Enable waiting room
				WaitingRoom *bool `json:"waiting_room,omitempty"`

				// Watermark Add watermark when viewing a shared screen.
				Watermark *bool `json:"watermark,omitempty"`
			} `json:"settings,omitempty"`

			// StartTime Meeting start time in GMT/UTC. Start time will not be returned if the meeting is an **instant** meeting.
			StartTime *time.Time `json:"start_time,omitempty"`

			// StartUrl
			//  &lt;aside&gt;The &lt;code&gt;start_url&lt;/code&gt; of a Meeting is a URL using which a host or an alternative host can start the Meeting.
			//
			// The expiration time for the &lt;code&gt;start_url&lt;/code&gt; field listed in the response of the [**Create a meeting**](/docs/api-reference/zoom-api/methods#operation/meetingCreate) API is two hours for all regular users.
			//
			// For users created using the &lt;code&gt;custCreate&lt;/code&gt; option via the [**Create users**](/docs/api-reference/zoom-api/methods#operation/userCreate) API, the expiration time of the &lt;code&gt;start_url&lt;/code&gt; field is 90 days.
			//
			// For security reasons, to retrieve the updated value for the &lt;code&gt;start_url&lt;/code&gt; field programmatically (after the expiry time), you must call the [**Get a meeting](/docs/api-reference/zoom-api/methods#operation/meeting) API and refer to the value of the &lt;code&gt;start_url&lt;/code&gt; field in the response.&lt;/aside&gt;
			//  This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
			StartUrl *string `json:"start_url,omitempty"`

			// Status Meeting status
			Status *string `json:"status,omitempty"`

			// Timezone Timezone to format the meeting start time on the .
			Timezone *string `json:"timezone,omitempty"`

			// Topic Meeting topic.
			Topic *string `json:"topic,omitempty"`

			// TrackingFields Tracking fields
			TrackingFields *[]struct {
				// Field Label of the tracking field.
				Field *string `json:"field,omitempty"`

				// Value Value for the field.
				Value *string `json:"value,omitempty"`

				// Visible Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
				//
				// `true`: Tracking field is visible.
				//
				//
				// `false`: Tracking field is not visible to the users when they look at the meeting details in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
				Visible *bool `json:"visible,omitempty"`
			} `json:"tracking_fields,omitempty"`

			// Type Meeting Types:
			//  `1` - Instant meeting.
			//  `2` - Scheduled meeting.
			//  `3` - Recurring meeting with no fixed time.
			//  `4` - PMI Meeting
			//
			// `8` - Recurring meeting with a fixed time.
			Type *int `json:"type,omitempty"`

			// Uuid Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). You can retrieve a list of UUIDs from past meeting instances using the [**List past meeting instances**](/docs/api-reference/zoom-api/methods#operation/pastMeetings) API. [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a `/` or contains `//` in it.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingUpdateResponse parses an HTTP response from a MeetingUpdateWithResponse call
func ParseMeetingUpdateResponse(rsp *http.Response) (*MeetingUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateBatchPollsResponse parses an HTTP response from a CreateBatchPollsWithResponse call
func ParseCreateBatchPollsResponse(rsp *http.Response) (*CreateBatchPollsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBatchPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Polls *[]struct {
				// Anonymous Whether to allow meeting participants to answer poll questions anonymously:
				// * `true` &mdash; Anonymous polls enabled.
				// * `false` &mdash; Participants cannot answer poll questions anonymously.
				Anonymous *bool `json:"anonymous,omitempty"`

				// Id Meeting Poll ID
				Id *string `json:"id,omitempty"`

				// PollType The type of poll:
				// * `1` &mdash; Poll.
				// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
				// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
				PollType *int `json:"poll_type,omitempty"`

				// Questions Information about the poll's questions.
				Questions *[]struct {
					// AnswerMaxCharacter The allowed maximum number of characters. This field only returns for `short_answer` and `long_answer` polls.
					AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

					// AnswerMinCharacter The allowed minimum number of characters. This field only returns for `short_answer` and `long_answer` polls.
					AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

					// AnswerRequired Whether participants must answer the question:
					// * `true` &mdash; The participant must answer the question.
					// * `false` &mdash; The participant does not need to answer the question.
					AnswerRequired *bool `json:"answer_required,omitempty"`

					// Answers The poll question's available answers.
					Answers *[]string `json:"answers,omitempty"`

					// CaseSensitive Whether the correct answer is case sensitive. This field only returns for `fill_in_the_blank` polls:
					// * `true` &mdash; The answer is case-sensitive.
					// * `false` &mdash; The answer is not case-sensitive.
					CaseSensitive *bool `json:"case_sensitive,omitempty"`

					// Name The poll question's title. For `fill_in_the_blank` polls, this field is the poll's question.
					Name *string `json:"name,omitempty"`

					// Prompts Information about the prompt questions. This object only returns for `matching` and `rank_order` polls.
					Prompts *[]struct {
						// PromptQuestion The question prompt's title.
						PromptQuestion *string `json:"prompt_question,omitempty"`

						// PromptRightAnswers The question prompt's correct answers.
						PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
					} `json:"prompts,omitempty"`

					// RatingMaxLabel The high score label used for the `rating_max_value` field. This field only returns for `rating_scale` polls.
					RatingMaxLabel *string `json:"rating_max_label,omitempty"`

					// RatingMaxValue The rating scale's maximum value. This field only returns for `rating_scale` polls.
					RatingMaxValue *int `json:"rating_max_value,omitempty"`

					// RatingMinLabel The low score label used for the `rating_min_value` field. This field only returns for `rating_scale` polls.
					RatingMinLabel *string `json:"rating_min_label,omitempty"`

					// RatingMinValue The rating scale's minimum value. This field only returns for `rating_scale` polls.
					RatingMinValue *int `json:"rating_min_value,omitempty"`

					// RightAnswers The poll question's correct answer(s).
					RightAnswers *[]string `json:"right_answers,omitempty"`

					// ShowAsDropdown Whether to display the radio selection as a drop-down box:
					// * `true` &mdash; Show as a drop-down box.
					// * `false` &mdash; Do not show as a drop-down box.
					ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

					// Type The poll's question and answer type:
					// * `single` &mdash; Single choice.
					// * `multiple` &mdash; Multiple choice.
					// * `matching` &mdash; Matching.
					// * `rank_order` &mdash; Rank order.
					// * `short_answer` &mdash; Short answer.
					// * `long_answer` &mdash; Long answer.
					// * `fill_in_the_blank` &mdash; Fill in the blank.
					// * `rating_scale` &mdash; Rating scale.
					Type *string `json:"type,omitempty"`
				} `json:"questions,omitempty"`

				// Status Status of the Meeting Poll:
				//  `notstart` - Poll not started
				//  `started` - Poll started
				//  `ended` - Poll ended
				//  `sharing` - Sharing poll results
				Status *string `json:"status,omitempty"`

				// Title Title for the Poll
				Title *string `json:"title,omitempty"`
			} `json:"polls,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseAddBatchRegistrantsResponse parses an HTTP response from a AddBatchRegistrantsWithResponse call
func ParseAddBatchRegistrantsResponse(rsp *http.Response) (*AddBatchRegistrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddBatchRegistrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Registrants *[]struct {
				// Email Email address of the registrant.
				Email *string `json:"email,omitempty"`

				// JoinUrl Unique URL using which registrant can join the meeting.
				JoinUrl *string `json:"join_url,omitempty"`

				// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
				ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

				// RegistrantId Unique identifier of the registrant.
				RegistrantId *string `json:"registrant_id,omitempty"`
			} `json:"registrants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMeetingInvitationResponse parses an HTTP response from a MeetingInvitationWithResponse call
func ParseMeetingInvitationResponse(rsp *http.Response) (*MeetingInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Invitation Meeting invitation.
			Invitation *string `json:"invitation,omitempty"`

			// SipLinks A list of SIP phone addresses.
			SipLinks *[]string `json:"sip_links,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingInviteLinksCreateResponse parses an HTTP response from a MeetingInviteLinksCreateWithResponse call
func ParseMeetingInviteLinksCreateResponse(rsp *http.Response) (*MeetingInviteLinksCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingInviteLinksCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Attendees The attendee list.
			Attendees *[]struct {
				// JoinUrl The URL to join the meeting.
				JoinUrl *string `json:"join_url,omitempty"`

				// Name The user's display name.
				Name *string `json:"name,omitempty"`
			} `json:"attendees,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMeetingLiveStreamingJoinTokenResponse parses an HTTP response from a MeetingLiveStreamingJoinTokenWithResponse call
func ParseMeetingLiveStreamingJoinTokenResponse(rsp *http.Response) (*MeetingLiveStreamingJoinTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingLiveStreamingJoinTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExpireIn The number of seconds the join token is valid for before it expires. This value always returns `120`.
			ExpireIn *int64 `json:"expire_in,omitempty"`

			// Token The join token.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingLocalArchivingArchiveTokenResponse parses an HTTP response from a MeetingLocalArchivingArchiveTokenWithResponse call
func ParseMeetingLocalArchivingArchiveTokenResponse(rsp *http.Response) (*MeetingLocalArchivingArchiveTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingLocalArchivingArchiveTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExpireIn The number of seconds the archive token is valid for before it expires. This value always returns `120`.
			ExpireIn *int64 `json:"expire_in,omitempty"`

			// Token The archive token.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingLocalRecordingJoinTokenResponse parses an HTTP response from a MeetingLocalRecordingJoinTokenWithResponse call
func ParseMeetingLocalRecordingJoinTokenResponse(rsp *http.Response) (*MeetingLocalRecordingJoinTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingLocalRecordingJoinTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExpireIn The number of seconds the join token is valid for before it expires. This value always returns `120`.
			ExpireIn *int64 `json:"expire_in,omitempty"`

			// Token The join token.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMeetingLiveStreamDetailsResponse parses an HTTP response from a GetMeetingLiveStreamDetailsWithResponse call
func ParseGetMeetingLiveStreamDetailsResponse(rsp *http.Response) (*GetMeetingLiveStreamDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeetingLiveStreamDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// PageUrl Live streaming page URL. This is the URL using which anyone can view the livestream of the meeting.
			PageUrl *string `json:"page_url,omitempty"`

			// Resolution The number of pixels in each dimension that the video camera can display.
			Resolution *string `json:"resolution,omitempty"`

			// StreamKey Stream Key.
			StreamKey *string `json:"stream_key,omitempty"`

			// StreamUrl Stream URL.
			StreamUrl *string `json:"stream_url,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingLiveStreamUpdateResponse parses an HTTP response from a MeetingLiveStreamUpdateWithResponse call
func ParseMeetingLiveStreamUpdateResponse(rsp *http.Response) (*MeetingLiveStreamUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingLiveStreamUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingLiveStreamStatusUpdateResponse parses an HTTP response from a MeetingLiveStreamStatusUpdateWithResponse call
func ParseMeetingLiveStreamStatusUpdateResponse(rsp *http.Response) (*MeetingLiveStreamStatusUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingLiveStreamStatusUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingPollsResponse parses an HTTP response from a MeetingPollsWithResponse call
func ParseMeetingPollsResponse(rsp *http.Response) (*MeetingPollsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Polls Array of Polls
			Polls *[]struct {
				// Anonymous Allow meeting participants to answer poll questions anonymously.
				//
				// This value defaults to `false`.
				Anonymous *bool `json:"anonymous,omitempty"`

				// Id ID of Poll
				Id *string `json:"id,omitempty"`

				// PollType The type of poll:
				// * `1` &mdash; Poll.
				// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
				// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
				//
				//  This value defaults to `1`.
				PollType *int `json:"poll_type,omitempty"`

				// Questions Information about the poll's questions.
				Questions *[]struct {
					// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
					// * For `short_answer` polls, a maximum of 500 characters.
					// * For `long_answer` polls, a maximum of 2,000 characters.
					AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

					// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
					AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

					// AnswerRequired Whether participants must answer the question:
					// * `true` &mdash; The participant must answer the question.
					// * `false` &mdash; The participant does not need to answer the question.
					//
					// **Note:**
					// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
					// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
					AnswerRequired *bool `json:"answer_required,omitempty"`

					// Answers The poll question's available answers. This field requires a **minimum** of two answers.
					//
					// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
					// * For `matching` polls, you can only provide a maximum of 16 answers.
					// * For `rank_order` polls, you can only provide a maximum of seven answers.
					Answers *[]string `json:"answers,omitempty"`

					// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
					// * `true` &mdash; The answer is case-sensitive.
					// * `false` &mdash; The answer is not case-sensitive.
					//
					// This value defaults to `false`.
					CaseSensitive *bool `json:"case_sensitive,omitempty"`

					// Name The poll question, up to 255 characters.
					//
					// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
					Name *string `json:"name,omitempty"`

					// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
					Prompts *[]struct {
						// PromptQuestion The question prompt's title.
						PromptQuestion *string `json:"prompt_question,omitempty"`

						// PromptRightAnswers The question prompt's correct answers:
						// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
						// * For `rank_order` polls, you can only provide one correct answer.
						PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
					} `json:"prompts,omitempty"`

					// RatingMaxLabel The high score label used for the `rating_max_value` field.
					//
					// This field only applies to the `rating_scale` poll.
					RatingMaxLabel *string `json:"rating_max_label,omitempty"`

					// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
					//
					// This field only applies to the `rating_scale` poll.
					RatingMaxValue *int `json:"rating_max_value,omitempty"`

					// RatingMinLabel The low score label used for the `rating_min_value` field.
					//
					// This field only applies to the `rating_scale` poll.
					RatingMinLabel *string `json:"rating_min_label,omitempty"`

					// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
					//
					// This field only applies to the `rating_scale` poll.
					RatingMinValue *int `json:"rating_min_value,omitempty"`

					// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
					//
					//  For `single` and `matching` polls, this field only accepts one answer.
					RightAnswers *[]string `json:"right_answers,omitempty"`

					// ShowAsDropdown Whether to display the radio selection as a drop-down box:
					// * `true` &mdash; Show as a drop-down box.
					// * `false` &mdash; Do not show as a drop-down box.
					//
					// This value defaults to `false`.
					ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

					// Type The poll's question and answer type:
					// * `single` &mdash; Single choice.
					// * `multiple` &mdash; Multiple choice.
					// * `matching` &mdash; Matching.
					// * `rank_order` &mdash; Rank order.
					// * `short_answer` &mdash; Short answer.
					// * `long_answer` &mdash; Long answer.
					// * `fill_in_the_blank` &mdash; Fill in the blank.
					// * `rating_scale` &mdash; Rating scale.
					Type *string `json:"type,omitempty"`
				} `json:"questions,omitempty"`

				// Status Status of Poll:
				//  `notstart` - Poll not started
				//  `started` - Poll started
				//  `ended` - Poll ended
				//  `sharing` - Sharing poll results
				Status *string `json:"status,omitempty"`

				// Title The poll's title, up to 64 characters.
				Title *string `json:"title,omitempty"`
			} `json:"polls,omitempty"`

			// TotalRecords The number of all records available across pages
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingPollCreateResponse parses an HTTP response from a MeetingPollCreateWithResponse call
func ParseMeetingPollCreateResponse(rsp *http.Response) (*MeetingPollCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingPollCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Anonymous Allow meeting participants to answer poll questions anonymously.
			//
			// This value defaults to `false`.
			Anonymous *bool `json:"anonymous,omitempty"`

			// Id Meeting Poll ID
			Id *string `json:"id,omitempty"`

			// PollType The type of poll:
			// * `1` &mdash; Poll.
			// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
			// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
			//
			//  This value defaults to `1`.
			PollType *int `json:"poll_type,omitempty"`

			// Questions Information about the poll's questions.
			Questions *[]struct {
				// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
				// * For `short_answer` polls, a maximum of 500 characters.
				// * For `long_answer` polls, a maximum of 2,000 characters.
				AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

				// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
				AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

				// AnswerRequired Whether participants must answer the question:
				// * `true` &mdash; The participant must answer the question.
				// * `false` &mdash; The participant does not need to answer the question.
				//
				// **Note:**
				// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
				// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
				AnswerRequired *bool `json:"answer_required,omitempty"`

				// Answers The poll question's available answers. This field requires a **minimum** of two answers.
				//
				// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
				// * For `matching` polls, you can only provide a maximum of 16 answers.
				// * For `rank_order` polls, you can only provide a maximum of seven answers.
				Answers *[]string `json:"answers,omitempty"`

				// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
				// * `true` &mdash; The answer is case-sensitive.
				// * `false` &mdash; The answer is not case-sensitive.
				//
				// This value defaults to `false`.
				CaseSensitive *bool `json:"case_sensitive,omitempty"`

				// Name The poll question, up to 255 characters.
				//
				// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
				Name *string `json:"name,omitempty"`

				// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
				Prompts *[]struct {
					// PromptQuestion The question prompt's title.
					PromptQuestion *string `json:"prompt_question,omitempty"`

					// PromptRightAnswers The question prompt's correct answers:
					// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
					// * For `rank_order` polls, you can only provide one correct answer.
					PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
				} `json:"prompts,omitempty"`

				// RatingMaxLabel The high score label used for the `rating_max_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxLabel *string `json:"rating_max_label,omitempty"`

				// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxValue *int `json:"rating_max_value,omitempty"`

				// RatingMinLabel The low score label used for the `rating_min_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinLabel *string `json:"rating_min_label,omitempty"`

				// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinValue *int `json:"rating_min_value,omitempty"`

				// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
				//
				//  For `single` and `matching` polls, this field only accepts one answer.
				RightAnswers *[]string `json:"right_answers,omitempty"`

				// ShowAsDropdown Whether to display the radio selection as a drop-down box:
				// * `true` &mdash; Show as a drop-down box.
				// * `false` &mdash; Do not show as a drop-down box.
				//
				// This value defaults to `false`.
				ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

				// Type The poll's question and answer type:
				// * `single` &mdash; Single choice.
				// * `multiple` &mdash; Multiple choice.
				// * `matching` &mdash; Matching.
				// * `rank_order` &mdash; Rank order.
				// * `short_answer` &mdash; Short answer.
				// * `long_answer` &mdash; Long answer.
				// * `fill_in_the_blank` &mdash; Fill in the blank.
				// * `rating_scale` &mdash; Rating scale.
				Type *string `json:"type,omitempty"`
			} `json:"questions,omitempty"`

			// Status Status of the Meeting Poll:
			//  `notstart` - Poll not started
			//  `started` - Poll started
			//  `ended` - Poll ended
			//  `sharing` - Sharing poll results
			Status *string `json:"status,omitempty"`

			// Title The poll's title, up to 64 characters.
			Title *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMeetingPollDeleteResponse parses an HTTP response from a MeetingPollDeleteWithResponse call
func ParseMeetingPollDeleteResponse(rsp *http.Response) (*MeetingPollDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingPollDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingPollGetResponse parses an HTTP response from a MeetingPollGetWithResponse call
func ParseMeetingPollGetResponse(rsp *http.Response) (*MeetingPollGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingPollGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Anonymous Allow meeting participants to answer poll questions anonymously.
			//
			// This value defaults to `false`.
			Anonymous *bool `json:"anonymous,omitempty"`

			// Id Meeting Poll ID
			Id *string `json:"id,omitempty"`

			// PollType The type of poll:
			// * `1` &mdash; Poll.
			// * `2` &mdash; Advanced Poll. This feature must be enabled in your Zoom account.
			// * `3` &mdash; Quiz. This feature must be enabled in your Zoom account.
			//
			//  This value defaults to `1`.
			PollType *int `json:"poll_type,omitempty"`

			// Questions Information about the poll's questions.
			Questions *[]struct {
				// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `short_answer` and `long_answer` polls:
				// * For `short_answer` polls, a maximum of 500 characters.
				// * For `long_answer` polls, a maximum of 2,000 characters.
				AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

				// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `short_answer` and `long_answer` polls. You must provide at least a **one** character minimum value.
				AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

				// AnswerRequired Whether participants must answer the question:
				// * `true` &mdash; The participant must answer the question.
				// * `false` &mdash; The participant does not need to answer the question.
				//
				// **Note:**
				// * When the poll's `type` value is `1` (Poll), this value defaults to `true`.
				// * When the poll's `type` value is the `2` (Advanced Poll) or `3` (Quiz) values, this value defaults to `false`.
				AnswerRequired *bool `json:"answer_required,omitempty"`

				// Answers The poll question's available answers. This field requires a **minimum** of two answers.
				//
				// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
				// * For `matching` polls, you can only provide a maximum of 16 answers.
				// * For `rank_order` polls, you can only provide a maximum of seven answers.
				Answers *[]string `json:"answers,omitempty"`

				// CaseSensitive Whether the correct answer is case sensitive. This field only applies to `fill_in_the_blank` polls:
				// * `true` &mdash; The answer is case-sensitive.
				// * `false` &mdash; The answer is not case-sensitive.
				//
				// This value defaults to `false`.
				CaseSensitive *bool `json:"case_sensitive,omitempty"`

				// Name The poll question, up to 255 characters.
				//
				// For `fill_in_the_blank` polls, this field is the poll's question. For each value that the user must fill in, ensure that there are the same number of `right_answers` values.
				Name *string `json:"name,omitempty"`

				// Prompts Information about the prompt questions. This field only applies to `matching` and `rank_order` polls. You **must** provide a minimum of two prompts, up to a maximum of 10 prompts.
				Prompts *[]struct {
					// PromptQuestion The question prompt's title.
					PromptQuestion *string `json:"prompt_question,omitempty"`

					// PromptRightAnswers The question prompt's correct answers:
					// * For `matching` polls, you must provide a minimum of two correct answers, up to a maximum of 10 correct answers.
					// * For `rank_order` polls, you can only provide one correct answer.
					PromptRightAnswers *[]string `json:"prompt_right_answers,omitempty"`
				} `json:"prompts,omitempty"`

				// RatingMaxLabel The high score label used for the `rating_max_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxLabel *string `json:"rating_max_label,omitempty"`

				// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMaxValue *int `json:"rating_max_value,omitempty"`

				// RatingMinLabel The low score label used for the `rating_min_value` field.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinLabel *string `json:"rating_min_label,omitempty"`

				// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
				//
				// This field only applies to the `rating_scale` poll.
				RatingMinValue *int `json:"rating_min_value,omitempty"`

				// RightAnswers The poll question's correct answer(s). This field is **required** if the poll's `type` value is `3` (Quiz).
				//
				//  For `single` and `matching` polls, this field only accepts one answer.
				RightAnswers *[]string `json:"right_answers,omitempty"`

				// ShowAsDropdown Whether to display the radio selection as a drop-down box:
				// * `true` &mdash; Show as a drop-down box.
				// * `false` &mdash; Do not show as a drop-down box.
				//
				// This value defaults to `false`.
				ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

				// Type The poll's question and answer type:
				// * `single` &mdash; Single choice.
				// * `multiple` &mdash; Multiple choice.
				// * `matching` &mdash; Matching.
				// * `rank_order` &mdash; Rank order.
				// * `short_answer` &mdash; Short answer.
				// * `long_answer` &mdash; Long answer.
				// * `fill_in_the_blank` &mdash; Fill in the blank.
				// * `rating_scale` &mdash; Rating scale.
				Type *string `json:"type,omitempty"`
			} `json:"questions,omitempty"`

			// Status Status of the Meeting Poll:
			//  `notstart` - Poll not started
			//  `started` - Poll started
			//  `ended` - Poll ended
			//  `sharing` - Sharing poll results
			Status *string `json:"status,omitempty"`

			// Title The poll's title, up to 64 characters.
			Title *string `json:"title,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingPollUpdateResponse parses an HTTP response from a MeetingPollUpdateWithResponse call
func ParseMeetingPollUpdateResponse(rsp *http.Response) (*MeetingPollUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingPollUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingRegistrantsResponse parses an HTTP response from a MeetingRegistrantsWithResponse call
func ParseMeetingRegistrantsResponse(rsp *http.Response) (*MeetingRegistrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
			NextPageToken *string `json:"next_page_token,omitempty"`

			// PageCount The number of pages returned for the request made.
			PageCount *int `json:"page_count,omitempty"`

			// PageNumber **Deprecated.** We will no longer support this field in a future release. Instead, use the `next_page_token` for pagination.
			// Deprecated:
			PageNumber *int `json:"page_number,omitempty"`

			// PageSize The number of records returned with a single API call.
			PageSize *int `json:"page_size,omitempty"`

			// Registrants List of registrant objects.
			Registrants *[]struct {
				// Address The registrant's address.
				Address *string `json:"address,omitempty"`

				// City The registrant's city.
				City *string `json:"city,omitempty"`

				// Comments The registrant's questions and comments.
				Comments *string `json:"comments,omitempty"`

				// Country The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
				Country *string `json:"country,omitempty"`

				// CreateTime The time at which the registrant registered.
				CreateTime *time.Time `json:"create_time,omitempty"`

				// CustomQuestions Information about custom questions.
				CustomQuestions *[]struct {
					// Title The title of the custom question.
					Title *string `json:"title,omitempty"`

					// Value The custom question's response value. This has a limit of 128 characters.
					Value *string `json:"value,omitempty"`
				} `json:"custom_questions,omitempty"`

				// Email The registrant's email address. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for return value details.
				Email openapi_types.Email `json:"email"`

				// FirstName The registrant's first name.
				FirstName string `json:"first_name"`

				// Id Registrant ID.
				Id *string `json:"id,omitempty"`

				// Industry The registrant's industry.
				Industry *string `json:"industry,omitempty"`

				// JobTitle The registrant's job title.
				JobTitle *string `json:"job_title,omitempty"`

				// JoinUrl The URL using which an approved registrant can join the meeting or webinar.
				JoinUrl *string `json:"join_url,omitempty"`

				// LastName The registrant's last name.
				LastName *string `json:"last_name,omitempty"`

				// NoOfEmployees The registrant's number of employees:
				// * `1-20`
				// * `21-50`
				// * `51-100`
				// * `101-250`
				// * `251-500`
				// * `501-1,000`
				// * `1,001-5,000`
				// * `5,001-10,000`
				// * `More than 10,000`
				NoOfEmployees *string `json:"no_of_employees,omitempty"`

				// Org The registrant's organization.
				Org *string `json:"org,omitempty"`

				// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
				ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

				// Phone The registrant's phone number.
				Phone *string `json:"phone,omitempty"`

				// PurchasingTimeFrame The registrant's purchasing time frame:
				// * `Within a month`
				// * `1-3 months`
				// * `4-6 months`
				// * `More than 6 months`
				// * `No timeframe`
				PurchasingTimeFrame *string `json:"purchasing_time_frame,omitempty"`

				// RoleInPurchaseProcess The registrant's role in the purchase process:
				// * `Decision Maker`
				// * `Evaluator/Recommender`
				// * `Influencer`
				// * `Not involved`
				RoleInPurchaseProcess *string `json:"role_in_purchase_process,omitempty"`

				// State The registrant's state or province.
				State *string `json:"state,omitempty"`

				// Status The status of the registrant's registration.
				//   `approved`: User has been successfully approved for the webinar.
				//   `pending`:  The registration is still pending.
				//   `denied`: User has been denied from joining the webinar.
				Status *string `json:"status,omitempty"`

				// Zip The registrant's ZIP or postal code.
				Zip *string `json:"zip,omitempty"`
			} `json:"registrants,omitempty"`

			// TotalRecords The total number of all the records available across pages.
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingRegistrantCreateResponse parses an HTTP response from a MeetingRegistrantCreateWithResponse call
func ParseMeetingRegistrantCreateResponse(rsp *http.Response) (*MeetingRegistrantCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id The meeting ID.
			Id *int64 `json:"id,omitempty"`

			// JoinUrl The URL the registrant can use to join the meeting.
			//
			// The API will not return this field if the meeting was [created](/docs/api-reference/zoom-api/methods#operation/meetingCreate) with the `approval_type` field value of `1` (manual approval).
			JoinUrl *string `json:"join_url,omitempty"`

			// Occurrences Array of occurrence objects.
			Occurrences *[]struct {
				// Duration Duration.
				Duration *int `json:"duration,omitempty"`

				// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
				OccurrenceId *string `json:"occurrence_id,omitempty"`

				// StartTime Start time.
				StartTime *time.Time `json:"start_time,omitempty"`

				// Status Occurrence status.
				Status *string `json:"status,omitempty"`
			} `json:"occurrences,omitempty"`

			// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
			ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

			// RegistrantId The registrant's ID.
			RegistrantId *string `json:"registrant_id,omitempty"`

			// StartTime The meeting's start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Topic The meeting's topic.
			Topic *string `json:"topic,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMeetingRegistrantsQuestionsGetResponse parses an HTTP response from a MeetingRegistrantsQuestionsGetWithResponse call
func ParseMeetingRegistrantsQuestionsGetResponse(rsp *http.Response) (*MeetingRegistrantsQuestionsGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantsQuestionsGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CustomQuestions Array of Registrant Custom Questions
			CustomQuestions *[]struct {
				// Answers Answer choices for the question. Can not be used for `short` question type as this type of question requires registrants to type out the answer.
				Answers *[]string `json:"answers,omitempty"`

				// Required Indicates whether or not the custom question is required to be answered by participants or not.
				Required *bool `json:"required,omitempty"`

				// Title Title of the custom question.
				Title *string `json:"title,omitempty"`

				// Type Type of the question being asked.
				Type *string `json:"type,omitempty"`
			} `json:"custom_questions,omitempty"`

			// Questions Array of Registrant Questions
			Questions *[]struct {
				// FieldName Field name of the question.
				FieldName *string `json:"field_name,omitempty"`

				// Required Indicates whether or not the displayed fields are required to be filled out by registrants.
				Required *bool `json:"required,omitempty"`
			} `json:"questions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingRegistrantQuestionUpdateResponse parses an HTTP response from a MeetingRegistrantQuestionUpdateWithResponse call
func ParseMeetingRegistrantQuestionUpdateResponse(rsp *http.Response) (*MeetingRegistrantQuestionUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantQuestionUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingRegistrantStatusResponse parses an HTTP response from a MeetingRegistrantStatusWithResponse call
func ParseMeetingRegistrantStatusResponse(rsp *http.Response) (*MeetingRegistrantStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingregistrantdeleteResponse parses an HTTP response from a MeetingregistrantdeleteWithResponse call
func ParseMeetingregistrantdeleteResponse(rsp *http.Response) (*MeetingregistrantdeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingregistrantdeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingRegistrantGetResponse parses an HTTP response from a MeetingRegistrantGetWithResponse call
func ParseMeetingRegistrantGetResponse(rsp *http.Response) (*MeetingRegistrantGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingRegistrantGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Address The registrant's address.
			Address *string `json:"address,omitempty"`

			// City The registrant's city.
			City *string `json:"city,omitempty"`

			// Comments The registrant's questions and comments.
			Comments *string `json:"comments,omitempty"`

			// Country The registrant's two-letter [country code](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries).
			Country *string `json:"country,omitempty"`

			// CreateTime The registrant's registration date and time.
			CreateTime *time.Time `json:"create_time,omitempty"`

			// CustomQuestions Information about custom questions.
			CustomQuestions *[]struct {
				// Title The title of the custom question.
				Title *string `json:"title,omitempty"`

				// Value The custom question's response value. This has a limit of 128 characters.
				Value *string `json:"value,omitempty"`
			} `json:"custom_questions,omitempty"`

			// Email The registrant's email address. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for return value details.
			Email openapi_types.Email `json:"email"`

			// FirstName The registrant's first name.
			FirstName string  `json:"first_name"`
			Id        *string `json:"id,omitempty"`

			// Industry The registrant's industry.
			Industry *string `json:"industry,omitempty"`

			// JobTitle The registrant's job title.
			JobTitle *string `json:"job_title,omitempty"`

			// JoinUrl The URL with which the approved registrant can join the meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// LastName The registrant's last name.
			LastName *string `json:"last_name,omitempty"`

			// NoOfEmployees The registrant's number of employees:
			// * `1-20`
			// * `21-50`
			// * `51-100`
			// * `101-250`
			// * `251-500`
			// * `501-1,000`
			// * `1,001-5,000`
			// * `5,001-10,000`
			// * `More than 10,000`
			NoOfEmployees *string `json:"no_of_employees,omitempty"`

			// Org The registrant's organization.
			Org *string `json:"org,omitempty"`

			// ParticipantPinCode The participant PIN code is used to authenticate audio participants before they join the meeting.
			ParticipantPinCode *int64 `json:"participant_pin_code,omitempty"`

			// Phone The registrant's phone number.
			Phone *string `json:"phone,omitempty"`

			// PurchasingTimeFrame The registrant's purchasing time frame:
			// * `Within a month`
			// * `1-3 months`
			// * `4-6 months`
			// * `More than 6 months`
			// * `No timeframe`
			PurchasingTimeFrame *string `json:"purchasing_time_frame,omitempty"`

			// RoleInPurchaseProcess The registrant's role in the purchase process:
			// * `Decision Maker`
			// * `Evaluator/Recommender`
			// * `Influencer`
			// * `Not involved`
			RoleInPurchaseProcess *string `json:"role_in_purchase_process,omitempty"`

			// State The registrant's state or province.
			State *string `json:"state,omitempty"`

			// Status The registrant's registration status:
			// * `approved` &mdash; The registrant is approved to join the meeting.
			// * `pending` &mdash; The registrant's registration is pending.
			// * `denied` &mdash; The registrant was declined to join the meeting.
			Status *string `json:"status,omitempty"`

			// Zip The registrant's ZIP or postal code.
			Zip *string `json:"zip,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSipDialingWithPasscodeResponse parses an HTTP response from a GetSipDialingWithPasscodeWithResponse call
func ParseGetSipDialingWithPasscodeResponse(rsp *http.Response) (*GetSipDialingWithPasscodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSipDialingWithPasscodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExpireIn The number of seconds the encoded SIP URI is valid before it expires.
			ExpireIn *int64 `json:"expire_in,omitempty"`

			// PaidCrcPlanParticipant Whether the API caller has a CRC (Conference Room Connector) plan.
			PaidCrcPlanParticipant *bool `json:"paid_crc_plan_participant,omitempty"`

			// ParticipantIdentifierCode This value identifies the meeting participant. It is automatically embedded in the SIP URI if the API caller has a CRC (Conference Room Connector) plan.
			ParticipantIdentifierCode *string `json:"participant_identifier_code,omitempty"`

			// SipDialing The meeting's encoded SIP URI.
			SipDialing *string `json:"sip_dialing,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingStatusResponse parses an HTTP response from a MeetingStatusWithResponse call
func ParseMeetingStatusResponse(rsp *http.Response) (*MeetingStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingSurveyDeleteResponse parses an HTTP response from a MeetingSurveyDeleteWithResponse call
func ParseMeetingSurveyDeleteResponse(rsp *http.Response) (*MeetingSurveyDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingSurveyDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingSurveyGetResponse parses an HTTP response from a MeetingSurveyGetWithResponse call
func ParseMeetingSurveyGetResponse(rsp *http.Response) (*MeetingSurveyGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingSurveyGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// CustomSurvey Information about the customized meeting survey.
			CustomSurvey *struct {
				// Anonymous Allow participants to anonymously answer survey questions.
				//
				//  This value defaults to `true`.
				Anonymous *bool `json:"anonymous,omitempty"`

				// Questions Information about the meeting survey's questions.
				Questions *[]struct {
					// AnswerMaxCharacter The allowed maximum number of characters. This field only applies to `long_answer` survey, a maximum of 2,000 characters.
					AnswerMaxCharacter *int `json:"answer_max_character,omitempty"`

					// AnswerMinCharacter The allowed minimum number of characters. This field only applies to `long_answer` survey. You must provide at least a **one** character minimum value.
					AnswerMinCharacter *int `json:"answer_min_character,omitempty"`

					// AnswerRequired Whether participants must answer the question:
					// * `true` &mdash; The participant must answer the question.
					// * `false` &mdash; The participant does not need to answer the question.
					//
					//  This value defaults to `false`.
					AnswerRequired *bool `json:"answer_required,omitempty"`

					// Answers The survey question's available answers. This field requires a **minimum** of two answers.
					//
					// * For `single` and `multiple` polls, you can only provide a maximum of 10 answers.
					// * For `matching` polls, you can only provide a maximum of 16 answers.
					// * For `rank_order` polls, you can only provide a maximum of seven answers.
					Answers *[]string `json:"answers,omitempty"`

					// Name The survey question, up to 255 characters.
					Name *string `json:"name,omitempty"`

					// RatingMaxLabel The high score label used for the `rating_max_value` field.
					//
					//  This field only applies to the `rating_scale` survey.
					RatingMaxLabel *string `json:"rating_max_label,omitempty"`

					// RatingMaxValue The rating scale's maximum value, up to a maximum value of 10.
					//
					//  This field only applies to the `rating_scale` survey.
					RatingMaxValue *int `json:"rating_max_value,omitempty"`

					// RatingMinLabel The low score label used for the `rating_min_value` field.
					//
					// T his field only applies to the `rating_scale` survey.
					RatingMinLabel *string `json:"rating_min_label,omitempty"`

					// RatingMinValue The rating scale's minimum value. This value cannot be less than zero.
					//
					//  This field only applies to the `rating_scale` survey.
					RatingMinValue *int `json:"rating_min_value,omitempty"`

					// ShowAsDropdown Display the radio selection as a drop-down box:
					// * `true` &mdash; Show as a drop-down box.
					// * `false` &mdash; Do not show as a drop-down box.
					//
					//  This value defaults to `false`.
					ShowAsDropdown *bool `json:"show_as_dropdown,omitempty"`

					// Type The survey's question and answer type:
					// * `single` &mdash; Single choice.
					// * `multiple` &mdash; Multiple choice.
					// * `rating_scale` &mdash; Rating scale.
					// * `long_answer` &mdash; Long answer.
					Type *string `json:"type,omitempty"`
				} `json:"questions,omitempty"`
			} `json:"custom_survey,omitempty"`

			// ShowInTheBrowser Whether the **Show in the browser when the meeting ends** option is enabled:
			// * `true` &mdash; Enabled.
			// * `false` &mdash; Disabled.
			//
			//  This value defaults to `true`.
			ShowInTheBrowser *bool `json:"show_in_the_browser,omitempty"`

			// ThirdPartySurvey The link to the third party meeting survey.
			ThirdPartySurvey *string `json:"third_party_survey,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingSurveyUpdateResponse parses an HTTP response from a MeetingSurveyUpdateWithResponse call
func ParseMeetingSurveyUpdateResponse(rsp *http.Response) (*MeetingSurveyUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingSurveyUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseMeetingTokenResponse parses an HTTP response from a MeetingTokenWithResponse call
func ParseMeetingTokenResponse(rsp *http.Response) (*MeetingTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token The generated meeting token.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePastMeetingDetailsResponse parses an HTTP response from a PastMeetingDetailsWithResponse call
func ParsePastMeetingDetailsResponse(rsp *http.Response) (*PastMeetingDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PastMeetingDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Dept The meeting host's department.
			Dept *string `json:"dept,omitempty"`

			// Duration The meeting's duration, in minutes.
			Duration *int `json:"duration,omitempty"`

			// EndTime The meeting's end date and time.
			EndTime *time.Time `json:"end_time,omitempty"`

			// HostId The host's ID.
			HostId *string `json:"host_id,omitempty"`

			// Id The [meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID).
			Id *int64 `json:"id,omitempty"`

			// ParticipantsCount The number of meeting participants.
			ParticipantsCount *int `json:"participants_count,omitempty"`

			// Source Whether the meeting was created directly through Zoom or via an API request:
			// * If the meeting was created via an OAuth app, this field returns the OAuth app's name.
			// * If the meeting was created via JWT or the Zoom Web Portal, this returns the `Zoom` value.
			Source *string `json:"source,omitempty"`

			// StartTime The meeting's start date and time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Topic The meeting's topic.
			Topic *string `json:"topic,omitempty"`

			// TotalMinutes The total number of minutes attended by the meeting's host and participants.
			TotalMinutes *int `json:"total_minutes,omitempty"`

			// Type The meeting type:
			// * `0` &mdash; A prescheduled meeting.
			// * `1` &mdash; An instant meeting.
			// * `2` &mdash; A scheduled meeting.
			// * `3` &mdash; A recurring meeting with no fixed time.
			// * `4` &mdash; A [personal meeting room](https://support.zoom.us/hc/en-us/articles/201362843).
			// * `7` &mdash; A [PAC (Personal Audio Conference)](https://support.zoom.us/hc/en-us/articles/205172455-Hosting-a-Personal-Audio-Conference-PAC-meeting) meeting.
			// * `8` &mdash; A recurring meeting with a fixed time.
			Type *int `json:"type,omitempty"`

			// UserEmail The user's email address.
			UserEmail *openapi_types.Email `json:"user_email,omitempty"`

			// UserName The user's display name.
			UserName *string `json:"user_name,omitempty"`

			// Uuid The meeting's UUID. You **must** [double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) this value if the meeting UUID begins with a `/` character or contains the `//` character.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePastMeetingsResponse parses an HTTP response from a PastMeetingsWithResponse call
func ParsePastMeetingsResponse(rsp *http.Response) (*PastMeetingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PastMeetingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Meetings List of ended meeting instances.
			Meetings *[]struct {
				// StartTime Start time
				StartTime *time.Time `json:"start_time,omitempty"`

				// Uuid Meeting UUID. Unique meeting ID. Each meeting instance will generate its own Meeting UUID (i.e., after a meeting ends, a new UUID will be generated for the next instance of the meeting). [Double encode](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#meeting-id-and-uuid) your UUID when using it for API calls if the UUID begins with a '/'or contains '//' in it.
				//
				Uuid *string `json:"uuid,omitempty"`
			} `json:"meetings,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePastMeetingParticipantsResponse parses an HTTP response from a PastMeetingParticipantsWithResponse call
func ParsePastMeetingParticipantsResponse(rsp *http.Response) (*PastMeetingParticipantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PastMeetingParticipantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
			NextPageToken *string `json:"next_page_token,omitempty"`

			// PageCount The number of pages returned for the request made.
			PageCount *int `json:"page_count,omitempty"`

			// PageSize The number of records returned within a single API call.
			PageSize *int `json:"page_size,omitempty"`

			// Participants The Array of meeting participant objects.
			Participants *[]struct {
				// Duration The participant's duration.
				Duration *int `json:"duration,omitempty"`

				// Failover Indicates if failover happened during the meeting.
				Failover *bool `json:"failover,omitempty"`

				// Id Universal unique identifier of the participant. It is the same as the User ID of the participant if the participant joins the meeting by logging into Zoom. If the participant joins the meeting without logging in, the value of this field will be blank.
				Id *string `json:"id,omitempty"`

				// JoinTime The participant's join time.
				JoinTime *time.Time `json:"join_time,omitempty"`

				// LeaveTime The participant's leave time.
				LeaveTime *time.Time `json:"leave_time,omitempty"`

				// Name The participant's display name.
				Name *string `json:"name,omitempty"`

				// RegistrantId The participant's unique registrant ID. This field only returns if you pass the `registrant_id` value for the `include_fields` query parameter.
				//
				// This field does not return if the `type` query parameter is the `live` value.
				RegistrantId *string `json:"registrant_id,omitempty"`

				// Status The participant's status.
				// * `in_meeting` &mdash; In a meeting.
				// * `in_waiting_room` &mdash; In a waiting room.
				Status *string `json:"status,omitempty"`

				// UserEmail The email address of the user. If the participant is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
				UserEmail *string `json:"user_email,omitempty"`

				// UserId The participant's ID. This is a unique ID assigned to the participant joining a meeting and is valid for that meeting only.
				UserId *string `json:"user_id,omitempty"`
			} `json:"participants,omitempty"`

			// TotalRecords The number of all records available across pages.
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPastMeetingPollsResponse parses an HTTP response from a ListPastMeetingPollsWithResponse call
func ParseListPastMeetingPollsResponse(rsp *http.Response) (*ListPastMeetingPollsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPastMeetingPollsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
			Id        *int64 `json:"id,omitempty"`
			Questions *[]struct {
				// Email Email address of the user who submitted answers to the poll. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
				Email *string `json:"email,omitempty"`

				// Name Name of the user who submitted answers to the poll. If &quot;anonymous&quot; option is enabled for a poll, the participant's polling information will be kept anonymous and the value of `name` field will be &quot;Anonymous Attendee&quot;.
				Name            *string `json:"name,omitempty"`
				QuestionDetails *[]struct {
					// Answer Answer submitted by the user.
					Answer *string `json:"answer,omitempty"`

					// DateTime Date and time at which the answer to the poll was submitted.
					DateTime *time.Time `json:"date_time,omitempty"`

					// PollingId Unique identifier of the poll.
					PollingId *string `json:"polling_id,omitempty"`

					// Question Question asked during the poll.
					Question *string `json:"question,omitempty"`
				} `json:"question_details,omitempty"`
			} `json:"questions,omitempty"`

			// StartTime The start time of the meeting.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Uuid Meeting UUID.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPastMeetingQAResponse parses an HTTP response from a ListPastMeetingQAWithResponse call
func ParseListPastMeetingQAResponse(rsp *http.Response) (*ListPastMeetingQAResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPastMeetingQAResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
			Id        *int64 `json:"id,omitempty"`
			Questions *[]struct {
				// Email The user's email address. If the user is **not** part of the host's account, this returns an empty string value, with some exceptions. See [Email address display rules](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#email-address) for details.
				Email *string `json:"email,omitempty"`

				// Name The user's name. If &quot;anonymous&quot; option is enabled for the Q&amp;A, the participant's information is be kept anonymous and the value of `name` field is &quot;Anonymous Attendee&quot;.
				Name            *string `json:"name,omitempty"`
				QuestionDetails *[]struct {
					// Answer An answer submitted for the question. The value is 'live answered' if this is a live answer.
					Answer *string `json:"answer,omitempty"`

					// Question A question asked during the Q&amp;A.
					Question *string `json:"question,omitempty"`
				} `json:"question_details,omitempty"`
			} `json:"questions,omitempty"`

			// StartTime The meeting's start time.
			StartTime *time.Time `json:"start_time,omitempty"`

			// Uuid Meeting UUID.
			Uuid *string `json:"uuid,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUsersResponse parses an HTTP response from a UsersWithResponse call
func ParseUsersResponse(rsp *http.Response) (*UsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// NextPageToken The next page token is used to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. The expiration period for this token is 15 minutes.
			NextPageToken *string `json:"next_page_token,omitempty"`

			// PageCount The number of pages returned for the request made.
			PageCount *int `json:"page_count,omitempty"`

			// PageNumber The page number of the current results.
			PageNumber *int `json:"page_number,omitempty"`

			// PageSize The number of records returned within a single API call.
			PageSize *int `json:"page_size,omitempty"`

			// TotalRecords The total number of all the records available across pages.
			TotalRecords *int `json:"total_records,omitempty"`

			// Users Information about the users.
			Users *[]struct {
				// CreatedAt The date and time at which this user's latest login type was created.
				// Deprecated:
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// CustomAttributes Information about the user's custom attributes.
				//
				// This field is **only** returned if users are assigned custom attributes and you provided the `custom_attributes` value for the `include_fields` query parameter in the API request.
				CustomAttributes *[]struct {
					// Key The custom attribute's unique ID.
					Key *string `json:"key,omitempty"`

					// Name The custom attribute's name.
					Name *string `json:"name,omitempty"`

					// Value The custom attribute's value.
					Value *string `json:"value,omitempty"`
				} `json:"custom_attributes,omitempty"`

				// Dept The user's department.
				Dept *string `json:"dept,omitempty"`

				// DisplayName The user's display name.
				DisplayName *string `json:"display_name,omitempty"`

				// Email The user's email address.
				Email openapi_types.Email `json:"email"`

				// EmployeeUniqueId The employee's unique ID. The this field only returns when:
				// * SAML single sign-on (SSO) is enabled.
				// * The `login_type` value is `101` (SSO).
				EmployeeUniqueId *string `json:"employee_unique_id,omitempty"`

				// FirstName The user's first name.
				FirstName *string `json:"first_name,omitempty"`

				// GroupIds The IDs of groups where the user is a member.
				GroupIds *[]string `json:"group_ids,omitempty"`

				// Id The user's ID.
				//
				// The API does **not** return this value for users with the `pending` status.
				Id *string `json:"id,omitempty"`

				// ImGroupIds The IDs of IM directory groups where the user is a member.
				ImGroupIds *[]string `json:"im_group_ids,omitempty"`

				// LastClientVersion The last client version that user used to log in.
				LastClientVersion *string `json:"last_client_version,omitempty"`

				// LastLoginTime The user's last login time. This field has a three-day buffer period.
				//
				// For example, if user first logged in on `2020-01-01` and then logged out and logged in on `2020-01-02`, this value will still reflect the login time of `2020-01-01`. However, if the user logs in on `2020-01-04`, the value of this field will reflect the corresponding login time since it exceeds the three-day buffer period.
				LastLoginTime *time.Time `json:"last_login_time,omitempty"`

				// LastName The user's last name.
				LastName *string `json:"last_name,omitempty"`

				// PlanUnitedType This field is returned if the user is enrolled in the [Zoom United](https://zoom.us/pricing/zoom-bundles) plan. The license option:
				// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
				// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
				// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
				// * `8` &mdash; Zoom United Pro-United with Global Select.
				// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
				// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
				// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
				// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
				// * `256` &mdash; Zoom United Biz-United with Global Select.
				// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
				// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
				// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
				// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
				// * `8192` &mdash; Zoom United Ent-United with Global Select.
				// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
				// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
				// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
				// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
				PlanUnitedType *string `json:"plan_united_type,omitempty"`

				// Pmi The user's [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi).
				Pmi *int64 `json:"pmi,omitempty"`

				// RoleId The unique ID of the user's assigned [role](/docs/api-reference/zoom-api/methods#operation/roles).
				RoleId *string `json:"role_id,omitempty"`

				// Status The user's status:
				// * `active` &mdash; An active user.
				// * `inactive` &mdash; A deactivated user.
				// * `pending` &mdash; A pending user.
				Status *string `json:"status,omitempty"`

				// Timezone The user's timezone.
				Timezone *string `json:"timezone,omitempty"`

				// Type The user's assigned plan type:
				// * `1` &mdash; Basic.
				// * `2` &mdash; Licensed.
				// * `99` &mdash; None (this can only be set with `ssoCreate`).
				Type int `json:"type"`

				// UserCreatedAt The date and time at which this user was created.
				UserCreatedAt *time.Time `json:"user_created_at,omitempty"`

				// Verified Display whether the user's email address for the Zoom account is verified:
				// * `1` &mdash; A verified user email.
				// * `0` &mdash; The user's email **not** verified.
				Verified *int `json:"verified,omitempty"`
			} `json:"users,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserCreateResponse parses an HTTP response from a UserCreateWithResponse call
func ParseUserCreateResponse(rsp *http.Response) (*UserCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Email User email address.
			Email *string `json:"email,omitempty"`

			// FirstName The user's first name.
			FirstName *string `json:"first_name,omitempty"`

			// Id User ID.
			Id *string `json:"id,omitempty"`

			// LastName The user's last name.
			LastName *string `json:"last_name,omitempty"`

			// Type User type.
			//  `1` - Basic.
			//  `2` - Licensed.
			//  `99` - None (this can only be set with `ssoCreate`).
			Type *int `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserEmailResponse parses an HTTP response from a UserEmailWithResponse call
func ParseUserEmailResponse(rsp *http.Response) (*UserEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ExistedEmail Indicates whether or not the email already exists in Zoom.
			ExistedEmail *bool `json:"existed_email,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkUpdateFeatureResponse parses an HTTP response from a BulkUpdateFeatureWithResponse call
func ParseBulkUpdateFeatureResponse(rsp *http.Response) (*BulkUpdateFeatureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUpdateFeatureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// FailDetails The details why these users' feature was not updated successfully.
			FailDetails *[]struct {
				// Reason The reason why the feature for these users was not updated successfully.
				Reason *string `json:"reason,omitempty"`

				// UserIds The IDs of users for whom the feature was not updated successfully.
				UserIds *[]string `json:"user_ids,omitempty"`
			} `json:"fail_details,omitempty"`

			// SuccessUserIds The IDs of users for whom the feature was updated successfully
			SuccessUserIds *[]string `json:"success_user_ids,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserZakResponse parses an HTTP response from a UserZakWithResponse call
func ParseUserZakResponse(rsp *http.Response) (*UserZakResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserZakResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token The user's Zoom Access Key (ZAK).
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserSummaryResponse parses an HTTP response from a UserSummaryWithResponse call
func ParseUserSummaryResponse(rsp *http.Response) (*UserSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BasicUsersCount The number of basic users.
			BasicUsersCount *int `json:"basic_users_count,omitempty"`

			// JoinOnlyUsersCount The number of users without licenses.
			JoinOnlyUsersCount *int `json:"join_only_users_count,omitempty"`

			// LicensedUsersCount The number of licensed users.
			LicensedUsersCount *int `json:"licensed_users_count,omitempty"`

			// OnPremUsersCount The number of on-prem users.
			OnPremUsersCount *int `json:"on_prem_users_count,omitempty"`

			// PendingUsersCount The number of users with a pending activation meeting license.
			PendingUsersCount *int `json:"pending_users_count,omitempty"`

			// RoomUsersCount The number of Zoom rooms.
			RoomUsersCount *int `json:"room_users_count,omitempty"`

			// TotalUsersCount The total number of `licensed_users_count`, `basic_users_count`, `on_prem_users_count`, `join_only_users_count` and `room_users_count`.
			TotalUsersCount *int `json:"total_users_count,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserVanityNameResponse parses an HTTP response from a UserVanityNameWithResponse call
func ParseUserVanityNameResponse(rsp *http.Response) (*UserVanityNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserVanityNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Existed If `true`, it indicates that the personal meeting room with the given name exists.
			//   `false` - The room name does not exist.
			Existed *bool `json:"existed,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserDeleteResponse parses an HTTP response from a UserDeleteWithResponse call
func ParseUserDeleteResponse(rsp *http.Response) (*UserDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserResponse parses an HTTP response from a UserWithResponse call
func ParseUserResponse(rsp *http.Response) (*UserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AccountId User's account ID.
			AccountId *string `json:"account_id,omitempty"`

			// AccountNumber The user's account number.
			AccountNumber *int64 `json:"account_number,omitempty"`

			// Cluster The user's cluster.
			Cluster *string `json:"cluster,omitempty"`

			// CmsUserId CMS ID of user, only enabled for Kaltura integration.
			CmsUserId *string `json:"cms_user_id,omitempty"`

			// Company User's company.
			Company *string `json:"company,omitempty"`

			// CreatedAt The date and time at which this user's latest login type was created.
			// Deprecated:
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// CustomAttributes Custom attribute(s) that have been assigned to the user.
			CustomAttributes *[]struct {
				// Key Identifier for the custom attribute.
				Key *string `json:"key,omitempty"`

				// Name Name of the custom attribute.
				Name *string `json:"name,omitempty"`

				// Value Value of the custom attribute.
				Value *string `json:"value,omitempty"`
			} `json:"custom_attributes,omitempty"`

			// Dept Department.
			Dept *string `json:"dept,omitempty"`

			// DisplayName User's display name.
			DisplayName *string `json:"display_name,omitempty"`

			// Email User's email address.
			Email string `json:"email"`

			// EmployeeUniqueId The employee's unique ID. This field only returns when:
			// * SAML single sign-on (SSO) is enabled.
			// * The `login_type` value is `101` (SSO).
			EmployeeUniqueId *string `json:"employee_unique_id,omitempty"`

			// FirstName User's first name.
			FirstName *string `json:"first_name,omitempty"`

			// GroupIds IDs of the web groups user belongs to.
			GroupIds *[]string `json:"group_ids,omitempty"`

			// Id User ID.
			Id *string `json:"id,omitempty"`

			// ImGroupIds IM IDs of the groups user belongs to.
			ImGroupIds *[]string `json:"im_group_ids,omitempty"`
			Jid        *string   `json:"jid,omitempty"`

			// JobTitle User's job title.
			JobTitle *string `json:"job_title,omitempty"`

			// Language Default language for the Zoom Web Portal.
			Language *string `json:"language,omitempty"`

			// LastClientVersion User last login client version.
			LastClientVersion *string `json:"last_client_version,omitempty"`

			// LastLoginTime User last login time.
			LastLoginTime *time.Time `json:"last_login_time,omitempty"`

			// LastName User's last name.
			LastName *string `json:"last_name,omitempty"`

			// Location User's location.
			Location *string `json:"location,omitempty"`

			// LoginTypes The user's login method:
			//
			// `0` &mdash; Facebook OAuth&lt;/br&gt;`1` &mdash; Google OAuth&lt;/br&gt;`24` &mdash; Apple OAuth&lt;/br&gt;`27` &mdash; Microsoft OAuth&lt;/br&gt;`97` &mdash; Mobile device&lt;/br&gt;`98` &mdash; RingCentral OAuth&lt;/br&gt;`99` &mdash; API user&lt;/br&gt;`100` &mdash; Zoom Work email&lt;/br&gt;`101` &mdash; Single Sign-On (SSO)
			//
			// The following login methods are only available in China:
			//
			// `11` &mdash; Phone number&lt;/br&gt;`21` &mdash; WeChat&lt;/br&gt;`23` &mdash; Alipay
			LoginTypes *[]int `json:"login_types,omitempty"`

			// Manager The manager for the user.
			Manager *openapi_types.Email `json:"manager,omitempty"`

			// PersonalMeetingUrl User's personal meeting url.
			PersonalMeetingUrl *string `json:"personal_meeting_url,omitempty"`

			// PhoneCountry **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field.
			//   User's country for Company Phone Number.
			// Deprecated:
			PhoneCountry *string `json:"phone_country,omitempty"`

			// PhoneNumber **Note:** This field has been **deprecated** and will not be supported in the future. Use the **phone_numbers** field instead of this field.
			//   User's phone number.
			// Deprecated:
			PhoneNumber  *string `json:"phone_number,omitempty"`
			PhoneNumbers *[]struct {
				// Code The phone number's country code. For example, for United States phone numbers, this will be a `+1` value.
				Code *string `json:"code,omitempty"`

				// Country The phone number's [country ID](https://marketplace.zoom.us/docs/api-reference/other-references/abbreviation-lists#countries). For example, if the phone number provided in the `number` field is a Brazil-based number, this will be the `BR` value.
				Country *string `json:"country,omitempty"`

				// Label The phone number's label:
				// * `Mobile`
				// * `Office`
				// * `Home`
				//  * `Fax`
				Label *string `json:"label,omitempty"`

				// Number The user's phone number.
				Number *string `json:"number,omitempty"`

				// Verified Whether Zoom has verified the phone number.
				Verified *bool `json:"verified,omitempty"`
			} `json:"phone_numbers,omitempty"`

			// PicUrl The URL for user's profile picture.
			PicUrl *string `json:"pic_url,omitempty"`

			// PlanUnitedType This field is returned if the user is enrolled in the [Zoom United](https://zoom.us/pricing/zoom-bundles) plan. The license option:
			// * `1` &mdash; Zoom United Pro-United with US/CA Unlimited.
			// * `2` &mdash; Zoom United Pro-United with UK/IR Unlimited.
			// * `4` &mdash; Zoom United Pro-United with AU/NZ Unlimited.
			// * `8` &mdash; Zoom United Pro-United with Global Select.
			// * `16` &mdash; Zoom United Pro-United with Zoom Phone Pro.
			// * `32` &mdash; Zoom United Biz-United with US/CA Unlimited.
			// * `64` &mdash; Zoom United Biz-United with UK/IR Unlimited.
			// * `128` &mdash; Zoom United Biz-United with AU/NZ Unlimited.
			// * `256` &mdash; Zoom United Biz-United with Global Select.
			// * `512` &mdash; Zoom United Biz-United with Zoom Phone Pro.
			// * `1024` &mdash; Zoom United Ent-United with US/CA Unlimited.
			// * `2048` &mdash; Zoom United Ent-United with UK/IR Unlimited.
			// * `4096` &mdash; Zoom United Ent-United with AU/NZ Unlimited.
			// * `8192` &mdash; Zoom United Ent-United with Global Select.
			// * `16384` &mdash; Zoom United Ent-United with Zoom Phone Pro.
			// * `32768` &mdash; Zoom United Pro-United with JP Unlimited.
			// * `65536` &mdash; Zoom United Biz-United with JP Unlimited.
			// * `131072` &mdash; Zoom United Ent-United with JP Unlimited.
			PlanUnitedType *string `json:"plan_united_type,omitempty"`

			// Pmi [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi).
			Pmi *int64 `json:"pmi,omitempty"`

			// Pronouns The user's pronouns.
			Pronouns *string `json:"pronouns,omitempty"`

			// PronounsOption The user's display pronouns setting:
			// * `1` &mdash; Ask the user every time they join meetings and webinars.
			// * `2` &mdash; Always display pronouns in meetings and webinars.
			// * `3` &mdash; Do not display pronouns in meetings and webinars.
			PronounsOption *int `json:"pronouns_option,omitempty"`

			// RoleId Unique identifier of the [role](/docs/api-reference/zoom-api/methods#operation/roles) assigned to the user.
			RoleId *string `json:"role_id,omitempty"`

			// RoleName User's [role](https://support.zoom.us/hc/en-us/articles/115001078646-Role-Based-Access-Control) name.
			RoleName *string `json:"role_name,omitempty"`

			// Status Status of user's account.
			Status *string `json:"status,omitempty"`

			// Timezone The time zone of the user.
			Timezone *string `json:"timezone,omitempty"`

			// Type User's plan type:
			//  `1` - Basic.
			//  `2` - Licensed.
			//  `99` - None (this can only be set with `ssoCreate`).
			Type int `json:"type"`

			// UsePmi Displays `true` if user has enabled a [Personal Meeting ID (PMI)](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis#understanding-personal-meeting-id-pmi) for instant meetings, `false` otherwise.
			UsePmi *bool `json:"use_pmi,omitempty"`

			// UserCreatedAt The date and time at which this user was created.
			UserCreatedAt *time.Time `json:"user_created_at,omitempty"`

			// VanityUrl Personal meeting room URL, if the user has one.
			VanityUrl *string `json:"vanity_url,omitempty"`

			// Verified Displays whether user is verified or not.
			//
			// `1` - Account verified.
			//
			// `0` - Account not verified.
			Verified *int `json:"verified,omitempty"`

			// ZoomOneType The user's Zoom One plan option.
			//  `4` - Zoom One Enterprise.
			//  `8` - Zoom One Enterprise Plus.
			//  `16` - Zoom One Business Plus with US/CA Unlimited.
			//  `32` - Zoom One Business Plus with UK/IR Unlimited.
			//  `64` - Zoom One Business Plus with AU/NZ Unlimited.
			//  `128` - Zoom One Business Plus with Japan Unlimited.
			//  `33554432` - Zoom One Business Plus with Global Select.
			//
			//  The Zoom One plan option for Gov accounts:
			//  `4` - Zoom One Enterprise.
			//  `8` - Zoom One Enterprise Plus.
			//  `16` - Zoom One Business Plus.
			ZoomOneType *int `json:"zoom_one_type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserUpdateResponse parses an HTTP response from a UserUpdateWithResponse call
func ParseUserUpdateResponse(rsp *http.Response) (*UserUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSwitchAUsersAccountResponse parses an HTTP response from a SwitchAUsersAccountWithResponse call
func ParseSwitchAUsersAccountResponse(rsp *http.Response) (*SwitchAUsersAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SwitchAUsersAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserAssistantsDeleteResponse parses an HTTP response from a UserAssistantsDeleteWithResponse call
func ParseUserAssistantsDeleteResponse(rsp *http.Response) (*UserAssistantsDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserAssistantsDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserAssistantsResponse parses an HTTP response from a UserAssistantsWithResponse call
func ParseUserAssistantsResponse(rsp *http.Response) (*UserAssistantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserAssistantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Assistants List of User's assistants.
			Assistants *[]struct {
				// Email Assistant's email address.
				Email *string `json:"email,omitempty"`

				// Id Assistant's user ID.
				Id *string `json:"id,omitempty"`
			} `json:"assistants,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserAssistantCreateResponse parses an HTTP response from a UserAssistantCreateWithResponse call
func ParseUserAssistantCreateResponse(rsp *http.Response) (*UserAssistantCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserAssistantCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			AddAt *time.Time `json:"add_at,omitempty"`

			// Ids User ID.
			Ids *string `json:"ids,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserAssistantDeleteResponse parses an HTTP response from a UserAssistantDeleteWithResponse call
func ParseUserAssistantDeleteResponse(rsp *http.Response) (*UserAssistantDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserAssistantDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListCollaborationDevicesResponse parses an HTTP response from a ListCollaborationDevicesWithResponse call
func ParseListCollaborationDevicesResponse(rsp *http.Response) (*ListCollaborationDevicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollaborationDevicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CollaborationDevices *[]struct {
				// DeviceName Name of the Personal Zoom Room's device.
				DeviceName *string `json:"device_name,omitempty"`

				// Id Unique identifier of the device.
				Id *string `json:"id,omitempty"`

				// RoomName Name of the Personal Zoom Room.
				RoomName *string `json:"room_name,omitempty"`

				// RoomUserId Unique Identifier of the Zoom Room.
				RoomUserId *string `json:"room_user_id,omitempty"`

				// Status Status of the device. The value can be either `Online` or `Offline`.
				Status *string `json:"status,omitempty"`
			} `json:"collaboration_devices,omitempty"`

			// TotalRecords Total number of records returned.
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCollaborationDeviceResponse parses an HTTP response from a GetCollaborationDeviceWithResponse call
func ParseGetCollaborationDeviceResponse(rsp *http.Response) (*GetCollaborationDeviceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollaborationDeviceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DeviceName Name of the Personal Zoom Room's device.
			DeviceName *string `json:"device_name,omitempty"`

			// Id Unique identifier of the device.
			Id *string `json:"id,omitempty"`

			// RoomName Name of the Personal Zoom Room.
			RoomName *string `json:"room_name,omitempty"`

			// RoomUserId Unique Identifier of the Zoom Room.
			RoomUserId *string `json:"room_user_id,omitempty"`

			// Status Status of the device. The value can be either `Online` or `Offline`.
			Status *string `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserEmailUpdateResponse parses an HTTP response from a UserEmailUpdateWithResponse call
func ParseUserEmailUpdateResponse(rsp *http.Response) (*UserEmailUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserEmailUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListMeetingTemplatesResponse parses an HTTP response from a ListMeetingTemplatesWithResponse call
func ParseListMeetingTemplatesResponse(rsp *http.Response) (*ListMeetingTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListMeetingTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Templates *[]struct {
				// Id The template ID.
				Id *string `json:"id,omitempty"`

				// Name The template name.
				Name *string `json:"name,omitempty"`

				// Type The template type:
				//
				// `1`: Meeting template
				//
				// `2`: Admin meeting template
				Type *int `json:"type,omitempty"`
			} `json:"templates,omitempty"`

			// TotalRecords Total records found for this request.
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingTemplateCreateResponse parses an HTTP response from a MeetingTemplateCreateWithResponse call
func ParseMeetingTemplateCreateResponse(rsp *http.Response) (*MeetingTemplateCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingTemplateCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id The template ID.
			Id *string `json:"id,omitempty"`

			// Name The template name.
			Name *string `json:"name,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseMeetingsResponse parses an HTTP response from a MeetingsWithResponse call
func ParseMeetingsResponse(rsp *http.Response) (*MeetingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Meetings List of Meeting objects.
			Meetings *[]struct {
				// Agenda Meeting description. The length of agenda gets truncated to 250 characters when you list all meetings for a user. To view the complete agenda of a meeting, retrieve details for a single meeting, use the [**Get a meeting**](/docs/api-reference/zoom-api/methods#operation/meeting) API.
				Agenda *string `json:"agenda,omitempty"`

				// CreatedAt Time of creation.
				CreatedAt *time.Time `json:"created_at,omitempty"`

				// Duration Meeting duration.
				Duration *int `json:"duration,omitempty"`

				// HostId ID of the user who is set as the host of the meeting.
				HostId *string `json:"host_id,omitempty"`

				// Id Meeting ID - also known as the meeting number in long (int64) format.
				Id *int64 `json:"id,omitempty"`

				// JoinUrl URL using which participants can join a meeting.
				JoinUrl *string `json:"join_url,omitempty"`

				// Pmi [Personal meeting ID](https://marketplace.zoom.us/docs/api-reference/using-zoom-apis/#understanding-personal-meeting-id-pmi). This field is only returned if PMI was used to schedule the meeting.
				Pmi *string `json:"pmi,omitempty"`

				// StartTime Meeting start time.
				StartTime *time.Time `json:"start_time,omitempty"`

				// Timezone Timezone to format the meeting start time.
				Timezone *string `json:"timezone,omitempty"`

				// Topic Meeting topic.
				Topic *string `json:"topic,omitempty"`

				// Type Meeting Types:
				//  `1` - Instant meeting.
				//  `2` - Scheduled meeting.
				//  `3` - Recurring meeting with no fixed time.
				//  `8` - Recurring meeting with fixed time.
				Type *int `json:"type,omitempty"`

				// Uuid Unique Meeting ID. Each meeting instance will generate its own Meeting UUID.
				Uuid *string `json:"uuid,omitempty"`
			} `json:"meetings,omitempty"`

			// NextPageToken Use the next page token to paginate through large result sets. A next page token will be returned whenever the set of available results exceeds the current page size. This token's expiration period is 15 minutes.
			NextPageToken *string `json:"next_page_token,omitempty"`

			// PageCount The number of pages returned for the request made.
			PageCount *int `json:"page_count,omitempty"`

			// PageNumber The page number of the current results.
			PageNumber *int `json:"page_number,omitempty"`

			// PageSize The number of records returned with a single API call.
			PageSize *int `json:"page_size,omitempty"`

			// TotalRecords The total number of all the records available across pages.
			TotalRecords *int `json:"total_records,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseMeetingCreateResponse parses an HTTP response from a MeetingCreateWithResponse call
func ParseMeetingCreateResponse(rsp *http.Response) (*MeetingCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &MeetingCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Agenda Agenda
			Agenda *string `json:"agenda,omitempty"`

			// AssistantId The ID of the user who scheduled this meeting on behalf of the host.
			AssistantId *string `json:"assistant_id,omitempty"`

			// ChatJoinUrl The URL to join the chat.
			ChatJoinUrl *string `json:"chat_join_url,omitempty"`

			// CreatedAt The date and time at which this meeting was created.
			CreatedAt *time.Time `json:"created_at,omitempty"`

			// Duration Meeting duration.
			Duration *int `json:"duration,omitempty"`

			// H323Password H.323/SIP room system password
			H323Password *string `json:"h323_password,omitempty"`

			// HostEmail Email address of the meeting host.
			HostEmail *openapi_types.Email `json:"host_email,omitempty"`

			// Id [Meeting ID](https://support.zoom.us/hc/en-us/articles/201362373-What-is-a-Meeting-ID-): Unique identifier of the meeting in &quot;**long**&quot; format(represented as int64 data type in JSON), also known as the meeting number.
			Id *int64 `json:"id,omitempty"`

			// JoinUrl URL for participants to join the meeting. This URL should only be shared with users that you would like to invite for the meeting.
			JoinUrl *string `json:"join_url,omitempty"`

			// Occurrences Array of occurrence objects.
			Occurrences *[]struct {
				// Duration Duration.
				Duration *int `json:"duration,omitempty"`

				// OccurrenceId Occurrence ID: Unique Identifier that identifies an occurrence of a recurring webinar. [Recurring webinars](https://support.zoom.us/hc/en-us/articles/216354763-How-to-Schedule-A-Recurring-Webinar) can have a maximum of 50 occurrences.
				OccurrenceId *string `json:"occurrence_id,omitempty"`

				// StartTime Start time.
				StartTime *time.Time `json:"start_time,omitempty"`

				// Status Occurrence status.
				Status *string `json:"status,omitempty"`
			} `json:"occurrences,omitempty"`

			// Password Meeting password. Password may only contain the following characters: `[a-z A-Z 0-9 @ - _ * !]`
			//
			// If &quot;Require a password when scheduling new meetings&quot; setting has been **enabled** **and** [locked](https://support.zoom.us/hc/en-us/articles/115005269866-Using-Tiered-Settings#locked) for the user, the password field will be autogenerated in the response even if it is not provided in the API request.
			//
			//
			Password *string `json:"password,omitempty"`

			// Pmi [Personal Meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
			Pmi *string `json:"pmi,omitempty"`

			// PreSchedule Whether the prescheduled meeting was created via the [GSuite app](https://support.zoom.us/hc/en-us/articles/360020187492-Zoom-for-GSuite-add-on). This **only** supports the meeting `type` value of `2` (scheduled meetings) and `3` (recurring meetings with no fixed time):
			// * `true` &mdash; A GSuite prescheduled meeting.
			// * `false` &mdash; A regular meeting.
			PreSchedule *bool `json:"pre_schedule,omitempty"`

			// Recurrence Recurrence object. Use this object only for a meeting with type `8` i.e., a recurring meeting with fixed time.
			Recurrence *struct {
				// EndDateTime Select the final date on which the meeting will recur before it is canceled. Should be in UTC time, such as 2017-11-25T12:00:00Z. (Cannot be used with &quot;end_times&quot;.)
				EndDateTime *time.Time `json:"end_date_time,omitempty"`

				// EndTimes Select how many times the meeting should recur before it is canceled. The default recurrence is 50 times. To support meetings recurring more than 50 times, contact Zoom support. Cannot be used with &quot;end_date_time&quot;.
				EndTimes *int `json:"end_times,omitempty"`

				// MonthlyDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state which day in a month, the meeting should recur. The value range is from 1 to 31.
				//
				// For instance, if you would like the meeting to recur on 23rd of each month, provide `23` as the value of this field and `1` as the value of the `repeat_interval` field. Instead, if you would like the meeting to recur every three months, on 23rd of the month, change the value of the `repeat_interval` field to `3`.
				MonthlyDay *int `json:"monthly_day,omitempty"`

				// MonthlyWeek Use this field **only if you're scheduling a recurring meeting of type** `3` to state the week of the month when the meeting should recur. If you use this field, **you must also use the `monthly_week_day` field to state the day of the week when the meeting should recur.**
				//  `-1` - Last week of the month.
				//  `1` - First week of the month.
				//  `2` - Second week of the month.
				//  `3` - Third week of the month.
				//  `4` - Fourth week of the month.
				MonthlyWeek *int `json:"monthly_week,omitempty"`

				// MonthlyWeekDay Use this field **only if you're scheduling a recurring meeting of type** `3` to state a specific day in a week when the monthly meeting should recur. To use this field, you must also use the `monthly_week` field.
				//
				//
				//  `1` - Sunday.
				//  `2` - Monday.
				//  `3` - Tuesday.
				//  `4` -  Wednesday.
				//  `5` - Thursday.
				//  `6` - Friday.
				//  `7` - Saturday.
				MonthlyWeekDay *int `json:"monthly_week_day,omitempty"`

				// RepeatInterval Define the interval at which the meeting should recur. For instance, if you would like to schedule a meeting that recurs every two months, you must set the value of this field as `2` and the value of the `type` parameter as `3`.
				//
				// For a daily meeting, the maximum interval you can set is `90` days. For a weekly meeting the maximum interval that you can set is  of `12` weeks. For a monthly meeting, there is a maximum of `3` months.
				//
				RepeatInterval *int `json:"repeat_interval,omitempty"`

				// Type Recurrence meeting types:
				//  `1` - Daily.
				//  `2` - Weekly.
				//  `3` - Monthly.
				Type int `json:"type"`

				// WeeklyDays This field is required **if you're scheduling a recurring meeting of type** `2` to state which day(s) of the week the meeting should repeat.
				//
				//   The value for this field could be a number between `1` to `7` in string format. For instance, if the meeting should recur on Sunday, provide `&quot;1&quot;` as the value of this field.
				//
				//   **Note:** If you would like the meeting to occur on multiple days of a week, you should provide comma separated values for this field. For instance, if the meeting should recur on Sundays and Tuesdays provide `&quot;1,3&quot;` as the value of this field.
				//
				//
				//  `1`  - Sunday.
				//  `2` - Monday.
				//  `3` - Tuesday.
				//  `4` -  Wednesday.
				//  `5` -  Thursday.
				//  `6` - Friday.
				//  `7` - Saturday.
				WeeklyDays *string `json:"weekly_days,omitempty"`
			} `json:"recurrence,omitempty"`

			// RegistrationUrl URL using which registrants can register for a meeting. This field is only returned for meetings that have enabled registration.
			RegistrationUrl *string `json:"registration_url,omitempty"`

			// Settings Meeting settings.
			Settings *struct {
				// AllowMultipleDevices Allow attendees to join the meeting from multiple devices. This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
				AllowMultipleDevices *bool `json:"allow_multiple_devices,omitempty"`

				// AlternativeHostUpdatePolls Whether the **Allow alternative hosts to add or edit polls** feature is enabled. This requires Zoom version 5.8.0 or higher.
				AlternativeHostUpdatePolls *bool `json:"alternative_host_update_polls,omitempty"`

				// AlternativeHosts A semicolon-separated list of the meeting's alternative hosts' email addresses or IDs.
				AlternativeHosts *string `json:"alternative_hosts,omitempty"`

				// AlternativeHostsEmailNotification Flag to determine whether to send email notifications to alternative hosts, default value is true.
				AlternativeHostsEmailNotification *bool `json:"alternative_hosts_email_notification,omitempty"`

				// ApprovalType Enable registration and set approval for the registration. Note that this feature requires the host to be of **Licensed** user type. **Registration cannot be enabled for a basic user.**
				//
				//
				//
				// `0` - Automatically approve.
				//  `1` - Manually approve.
				//  `2` - No registration required.
				ApprovalType *int `json:"approval_type,omitempty"`

				// ApprovedOrDeniedCountriesOrRegions Approve or block users from specific regions/countries from joining this meeting.
				ApprovedOrDeniedCountriesOrRegions *struct {
					// ApprovedList List of countries/regions from where participants can join this meeting.
					ApprovedList *[]string `json:"approved_list,omitempty"`

					// DeniedList List of countries/regions from where participants can not join this meeting.
					DeniedList *[]string `json:"denied_list,omitempty"`

					// Enable `true`: Setting enabled to either allow users or block users from specific regions to join your meetings.
					//
					//
					// `false`: Setting disabled.
					Enable *bool `json:"enable,omitempty"`

					// Method Specify whether to allow users from specific regions to join this meeting; or block users from specific regions from joining this meeting.
					//
					//
					// `approve`: Allow users from specific regions/countries to join this meeting. If this setting is selected, the approved regions/countries must be included in the `approved_list`.
					//
					//
					// `deny`: Block users from specific regions/countries from joining this meeting. If this setting is selected, the approved regions/countries must be included in the `denied_list`
					Method *string `json:"method,omitempty"`
				} `json:"approved_or_denied_countries_or_regions,omitempty"`

				// Audio Determine how participants can join the audio portion of the meeting.
				//  `both` - Both Telephony and VoIP.
				//  `telephony` - Telephony only.
				//  `voip` - VoIP only.
				//  `thirdParty` - Third party audio conference.
				Audio *string `json:"audio,omitempty"`

				// AudioConferenceInfo Third party audio conference info.
				AudioConferenceInfo *string `json:"audio_conference_info,omitempty"`

				// AuthenticationDomains If user has configured [&quot;Sign Into Zoom with Specified Domains&quot;](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f) option, this will list the domains that are authenticated.
				AuthenticationDomains *string `json:"authentication_domains,omitempty"`

				// AuthenticationException The participants added here will receive unique meeting invite links and bypass authentication.
				AuthenticationException *[]struct {
					// Email Email address of the participant.
					Email *openapi_types.Email `json:"email,omitempty"`

					// JoinUrl URL for participants to join the meeting
					JoinUrl *string `json:"join_url,omitempty"`

					// Name Name of the participant.
					Name *string `json:"name,omitempty"`
				} `json:"authentication_exception,omitempty"`

				// AuthenticationName Authentication name set in the [authentication profile](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars#h_5c0df2e1-cfd2-469f-bb4a-c77d7c0cca6f).
				AuthenticationName *string `json:"authentication_name,omitempty"`

				// AuthenticationOption Meeting authentication option id.
				AuthenticationOption *string `json:"authentication_option,omitempty"`

				// AutoRecording Automatic recording:
				//  `local` - Record on local.
				//  `cloud` -  Record on cloud.
				//  `none` - Disabled.
				AutoRecording *string `json:"auto_recording,omitempty"`

				// BreakoutRoom Setting to [pre-assign breakout rooms](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4).
				BreakoutRoom *struct {
					// Enable Set the value of this field to `true` if you would like to enable the [breakout room pre-assign](https://support.zoom.us/hc/en-us/articles/360032752671-Pre-assigning-participants-to-breakout-rooms#h_36f71353-4190-48a2-b999-ca129861c1f4) option.
					Enable *bool `json:"enable,omitempty"`

					// Rooms Create room(s).
					Rooms *[]struct {
						// Name Name of the breakout room.
						Name *string `json:"name,omitempty"`

						// Participants Email addresses of the participants who are to be assigned to the breakout room.
						Participants *[]string `json:"participants,omitempty"`
					} `json:"rooms,omitempty"`
				} `json:"breakout_room,omitempty"`

				// CalendarType Indicates the type of calendar integration used to schedule the meeting:
				// * `1` &mdash; [Zoom Outlook add-in](https://support.zoom.us/hc/en-us/articles/360031592971-Getting-started-with-Outlook-plugin-and-add-in)
				// * `2` &mdash; [Zoom for Google Workspace add-on](https://support.zoom.us/hc/en-us/articles/360020187492-Using-the-Zoom-for-Google-Workspace-add-on)
				//
				// Works with the `private_meeting` field to determine whether to share details of meetings or not.
				CalendarType *int `json:"calendar_type,omitempty"`

				// CloseRegistration Close registration after event date
				CloseRegistration *bool `json:"close_registration,omitempty"`

				// CnMeeting Host meeting in China.
				// Deprecated:
				CnMeeting *bool `json:"cn_meeting,omitempty"`

				// ContactEmail Contact email for registration
				ContactEmail *string `json:"contact_email,omitempty"`

				// ContactName Contact name for registration
				ContactName *string `json:"contact_name,omitempty"`

				// CustomKeys Custom keys and values assigned to the meeting.
				CustomKeys *[]struct {
					// Key Custom key associated with the user.
					Key *string `json:"key,omitempty"`

					// Value Value of the custom key associated with the user.
					Value *string `json:"value,omitempty"`
				} `json:"custom_keys,omitempty"`

				// EmailNotification Whether to send email notifications to [alternative hosts](https://support.zoom.us/hc/en-us/articles/208220166) and [users with scheduling privileges](https://support.zoom.us/hc/en-us/articles/201362803-Scheduling-privilege). This value defaults to `true`.
				EmailNotification *bool `json:"email_notification,omitempty"`

				// EncryptionType Choose between enhanced encryption and [end-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871) when starting or a meeting. When using end-to-end encryption, several features (e.g. cloud recording, phone/SIP/H.323 dial-in) will be **automatically disabled**.
				//
				//  The value of this field can be one of the following:
				//
				// `enhanced_encryption`: Enhanced encryption. Encryption is stored in the cloud if you enable this option.
				//
				//
				// `e2ee`: [End-to-end encryption](https://support.zoom.us/hc/en-us/articles/360048660871). The encryption key is stored in your local device and can not be obtained by anyone else. Enabling this setting also **disables** the following features: join before host, cloud recording, streaming, live transcription, breakout rooms, polling, 1:1 private chat, and meeting reactions.
				EncryptionType *string `json:"encryption_type,omitempty"`

				// EnforceLogin Only signed in users can join this meeting.
				//
				// **This field is deprecated and will not be supported in the future.**
				//
				//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
				// Deprecated:
				EnforceLogin *bool `json:"enforce_login,omitempty"`

				// EnforceLoginDomains Only signed in users with specified domains can join meetings.
				//
				// **This field is deprecated and will not be supported in the future.**
				//
				//  As an alternative, use the &quot;meeting_authentication&quot;, &quot;authentication_option&quot; and &quot;authentication_domains&quot; fields to understand the [authentication configurations](https://support.zoom.us/hc/en-us/articles/360037117472-Authentication-Profiles-for-Meetings-and-Webinars) set for the meeting.
				// Deprecated:
				EnforceLoginDomains *string `json:"enforce_login_domains,omitempty"`

				// FocusMode Whether the [**Focus Mode** feature](https://support.zoom.us/hc/en-us/articles/360061113751-Using-focus-mode) is enabled when the meeting starts.
				FocusMode *bool `json:"focus_mode,omitempty"`

				// GlobalDialInCountries List of global dial-in countries
				GlobalDialInCountries *[]string `json:"global_dial_in_countries,omitempty"`

				// GlobalDialInNumbers Global Dial-in Countries/Regions
				GlobalDialInNumbers *[]struct {
					// City City of the number, if any. For example, Chicago.
					City *string `json:"city,omitempty"`

					// Country Country code. For example, BR.
					Country *string `json:"country,omitempty"`

					// CountryName Full name of country. For example, Brazil.
					CountryName *string `json:"country_name,omitempty"`

					// Number Phone number. For example, +1 2332357613.
					Number *string `json:"number,omitempty"`

					// Type Type of number.
					Type *string `json:"type,omitempty"`
				} `json:"global_dial_in_numbers,omitempty"`

				// HostSaveVideoOrder Whether the **Allow host to save video order** feature is enabled.
				HostSaveVideoOrder *bool `json:"host_save_video_order,omitempty"`

				// HostVideo Start video when the host joins the meeting.
				HostVideo *bool `json:"host_video,omitempty"`

				// InMeeting Host meeting in India.
				// Deprecated:
				InMeeting *bool `json:"in_meeting,omitempty"`

				// JbhTime If the value of &quot;join_before_host&quot; field is set to true, this field can be used to indicate time limits within which a participant may join a meeting before a host. The value of this field can be one of the following:
				//
				// *  `0`: Allow participant to join anytime.
				// *  `5`: Allow participant to join 5 minutes before meeting start time.
				//  * `10`: Allow participant to join 10 minutes before meeting start time.
				JbhTime *int `json:"jbh_time,omitempty"`

				// JoinBeforeHost Allow participants to join the meeting before the host starts the meeting. Only used for scheduled or recurring meetings.
				JoinBeforeHost *bool `json:"join_before_host,omitempty"`

				// LanguageInterpretation The meeting's [language interpretation settings](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars). Make sure to add the language in the web portal in order to use it in the API. See link for details.
				//
				// **Note:** This feature is only available for certain Meeting add-on, Education, and Business and higher plans. If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
				LanguageInterpretation *struct {
					// Enable Whether to enable [language interpretation](https://support.zoom.us/hc/en-us/articles/360034919791-Language-interpretation-in-meetings-and-webinars) for the meeting.
					Enable *bool `json:"enable,omitempty"`

					// Interpreters Information about the meeting's language interpreters.
					Interpreters *[]struct {
						// Email The interpreter's email address.
						Email *openapi_types.Email `json:"email,omitempty"`

						// Languages A comma-separated list of the interpreter's languages. The string must contain two [country IDs](/docs/api/rest/other-references/abbreviation-lists/#countries).
						//
						// For example, if the interpreter will translate from English to Chinese, then this value will be `US,CN`.
						Languages *string `json:"languages,omitempty"`
					} `json:"interpreters,omitempty"`
				} `json:"language_interpretation,omitempty"`

				// MeetingAuthentication `true`- Only authenticated users can join meetings.
				MeetingAuthentication *bool `json:"meeting_authentication,omitempty"`

				// MuteUponEntry Mute participants upon entry.
				MuteUponEntry *bool `json:"mute_upon_entry,omitempty"`

				// ParticipantVideo Start video when participants join the meeting.
				ParticipantVideo *bool `json:"participant_video,omitempty"`

				// PrivateMeeting Whether the meeting is set as private.
				PrivateMeeting *bool `json:"private_meeting,omitempty"`

				// RegistrantsConfirmationEmail Whether to send registrants an email confirmation.
				// * `true` - Send a confirmation email.
				// * `false` - Do not send a confirmation email.
				RegistrantsConfirmationEmail *bool `json:"registrants_confirmation_email,omitempty"`

				// RegistrantsEmailNotification Whether to send registrants email notifications about their registration approval, cancellation, or rejection.
				//
				// * `true` - Send an email notification.
				// * `false` - Do not send an email notification.
				//
				//  Set this value to `true` to also use the `registrants_confirmation_email` parameter.
				RegistrantsEmailNotification *bool `json:"registrants_email_notification,omitempty"`

				// RegistrationType Registration type. Used for recurring meeting with fixed time only.
				//  `1` Attendees register once and can attend any of the occurrences.
				//  `2` Attendees need to register for each occurrence to attend.
				//  `3` Attendees register once and can choose one or more occurrences to attend.
				RegistrationType *int `json:"registration_type,omitempty"`

				// ShowShareButton Show social share buttons on the meeting registration page.
				// This setting only works for meetings that require [registration](https://support.zoom.us/hc/en-us/articles/211579443-Setting-up-registration-for-a-meeting).
				ShowShareButton *bool `json:"show_share_button,omitempty"`

				// SignLanguageInterpretation The meeting's [sign language interpretation settings](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar). Make sure to add the language in the web portal in order to use it in the API. See link for details.
				//
				// **Note:** If this feature is not enabled on the host's account, this setting will **not** be applied to the meeting.
				SignLanguageInterpretation *struct {
					// Enable Whether to enable [sign language interpretation](https://support.zoom.us/hc/en-us/articles/9644962487309-Using-sign-language-interpretation-in-a-meeting-or-webinar) for the meeting.
					Enable *bool `json:"enable,omitempty"`

					// Interpreters Information about the meeting's sign language interpreters.
					Interpreters *[]struct {
						// Email The interpreter's email address.
						Email *openapi_types.Email `json:"email,omitempty"`

						// SignLanguage The interpreter's sign language.
						//
						//  To get this value, use the `sign_language_interpretation` object's `languages` and `custom_languages` values in the [**Get user settings**](/api-reference/zoom-api/methods#operation/userSettings) API response.
						SignLanguage *string `json:"sign_language,omitempty"`
					} `json:"interpreters,omitempty"`
				} `json:"sign_language_interpretation,omitempty"`

				// UsePmi Use a [Personal Meeting ID (PMI)](/docs/api/rest/using-zoom-apis/#understanding-personal-meeting-id-pmi). Only used for scheduled meetings and recurring meetings with no fixed time.
				UsePmi *bool `json:"use_pmi,omitempty"`

				// WaitingRoom Enable waiting room
				WaitingRoom *bool `json:"waiting_room,omitempty"`

				// Watermark Add watermark when viewing a shared screen.
				Watermark *bool `json:"watermark,omitempty"`
			} `json:"settings,omitempty"`

			// StartTime Meeting start date-time in UTC/GMT. Example: &quot;2020-03-31T12:02:00Z&quot;
			StartTime *time.Time `json:"start_time,omitempty"`

			// StartUrl URL to start the meeting. This URL should only be used by the host of the meeting and **should not be shared with anyone other than the host** of the meeting as anyone with this URL will be able to login to the Zoom Client as the host of the meeting.
			StartUrl *string `json:"start_url,omitempty"`

			// Timezone Timezone to format start_time
			Timezone *string `json:"timezone,omitempty"`

			// Topic Meeting topic
			Topic *string `json:"topic,omitempty"`

			// TrackingFields Tracking fields
			TrackingFields *[]struct {
				// Field Label of the tracking field.
				Field *string `json:"field,omitempty"`

				// Value Value for the field.
				Value *string `json:"value,omitempty"`

				// Visible Indicates whether the [tracking field](https://support.zoom.us/hc/en-us/articles/115000293426-Scheduling-Tracking-Fields) is visible in the meeting scheduling options in the Zoom Web Portal or not.
				//
				// `true`: Tracking field is visible.
				//
				//
				// `false`: Tracking field is not visible to the users in the meeting options in the Zoom Web Portal but the field was used while scheduling this meeting via API. An invisible tracking field can be used by users while scheduling meetings via API only.
				Visible *bool `json:"visible,omitempty"`
			} `json:"tracking_fields,omitempty"`

			// Type Meeting Type
			Type *int `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserPasswordResponse parses an HTTP response from a UserPasswordWithResponse call
func ParseUserPasswordResponse(rsp *http.Response) (*UserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserPermissionResponse parses an HTTP response from a UserPermissionWithResponse call
func ParseUserPermissionResponse(rsp *http.Response) (*UserPermissionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserPermissionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Permissions List of user permissions.
			Permissions *[]string `json:"permissions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserPictureDeleteResponse parses an HTTP response from a UserPictureDeleteWithResponse call
func ParseUserPictureDeleteResponse(rsp *http.Response) (*UserPictureDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserPictureDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserPictureResponse parses an HTTP response from a UserPictureWithResponse call
func ParseUserPictureResponse(rsp *http.Response) (*UserPictureResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserPictureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdatePresenceStatusResponse parses an HTTP response from a UpdatePresenceStatusWithResponse call
func ParseUpdatePresenceStatusResponse(rsp *http.Response) (*UpdatePresenceStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePresenceStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserSchedulersDeleteResponse parses an HTTP response from a UserSchedulersDeleteWithResponse call
func ParseUserSchedulersDeleteResponse(rsp *http.Response) (*UserSchedulersDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSchedulersDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserSchedulersResponse parses an HTTP response from a UserSchedulersWithResponse call
func ParseUserSchedulersResponse(rsp *http.Response) (*UserSchedulersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSchedulersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Schedulers List of users for whom the current user can schedule meetings.
			Schedulers *[]struct {
				// Email Email address of the scheduler.
				Email *string `json:"email,omitempty"`

				// Id Unique Identifier (User ID) of the Scheduler.
				Id *string `json:"id,omitempty"`

				// Pmi PMI of the meeting host in long (int64) format.
				Pmi *int64 `json:"pmi,omitempty"`
			} `json:"schedulers,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserSchedulerDeleteResponse parses an HTTP response from a UserSchedulerDeleteWithResponse call
func ParseUserSchedulerDeleteResponse(rsp *http.Response) (*UserSchedulerDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSchedulerDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserSettingsResponse parses an HTTP response from a UserSettingsWithResponse call
func ParseUserSettingsResponse(rsp *http.Response) (*UserSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUserSettingsUpdateResponse parses an HTTP response from a UserSettingsUpdateWithResponse call
func ParseUserSettingsUpdateResponse(rsp *http.Response) (*UserSettingsUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSettingsUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDelUserVBResponse parses an HTTP response from a DelUserVBWithResponse call
func ParseDelUserVBResponse(rsp *http.Response) (*DelUserVBResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DelUserVBResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadVBuserResponse parses an HTTP response from a UploadVBuserWithResponse call
func ParseUploadVBuserResponse(rsp *http.Response) (*UploadVBuserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadVBuserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Id The virtual background file's ID.
			Id *string `json:"id,omitempty"`

			// IsDefault Whether the virtual background file is set as the default virtual background:
			// * `true` &mdash; The default virtual background.
			// * `false` &mdash; Not the default virtual background.
			IsDefault *bool `json:"is_default,omitempty"`

			// Name The virtual background file's name.
			Name *string `json:"name,omitempty"`

			// Size The virtual background file's size, in bytes.
			Size *int `json:"size,omitempty"`

			// Type The virtual background file's file type:
			// * `image` &mdash; An image file.
			// * `video` &mdash; A video file.
			Type *string `json:"type,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseUserStatusResponse parses an HTTP response from a UserStatusWithResponse call
func ParseUserStatusResponse(rsp *http.Response) (*UserStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserSSOTokenDeleteResponse parses an HTTP response from a UserSSOTokenDeleteWithResponse call
func ParseUserSSOTokenDeleteResponse(rsp *http.Response) (*UserSSOTokenDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserSSOTokenDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUserTokenResponse parses an HTTP response from a UserTokenWithResponse call
func ParseUserTokenResponse(rsp *http.Response) (*UserTokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UserTokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Token The user's ZAK or token value.
			Token *string `json:"token,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
